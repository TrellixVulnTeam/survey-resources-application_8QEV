/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{glsl as e}from"../views/3d/webgl-engine/core/shaderModules/interfaces.js";import{Transform as a}from"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js";import{ShaderBuilder as o}from"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js";import{ColorConversion as i}from"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js";import{Slice as r}from"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js";import{ReadLinearDepth as d}from"../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl.js";import{OutputHighlight as l}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js";import{multipassTerrainTest as n}from"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js";import{OutputDepth as t}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js";import{ReadShadowMap as s}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js";import{ForwardLinearDepth as c}from"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js";import{NormalUtils as m}from"../views/3d/webgl-engine/core/shaderLibrary/shading/NormalUtils.glsl.js";import{EvaluateAmbientOcclusion as g}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl.js";import{EvaluateSceneLighting as v}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js";import{Normals as p}from"../views/3d/webgl-engine/core/shaderLibrary/shading/Normals.glsl.js";import{PathVertexPosition as u}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/PathVertexPosition.glsl.js";function h(h){const f=new o;return f.vertex.uniforms.add("proj","mat4").add("view","mat4").add("camPos","vec3").add("localOrigin","vec3"),f.varyings.add("vpos","vec3"),f.include(u,h),0!==h.output&&7!==h.output||(f.include(a,{linearDepth:!1}),h.receiveShadows&&f.include(s,h),f.include(c,h),f.varyings.add("vnormal","vec3"),f.varyings.add("vcolor","vec4"),h.multipassTerrainEnabled&&f.varyings.add("depth","float"),f.vertex.code.add(e`
      void main() {
        vpos = calculateVPos();
        vnormal = normalize(localNormal());

        ${h.multipassTerrainEnabled?"depth = (view * vec4(vpos, 1.0)).z;":""}
        gl_Position = transformPosition(proj, view, vpos);

        ${0===h.output?"forwardLinearDepth();":""}

        vcolor = getColor();
      }
    `)),h.multipassTerrainEnabled&&(f.fragment.include(d),f.include(n,h)),7===h.output&&(f.include(r,h),f.fragment.uniforms.add("camPos","vec3"),f.fragment.uniforms.add("localOrigin","vec3"),f.fragment.uniforms.add("opacity","float"),f.fragment.code.add(e`
      void main() {
        discardBySlice(vpos);
        ${h.multipassTerrainEnabled?"terrainDepthTest(gl_FragCoord, depth);":""}
        float combinedOpacity = vcolor.a * opacity;
        gl_FragColor = vec4(combinedOpacity);
      }
    `)),0===h.output&&(f.include(r,h),f.include(v,h),f.include(g,h),h.receiveShadows&&f.include(s,h),f.include(p,h),f.fragment.uniforms.add("camPos","vec3").add("localOrigin","vec3").add("ambient","vec3").add("diffuse","vec3").add("specular","vec3").add("opacity","float"),f.fragment.include(i),f.fragment.code.add(e`
      void main() {
        discardBySlice(vpos);
        ${h.multipassTerrainEnabled?"terrainDepthTest(gl_FragCoord, depth);":""}

        shadingParams.viewDirection = normalize(vpos - camPos);
        shadingParams.normalView = vnormal;
        vec3 normal = shadingNormal(shadingParams);
        float ssao = evaluateAmbientOcclusionInverse();

        float additionalAmbientScale = _oldHeuristicLighting(vpos + localOrigin);
        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;
    `),h.receiveShadows?f.fragment.code.add(e`
        float shadow = readShadowMap(vpos, linearDepth);
      `):1===h.viewingMode?f.fragment.code.add(e`
        float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);
      `):f.fragment.code.add(e`
        float shadow = 0.0;
      `),f.fragment.code.add(e`
        vec3 albedo = vcolor.rgb * max(ambient, diffuse); // combine the old material parameters into a single one
        float combinedOpacity = vcolor.a * opacity;
        albedo += 0.25 * specular; // don't completely ignore specular for now

        vec3 shadedColor = evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight);
        gl_FragColor = vec4(shadedColor, combinedOpacity);
        gl_FragColor = highlightSlice(gl_FragColor, vpos);
        ${h.OITEnabled?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}
      }
    `)),1!==h.output&&3!==h.output||(f.include(a,{linearDepth:!0}),f.vertex.uniforms.add("nearFar","vec2"),f.varyings.add("depth","float"),f.vertex.code.add(e`
        void main() {
          vpos = calculateVPos();
          gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);
        }
    `),f.include(r,h),f.include(t,h),f.fragment.uniforms.add("timeElapsed","float"),f.fragment.code.add(e`
        void main() {
          discardBySlice(vpos);
          outputDepth(depth);
        }
    `)),2===h.output&&(f.include(a,{linearDepth:!1}),f.include(m,h),f.vertex.uniforms.add("viewNormal","mat4"),f.varyings.add("vnormal","vec3"),f.vertex.code.add(e`
        void main(void) {
          vpos = calculateVPos();
          vnormal = normalize((viewNormal * vec4(localNormal(), 1.0)).xyz);
          gl_Position = transformPosition(proj, view, vpos);
        }
    `),f.include(r,h),f.fragment.uniforms.add("waterColor","vec4"),f.fragment.code.add(e`
        void main() {
          discardBySlice(vpos);
          vec3 normal = normalize(vnormal);
          if (gl_FrontFacing == false) normal = -normal;
          gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);
        }
    `)),4===h.output&&(f.include(a,{linearDepth:!1}),f.include(m,h),f.vertex.uniforms.add("viewNormal","mat4"),f.varyings.add("vnormal","vec3"),f.vertex.code.add(e`
        void main(void) {
          vpos = calculateVPos();
          gl_Position = transformPosition(proj, view, vpos);
        }
    `),f.include(r,h),f.include(l),f.fragment.code.add(e`
      void main() {
        discardBySlice(vpos);
        outputHighlight();
      }
    `)),f}var f=Object.freeze({__proto__:null,build:h});export{f as P,h as b};
