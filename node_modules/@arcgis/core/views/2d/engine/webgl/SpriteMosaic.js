/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import"../../../../core/has.js";import{isSome as t}from"../../../../core/maybe.js";import e from"../../../../core/Error.js";import{SPRITE_PADDING as i}from"./definitions.js";import"../../../../chunks/builtins.js";import"../../../webgl/checkWebGLError.js";import s from"../../../webgl/Texture.js";import"../../../webgl/FramebufferObject.js";import a from"./Rect.js";import{log2 as r}from"./GeometryUtils.js";import o from"./RectangleBinPack.js";function h(t){return t&&"static"===t.type}class c{constructor(t,e,i,s=0){this._mosaicPages=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects=new Map,this._spriteCopyQueue=[],this.pixelRatio=1,(e<=0||i<=0)&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=e,this._pageHeight=i,this._requestRender=t,s>0&&(this._maxItemSize=s),this.pixelRatio=window.devicePixelRatio||1,this._binPack=new o(this._pageWidth,this._pageHeight);const a=Math.floor(this._pageWidth),r=Math.floor(this._pageHeight);this._mosaicPages.push({mosaicsData:{type:"static",data:new Uint32Array(a*r)},size:[this._pageWidth,this._pageHeight],dirty:!0,texture:void 0})}getWidth(t){return t>=this._mosaicPages.length?-1:this._mosaicPages[t].size[0]}getHeight(t){return t>=this._mosaicPages.length?-1:this._mosaicPages[t].size[1]}getPageTexture(t){return t<this._mosaicPages.length?this._mosaicPages[t].texture:null}has(t){return this._mosaicRects.has(t)}get itemCount(){return this._mosaicRects.size}getSpriteItem(t){return this._mosaicRects.get(t)}addSpriteItem(t,e,i,s,r,o){if(this._mosaicRects.has(t))return this._mosaicRects.get(t);let c,n,g;if(h(i))[c,n,g]=this._allocateImage(e[0],e[1]);else{c=new a(0,0,e[0],e[1]),n=this._mosaicPages.length;const t=void 0;this._mosaicPages.push({mosaicsData:i,size:e,dirty:!0,texture:t})}if(c.width<=0||c.height<=0)return null;const m={rect:c,width:e[0],height:e[1],sdf:r,simplePattern:o,pixelRatio:1,page:n};return this._mosaicRects.set(t,m),h(i)&&this._copy({rect:c,spriteSize:e,spriteData:i.data,page:n,pageSize:g,repeat:s,sdf:r}),m}hasItemsToProcess(){return 0!==this._spriteCopyQueue.length}processNextItem(){const t=this._spriteCopyQueue.pop();t&&this._copy(t)}getSpriteItems(t){const e={};for(const i of t)e[i]=this.getSpriteItem(i);return e}getMosaicItemPosition(t){const e=this.getSpriteItem(t),s=e&&e.rect;if(!s)return null;s.width=e.width,s.height=e.height;const a=e.width,r=e.height,o=i,h=this._mosaicPages[e.page];return{size:[e.width,e.height],tl:[(s.x+o)/h[0],(s.y+o)/h[1]],br:[(s.x+o+a)/h[0],(s.y+o+r)/h[1]],page:e.page}}bind(e,i,s=0,a=0){const r=this._mosaicPages[s],o=r.mosaicsData;let c=r.texture;if(c||(c=n(e,o,r.size),r.texture=c),c.setSamplingMode(i),h(o))e.bindTexture(c,a),r.dirty&&(c.setData(new Uint8Array(o.data.buffer)),c.generateMipmap());else{const i=o.data,s=i.bindFrame(e,c,a);t(this._requestRender)&&s&&i.frameCount>0&&this._requestRender.requestRender(),i.bindFrame(e,c,a)}r.dirty=!1}static _copyBits(t,e,i,s,a,r,o,h,c,n,g){let m=s*e+i,p=h*r+o;if(g){p-=r;for(let o=-1;o<=n;o++,m=((o+n)%n+s)*e+i,p+=r)for(let e=-1;e<=c;e++)a[p+e]=t[m+(e+c)%c]}else for(let u=0;u<n;u++){for(let e=0;e<c;e++)a[p+e]=t[m+e];m+=e,p+=r}}_copy(t){if(t.page>=this._mosaicPages.length)return;const s=this._mosaicPages[t.page],a=s.mosaicsData;if(!h(s.mosaicsData))throw new e("mapview-invalid-resource","unsuitable data type!");const r=t.spriteData,o=a.data;o&&r||console.error("Source or target images are uninitialized!"),c._copyBits(r,t.spriteSize[0],0,0,o,t.pageSize[0],t.rect.x+i,t.rect.y+i,t.spriteSize[0],t.spriteSize[1],t.repeat),s.dirty=!0}_allocateImage(t,e){t+=2*i,e+=2*i;const s=Math.max(t,e);if(this._maxItemSize&&this._maxItemSize<s){const i=2**Math.ceil(r(t)),s=2**Math.ceil(r(e)),o=new a(0,0,t,e);return this._mosaicPages.push({mosaicsData:{type:"static",data:new Uint32Array(i*s)},size:[i,s],dirty:!0,texture:void 0}),[o,this._mosaicPages.length-1,[i,s]]}const c=this._binPack.allocate(t,e);if(c.width<=0){const i=this._mosaicPages[this._currentPage];return!i.dirty&&h(i.mosaicsData)&&(i.mosaicsData.data=null),this._currentPage=this._mosaicPages.length,this._mosaicPages.push({mosaicsData:{type:"static",data:new Uint32Array(this._pageWidth*this._pageHeight)},size:[this._pageWidth,this._pageHeight],dirty:!0,texture:void 0}),this._binPack=new o(this._pageWidth,this._pageHeight),this._allocateImage(t,e)}return[c,this._currentPage,[this._pageWidth,this._pageHeight]]}dispose(){this._binPack=null;for(const t of this._mosaicPages){const e=t.texture;e&&e.dispose();const i=t.mosaicsData;if(!h(i)){i.data.pause()}}this._mosaicPages=null,this._mosaicRects.clear()}}function n(t,e,i){return h(e)?new s(t,{pixelFormat:6408,dataType:5121,width:i[0],height:i[1]},new Uint8Array(e.data.buffer)):new s(t,{pixelFormat:6408,dataType:5121,samplingMode:9729,wrapMode:33071,width:i[0],height:i[1]},null)}export default c;
