/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{isNone as e}from"../../../../../../core/maybe.js";import{THIN_LINE_THRESHOLD as t}from"../../definitions.js";import{i1616to32 as r,i8888to32 as i}from"../../number.js";import{WGLGeometryType as s}from"../../enums.js";import{LineMaterialKey as n}from"../../materialKey/MaterialKey.js";import{clipLinesMarshall as o}from"./templateUtils.js";import{StandardTessellationCallbacks as l,tessellate as a,cleanup as x}from"../../TurboLine.js";const h=8,u=31,d=1024,v=65535,c=1/3.8,W=r=>class extends r{constructor(...e){super(...e),this.tessellationProperties={},this._tessellationOptions={},this.geometryType=s.LINE}_initializeTessellator(e){const r=n.load(this._materialKey),i=this._tessellationOptions,s=r.vvSizeFieldStops||r.vvSizeMinMaxValue||r.vvSizeScaleStops||r.vvSizeUnitValue,o=this.tessellationProperties._halfWidth<t/2;if(i.thin=o&&!e&&!s,i.trackDistance=this._isDashed||this._hasPattern,i.wrapDistance=v,i.innerBisectorAutoSplitThreshold=c,i.outerBisectorAutoSplitThreshold=c,i.enableInnerBisectorSplit=this._isDashed||this._hasPattern,i.enableOuterBisectorSplit=this._isDashed||this._hasPattern,i.thin)return void(this._tessellationCallbacks={vertex:_(this.tessellationProperties),bridge:p(this.tessellationProperties)});const a=new l(f(this.tessellationProperties),m(this.tessellationProperties));a.miterLimitCosine=this._miterLimitCosine,a.textured=this._isDashed||this._hasPattern,a.joinOnUTurn=this._joinOnUTurn,this._tessellationCallbacks=a}_write(e,t,r){const i="esriGeometryPoint"===t.geometryType;e.recordStart(t.getDisplayId(),this._materialKey,this.geometryType,!1,i),this._writeGeometry(e,t,r,i),e.recordEnd()}_writeGeometry(t,r,i,s){const n=null!=i?i:r.readLegacyGeometry(),o=this._getLines(n,s);e(o)||this._writeVertices(t,r,o)}_getLines(t,r){if(e(t))return null;const i=t.paths||t.rings;if(e(i))return null;return o(i,r?256:16)}_writeVertices(e,t,r){const i=t.getDisplayId(),s=e.vertexCount(),n=this.tessellationProperties;n.out=e,n.id=i,n.indexCount=0,n.vertexCount=0,n.offset=s;for(const{line:o,start:h}of r)this._tessellationOptions.initialDistance=h%v,this._tessellationCallbacks instanceof l&&(this._tessellationCallbacks.capType=this._capType,this._tessellationCallbacks.joinType=this._joinType),a(o,this._tessellationOptions,this._tessellationCallbacks),x()}},_=e=>t=>{const s=e.out,n=Math.ceil(d*e._halfWidth),o=Math.ceil(d*e._halfReferenceWidth);t.entry0=e.offset+e.vertexCount++;{const l=r(t.distance,n),a=i(Math.round(u*t.prevNormal.x),Math.round(u*t.prevNormal.y),Math.round(0*u),Math.round(-1*u)),x=i(0,0,0,e._bitset);s.vertexBounds(t.currentVertex.x,t.currentVertex.y,0,0),s.vertexWrite(r(h*t.currentVertex.x,h*t.currentVertex.y)),s.vertexWrite(e.id),s.vertexWrite(e._fillColor),s.vertexWrite(a),s.vertexWrite(l),s.vertexWrite(e._tl),s.vertexWrite(e._br),s.vertexWrite(x),s.vertexWrite(r(o,0)),s.vertexEnd()}t.entry2=e.offset+e.vertexCount++;{const l=r(t.distance,n),a=i(Math.round(u*-t.prevNormal.x),Math.round(u*-t.prevNormal.y),Math.round(0*u),Math.round(1*u)),x=i(0,0,0,e._bitset);s.vertexBounds(t.currentVertex.x,t.currentVertex.y,0,0),s.vertexWrite(r(h*t.currentVertex.x,h*t.currentVertex.y)),s.vertexWrite(e.id),s.vertexWrite(e._fillColor),s.vertexWrite(a),s.vertexWrite(l),s.vertexWrite(e._tl),s.vertexWrite(e._br),s.vertexWrite(x),s.vertexWrite(r(o,0)),s.vertexEnd()}t.exit0=e.offset+e.vertexCount++;{const l=r(t.distance,n),a=i(Math.round(u*t.nextNormal.x),Math.round(u*t.nextNormal.y),Math.round(0*u),Math.round(-1*u)),x=i(0,0,0,e._bitset);s.vertexBounds(t.currentVertex.x,t.currentVertex.y,0,0),s.vertexWrite(r(h*t.currentVertex.x,h*t.currentVertex.y)),s.vertexWrite(e.id),s.vertexWrite(e._fillColor),s.vertexWrite(a),s.vertexWrite(l),s.vertexWrite(e._tl),s.vertexWrite(e._br),s.vertexWrite(x),s.vertexWrite(r(o,0)),s.vertexEnd()}t.exit2=e.offset+e.vertexCount++;{const l=r(t.distance,n),a=i(Math.round(u*-t.nextNormal.x),Math.round(u*-t.nextNormal.y),Math.round(0*u),Math.round(1*u)),x=i(0,0,0,e._bitset);s.vertexBounds(t.currentVertex.x,t.currentVertex.y,0,0),s.vertexWrite(r(h*t.currentVertex.x,h*t.currentVertex.y)),s.vertexWrite(e.id),s.vertexWrite(e._fillColor),s.vertexWrite(a),s.vertexWrite(l),s.vertexWrite(e._tl),s.vertexWrite(e._br),s.vertexWrite(x),s.vertexWrite(r(o,0)),s.vertexEnd()}},p=e=>t=>{const r=e.out;r.indexWrite(t.leftExit0),r.indexWrite(t.rightEntry0),r.indexWrite(t.leftExit2),r.indexWrite(t.rightEntry0),r.indexWrite(t.rightEntry2),r.indexWrite(t.leftExit2),e.indexCount+=6},f=e=>(t,s,n,o,l,a,x,v,c)=>{const W=r(c,Math.ceil(d*e._halfWidth)),_=i(Math.round(u*l),Math.round(u*a),Math.round(u*x),Math.round(u*v)),p=i(u*n,u*o,0,e._bitset),f=e.out;return f.vertexBounds(t,s,1,1),f.vertexWrite(r(h*t,h*s)),f.vertexWrite(e.id),f.vertexWrite(e._fillColor),f.vertexWrite(_),f.vertexWrite(W),f.vertexWrite(e._tl),f.vertexWrite(e._br),f.vertexWrite(p),f.vertexWrite(r(Math.ceil(d*e._halfReferenceWidth),0)),f.vertexEnd(),e.offset+e.vertexCount++},m=e=>(t,r,i)=>{const s=e.out;s.indexWrite(t),s.indexWrite(r),s.indexWrite(i),e.indexCount+=3};export default W;
