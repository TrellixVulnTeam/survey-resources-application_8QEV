/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import"../../../../core/has.js";import{isSome as e,unwrapOr as t,isNone as r}from"../../../../core/maybe.js";import s from"../../../../core/CircularArray.js";import{t as i}from"../../../../chunks/vec2.js";import{i as a,t as n,m as h}from"../../../../chunks/mat2d.js";import{c as o}from"../../../../chunks/mat2df32.js";import{c}from"../../../../chunks/vec2f32.js";import{WGLGeometryType as d}from"./enums.js";import{forEachGeometryType as m}from"./Utils.js";import{WGLTile as _}from"./WGLTile.js";import{MetricReader as p}from"./collisions/MetricReader.js";import{Geometry as l}from"./cpuMapped/Geometry.js";const u=50,f=4,S=8;let w=0;class g extends _{constructor(e,t,r){super(e,t),this.instanceId=w++,this.patchCount=0,this._renderState={current:{geometry:new Map,metrics:null},next:null,swap:!1,swapFrames:0,locked:!1},this._patches=new s(100),this._lastCommitTime=0,this._lastMessageWasClear=!1,this.transforms.labelMat2d=o(),this._store=r}destroy(){super.destroy(),this._renderState.current.geometry.forEach((e=>e.destroy()))}get labelMetrics(){return this._renderState.current.metrics}get hasData(){return!!this._renderState.current.geometry.size}getGeometry(e){return this._renderState.current.geometry.get(e)}setTransform(e,t){super.setTransform(e,t);const r=this.transforms.labelMat2d,s=e.getScreenTransform(r,t),o=c();i(o,this.coords,s),a(r),n(r,r,o),h(r,e.viewMat2d,r)}patch(e){this.patchCount++,e.clear&&this._lastMessageWasClear||(this._lastMessageWasClear=e.clear,e.clear&&this._patches.size>=u&&this._dropPatches(),this._patches.enqueue(e),this.requestRender())}commit(e){if(this._lastCommitTime!==e.time){this._lastCommitTime=e.time;for(let e=0;e<f;e++)this._updateMesh();this._renderState.swap&&(this._swapRenderStates(),this.requestRender())}}lock(){this._renderState.locked=!0}unlock(){this._renderState.locked=!1,this._flushUpdates(),this._swap()}_swapRenderStates(){if(this._renderState.next){if(this._renderState.locked)return this._renderState.swap=!0,void this.requestRender();if(this._renderState.swap=!0,0===this._renderState.swapFrames)return this._renderState.swapFrames=S,void this.requestRender();1==this._renderState.swapFrames--?this._swap():this.requestRender()}}_swap(){this._renderState.swap&&(this._renderState.swap=!1,e(this._renderState.next)&&(this._renderState.current.geometry.forEach((e=>e.destroy())),this._renderState.current=this._renderState.next,this._renderState.next=null))}_flushUpdates(){let e=this._patches.maxSize;for(;this._patches.size&&e--;)this._updateMesh(),this._swap()}_updateMesh(){const t=this._patches.peek();if(e(t)&&t.clear&&null!==this._renderState.next)return;const r=this._patches.dequeue();if(e(r)){if(!0===r.clear){if(!this.isReady)return;return this._renderState.next,void(this._renderState.next={geometry:new Map,metrics:null})}this.requestRender(),this._patch(r),r.end&&(this.ready(),this._swapRenderStates())}}_patch(e){m((t=>{this._remove(t,e.remove),this._insert(e.type,t,e.addOrUpdate,e.clear)}))}_insert(e,s,i,a){try{const n=t(this._renderState.next,this._renderState.current),h=null==i?void 0:i.data[s],o=n.geometry;if(r(h))return;o.has(s)||o.set(s,new l(s,this.stage)),o.get(s).insert(e,h),s===d.LABEL&&this._insertLabelMetrics(e,h.metrics,a)}catch(n){}}_insertLabelMetrics(e,s,i){const a=t(this._renderState.next,this._renderState.current);if(r(s))return;const n=p.from(s);if(r(a.metrics))a.metrics=n;else{if("update"===e){const e=n.getCursor();for(;e.next();)a.metrics.delete(e.id)}a.metrics.link(n)}}_remove(e,r){const s=t(this._renderState.next,this._renderState.current).geometry.get(e);r&&r.length&&s&&(s.remove(r),this._removeLabelMetrics(r))}_removeLabelMetrics(e){const{metrics:s}=t(this._renderState.next,this._renderState.current);if(!r(s)&&e.length)for(const t of e)for(;s.delete(t););}_dropPatches(){const e=new Array;let t=!1;for(;this._patches.size;){const s=this._patches.dequeue();if(r(s))break;if(s.clear){if(t)break;t=!0}e.push(s)}this._patches.clear(),e.forEach((e=>this._patches.enqueue(e)))}}export{g as FeatureTile};
