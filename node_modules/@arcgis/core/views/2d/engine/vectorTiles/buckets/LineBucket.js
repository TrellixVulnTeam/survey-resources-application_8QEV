/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{getLimitCosine as e}from"../../webgl/mesh/templates/util.js";import{splitVertex as t,cleanup as r,tessellate as n}from"../../webgl/TurboLine.js";import i from"./BaseBucket.js";const l=65535,s=1/3.8,x=.97,d=.8;class a extends i{constructor(e,t,r,n){super(e,t),this.type=2,this._tessellationOptions={},this.tessellationProperties={_lineVertexBuffer:null,_lineIndexBuffer:null,_hasPattern:null,_ddValues:null,_capType:null,_joinType:null,_miterLimitCosine:null,_roundLimitCosine:null},this.tessellationProperties._lineVertexBuffer=r,this.tessellationProperties._lineIndexBuffer=n,this.tessellationProperties._hasPattern=e.getPaintValue("line-pattern",this.zoom)||e.getPaintValue("line-dasharray",this.zoom).length>0,this._isThinLine=e.isThinLine,this._isThinLine?this._tessellationCallbacks={vertex:u(this.tessellationProperties),bridge:f(this.tessellationProperties)}:this._tessellationCallbacks={vertex:o(this.tessellationProperties),bridge:V(this.tessellationProperties)}}get lineIndexStart(){return this._lineIndexStart}get lineIndexCount(){return this._lineIndexCount}processFeatures(t){this._lineIndexStart=3*this.tessellationProperties._lineIndexBuffer.index,this._lineIndexCount=0;const n=this.layer,i=this.zoom;t&&t.setExtent(this.layerExtent);for(const r of this._features){const l=n.hasDataDrivenLine?n.lineMaterial.encodeAttributes(r,i,n):null;this.tessellationProperties._capType=n.getLayoutValue("line-cap",i,r),this.tessellationProperties._joinType=n.getLayoutValue("line-join",i,r),this.tessellationProperties._miterLimitCosine=e(n.getLayoutValue("line-miter-limit",i,r)),this.tessellationProperties._roundLimitCosine=e(n.getLayoutValue("line-round-limit",i,r));const s=r.getGeometry(t);this._processFeature(s,l)}r()}serialize(){let e=6;e+=this.layerUIDs.length,e+=this.tessellationProperties._lineVertexBuffer.array.length,e+=this.tessellationProperties._lineIndexBuffer.array.length;const t=new Uint32Array(e),r=new Int32Array(t.buffer);let n=0;t[n++]=this.type,t[n++]=this.layerUIDs.length;for(let i=0;i<this.layerUIDs.length;i++)t[n++]=this.layerUIDs[i];t[n++]=this._lineIndexStart,t[n++]=this._lineIndexCount,t[n++]=this.tessellationProperties._lineVertexBuffer.array.length;for(let i=0;i<this.tessellationProperties._lineVertexBuffer.array.length;i++)r[n++]=this.tessellationProperties._lineVertexBuffer.array[i];t[n++]=this.tessellationProperties._lineIndexBuffer.array.length;for(let i=0;i<this.tessellationProperties._lineIndexBuffer.array.length;i++)t[n++]=this.tessellationProperties._lineIndexBuffer.array[i];return t.buffer}_processFeature(e,t){if(!e)return;const r=e.length;for(let n=0;n<r;n++)this._processGeometry(e[n],t)}_processGeometry(e,t){if(e.length<2)return;const r=.001;let i,x,d=e[0],a=1;for(;a<e.length;)i=e[a].x-d.x,x=e[a].y-d.y,i*i+x*x<r*r?e.splice(a,1):(d=e[a],++a);if(e.length<2)return;const u=3*this.tessellationProperties._lineIndexBuffer.index;this._tessellationOptions.trackDistance=this.tessellationProperties._hasPattern,this._tessellationOptions.initialDistance=0,this._tessellationOptions.thin=this._isThinLine,this._tessellationOptions.wrapDistance=l,this._tessellationOptions.outerBisectorAutoSplitThreshold=s,this._tessellationOptions.enableOuterBisectorSplit=this.tessellationProperties._hasPattern,this._tessellationOptions.innerBisectorAutoSplitThreshold=s,this._tessellationOptions.enableInnerBisectorSplit=this.tessellationProperties._hasPattern,this.tessellationProperties._ddValues=t,n(e,this._tessellationOptions,this._tessellationCallbacks),this._lineIndexCount+=3*this.tessellationProperties._lineIndexBuffer.index-u}}const u=e=>t=>{t.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(t.currentVertex.x,t.currentVertex.y,t.prevNormal.x,t.prevNormal.y,0,-1,t.distance,e._ddValues),t.entry2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(t.currentVertex.x,t.currentVertex.y,-t.prevNormal.x,-t.prevNormal.y,0,1,t.distance,e._ddValues),t.exit0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(t.currentVertex.x,t.currentVertex.y,t.nextNormal.x,t.nextNormal.y,0,-1,t.distance,e._ddValues),t.exit2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(t.currentVertex.x,t.currentVertex.y,-t.nextNormal.x,-t.nextNormal.y,0,1,t.distance,e._ddValues)},f=e=>t=>{e._lineIndexBuffer.add(t.leftExit0,t.rightEntry0,t.leftExit2),e._lineIndexBuffer.add(t.rightEntry0,t.rightEntry2,t.leftExit2)},o=e=>r=>{const n=2===e._joinType?e._miterLimitCosine:e._roundLimitCosine,i=r.isCap&&0!==e._capType;let l=!1;r.cosine>x?(r.exit0=r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.bisector.x/r.cosine,r.bisector.y/r.cosine,0,-1,r.distance,e._ddValues),r.exit2=r.entry2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.bisector.x/r.cosine,-r.bisector.y/r.cosine,0,1,r.distance,e._ddValues)):r.cosine<1-x?(r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.prevNormal.x,r.prevNormal.y,0,-1,r.distance,e._ddValues),r.entry2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.prevNormal.x,-r.prevNormal.y,0,1,r.distance,e._ddValues),r.exit0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.nextNormal.x,r.nextNormal.y,0,-1,r.distance,e._ddValues),r.exit2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.nextNormal.x,-r.nextNormal.y,0,1,r.distance,e._ddValues)):r.canSplit?(t(),r.sign>0?(r.splitInner?(r.exit0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.leftInner.x,r.leftInner.y,0,-1,r.distance,e._ddValues),r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.rightInner.x,r.rightInner.y,0,-1,r.distance,e._ddValues)):(r.exit0=r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.bisector.x/r.cosine,r.bisector.y/r.cosine,0,-1,r.distance,e._ddValues)),r.cosine<n?(l=!r.isCap,r.entry2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.prevNormal.x,-r.prevNormal.y,0,1,r.distance,e._ddValues),r.exit2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.nextNormal.x,-r.nextNormal.y,0,1,r.distance,e._ddValues)):r.splitOuter?(l=l||r.gapOuter,r.entry2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.leftOuter.x,-r.leftOuter.y,0,1,r.distance,e._ddValues),r.exit2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.rightOuter.x,-r.rightOuter.y,0,1,r.distance,e._ddValues)):(r.entry2=r.exit2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.bisector.x/r.cosine,-r.bisector.y/r.cosine,0,1,r.distance,e._ddValues))):(r.splitInner?(r.exit2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.leftInner.x,-r.leftInner.y,0,1,r.distance,e._ddValues),r.entry2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.rightInner.x,-r.rightInner.y,0,1,r.distance,e._ddValues)):(r.exit2=r.entry2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.bisector.x/r.cosine,-r.bisector.y/r.cosine,0,1,r.distance,e._ddValues)),r.cosine<n?(l=!r.isCap,r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.prevNormal.x,r.prevNormal.y,0,-1,r.distance,e._ddValues),r.exit0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.nextNormal.x,r.nextNormal.y,0,-1,r.distance,e._ddValues)):r.splitOuter?(l=l||r.gapOuter,r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.leftOuter.x,r.leftOuter.y,0,-1,r.distance,e._ddValues),r.exit0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.rightOuter.x,r.rightOuter.y,0,-1,r.distance,e._ddValues)):(r.exit0=r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.bisector.x/r.cosine,r.bisector.y/r.cosine,0,-1,r.distance,e._ddValues)))):r.sign>0?(r.exit0=r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.bisector.x/r.cosine,r.bisector.y/r.cosine,0,-1,r.distance,e._ddValues),r.cosine<n?(l=!r.isCap,r.entry2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.prevNormal.x,-r.prevNormal.y,0,1,r.distance,e._ddValues),r.exit2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.nextNormal.x,-r.nextNormal.y,0,1,r.distance,e._ddValues)):(r.entry2=r.exit2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.bisector.x/r.cosine,-r.bisector.y/r.cosine,0,1,r.distance,e._ddValues))):(r.exit2=r.entry2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.bisector.x/r.cosine,-r.bisector.y/r.cosine,0,1,r.distance,e._ddValues),r.cosine<n?(l=!r.isCap,r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.prevNormal.x,r.prevNormal.y,0,-1,r.distance,e._ddValues),r.exit0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.nextNormal.x,r.nextNormal.y,0,-1,r.distance,e._ddValues)):(r.exit0=r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.bisector.x/r.cosine,r.bisector.y/r.cosine,0,-1,r.distance,e._ddValues)));let s;if(r.canSplit&&(r.splitInner||r.splitOuter)||l||i?(s=r.entry1=r.exit1=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,0,0,0,0,r.distance,e._ddValues)):s=r.entry1=r.exit1=null,l&&1!==e._joinType)e._lineIndexBuffer.add(s,r.sign>0?r.exit2:r.entry0,r.sign>0?r.entry2:r.exit0);else if(i&&1===e._capType||l&&1===e._joinType){let t,n,i,l,x,a;if(r.isCap){const e=Math.PI;x=Math.ceil(e/d),a=e/x,r.isFirstVertex?(t=r.prevNormal.x,n=r.prevNormal.y,i=r.entry0,l=r.entry2):r.isLastVertex&&(t=-r.nextNormal.x,n=-r.nextNormal.y,i=r.exit2,l=r.exit0)}else{const e=2*Math.acos(r.cosine);x=Math.ceil(e/d),a=e/x,t=r.sign>0?-r.prevNormal.x:r.nextNormal.x,n=r.sign>0?-r.prevNormal.y:r.nextNormal.y,i=r.sign>0?r.entry2:r.exit0,l=r.sign>0?r.exit2:r.entry0}const u=Math.cos(a),f=Math.sin(a),o=f*t+u*n;let V,c;t=u*t-f*n,n=o;for(let d=0;d<x;++d){if(V=c,d<x-1)if(r.isCap){const i=r.isFirstVertex?-1:1;c=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,t,n,i,0,r.distance,e._ddValues)}else c=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,t,n,0,r.sign,r.distance,e._ddValues);e._lineIndexBuffer.add(0===d?i:V,s,d===x-1?l:c);const a=f*t+u*n;t=u*t-f*n,n=a}}else if(i&&2===e._capType){const t=r.isFirstVertex?1:-1;let n,i;e._hasPattern?(n=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.prevNormal.x-t*r.inbound.x,r.prevNormal.y-t*r.inbound.y,-t,-1,r.distance,e._ddValues),i=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.prevNormal.x-t*r.inbound.x,-r.prevNormal.y-t*r.inbound.y,-t,1,r.distance,e._ddValues)):(n=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.prevNormal.x-t*r.inbound.x,r.prevNormal.y-t*r.inbound.y,0,-1,r.distance,e._ddValues),i=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.prevNormal.x-t*r.inbound.x,-r.prevNormal.y-t*r.inbound.y,0,1,r.distance,e._ddValues)),t>0?(e._lineIndexBuffer.add(s,r.entry2,i),e._lineIndexBuffer.add(s,i,n),e._lineIndexBuffer.add(s,n,r.entry0)):(e._lineIndexBuffer.add(s,i,r.exit2),e._lineIndexBuffer.add(s,n,i),e._lineIndexBuffer.add(s,r.exit0,n))}},V=e=>t=>{e._lineIndexBuffer.add(t.leftExit0,t.rightEntry0,null!=t.leftExit1?t.leftExit1:t.leftExit2),e._lineIndexBuffer.add(t.rightEntry0,null!=t.rightEntry1?t.rightEntry1:t.rightEntry2,null!=t.leftExit1?t.leftExit1:t.leftExit2),null!=t.leftExit1&&null!=t.rightEntry1?(e._lineIndexBuffer.add(t.leftExit1,t.rightEntry1,t.leftExit2),e._lineIndexBuffer.add(t.rightEntry1,t.rightEntry2,t.leftExit2)):null!=t.leftExit1?e._lineIndexBuffer.add(t.leftExit1,t.rightEntry2,t.leftExit2):null!=t.rightEntry1&&e._lineIndexBuffer.add(t.rightEntry1,t.rightEntry2,t.leftExit2)};export default a;
