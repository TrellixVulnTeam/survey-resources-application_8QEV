/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import e from"../../../../core/has.js";import{isAbortError as t,eachAlways as s}from"../../../../core/promiseUtils.js";import r from"../../../../request.js";import i from"../../../../core/ItemCache.js";import{open as o}from"../../../../core/workers/workers.js";import a from"../../tiling/TileKey.js";import l from"./TileIndex.js";import n from"./GlyphMosaic.js";import c from"./GlyphSource.js";import h from"./SpriteMosaic.js";import{perfAdd as u}from"./decluttering/debugging.js";const p=new i(10),y=new Map;class f{constructor(e,t,s){this._vectorTileLayer=e,this._styleRepository=t,this.devicePixelRatio=s,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null}destroy(){this._connection&&(this._connection.close(),this._connection=null),this._styleRepository=null,this._vectorTileLayer=null,this._spriteMosaic&&(this._spriteMosaic=null),this._glyphMosaic&&(this._glyphMosaic=null)}get spriteMosaic(){return this._spriteSourcePromise.then((()=>this._spriteMosaic))}get glyphMosaic(){return this._glyphMosaic}async start(t){const s=this._vectorTileLayer,r=s.sourceNameToSource,i=[];for(const e in r)i.push(this._fetchTileMap(r[e],t));this._spriteSourcePromise=this._vectorTileLayer.loadSpriteSource(this.devicePixelRatio,t),this._spriteSourcePromise.then((e=>{this._spriteMosaic=new h(1024,1024,250),this._spriteMosaic.setSpriteSource(e)}));const a=this._styleRepository,l=new c(a.glyphs);return this._glyphMosaic=new n(1024,1024,l),this._broadcastPromise=o("WorkerTileHandler",{client:this,scheduler:t.scheduler,signal:t.signal}).then((r=>(this._connection=r,Promise.all(this._connection.broadcast("setStyle",{style:s.currentStyleInfo.style,vectorTileLayerMaxBuffers:e("vectortilelayer-max-buffers")},t))))),Promise.all(i)}async updateStyle(e){return await this._broadcastPromise,this._broadcastPromise=new Promise(((t,s)=>{Promise.all(this._connection.broadcast("updateStyle",e)).then(t,s)})),this._broadcastPromise}async setStyle(t,s){await this._broadcastPromise,this._styleRepository=t;const r=this._vectorTileLayer.sourceNameToSource,i=[];for(const e in r)i.push(this._fetchTileMap(r[e],null));this._spriteSourcePromise=this._vectorTileLayer.loadSpriteSource(this.devicePixelRatio,null),this._spriteSourcePromise.then((e=>{this._spriteMosaic=new h(1024,1024,250),this._spriteMosaic.setSpriteSource(e)}));const o=new c(t.glyphs);return this._glyphMosaic=new n(1024,1024,o),this._broadcastPromise=new Promise(((t,r)=>{Promise.all(this._connection.broadcast("setStyle",{style:s,vectorTileLayerMaxBuffers:e("vectortilelayer-max-buffers")})).then(t,r)})),i.push(this._broadcastPromise),Promise.all(i)}fetchTileData(e,t){return this._getRefKeys(e,t).then((e=>{const s=this._vectorTileLayer.sourceNameToSource,r=[];for(const t in s)r.push(t);return this._getSourcesData(r,e,t)}))}parseTileData(e,t){const s=e&&e.data;if(!s)return Promise.resolve(null);const{sourceName2DataAndRefKey:r,transferList:i}=s;return 0===Object.keys(r).length?Promise.resolve(null):this._broadcastPromise.then((()=>this._connection.getAvailableClient().then((s=>s.invoke("createTileAndParse",{key:e.key.id,sourceName2DataAndRefKey:r,styleLayerUIDs:e.styleLayerUIDs},{...t,transferList:i}).then((e=>({tileData:e})))))))}async getSprites(e){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(e)}getGlyphs(e){return this._glyphMosaic.getGlyphItems(e.font,e.codePoints)}perfReport({key:e,milliseconds:t}){u(e,t,"ms")}async _getTilePayload(e,s,r){const i=a.pool.acquire(e.id),o=this._vectorTileLayer.sourceNameToSource[s].getSourceTileUrl(i.level,i.row,i.col);a.pool.release(i);try{return{protobuff:await this.request(o,r),sourceName:s}}catch(l){if(t(l))throw l;return{protobuff:null,sourceName:s}}}request(e,t){return r(e,{responseType:"array-buffer",...t}).then((({data:e})=>e))}async _fetchTileMap(e,s){if(e.capabilities.operations.supportsTileMap&&e.tileIndex)return Promise.resolve();if(!e.tileMapURL)return;const i=p.get(e.tileMapURL);if(i)return void(e.tileIndex=i);let o;if(y.has(e.tileMapURL)){try{o=await y.get(e.tileMapURL),e.tileIndex=new l(o.data)}catch(n){if(t(n))throw n}return}const a=r(e.tileMapURL,s);y.set(e.tileMapURL,a);try{o=await a,y.delete(e.tileMapURL),p.put(e.tileMapURL,e.tileIndex),e.tileIndex=new l(o.data)}catch(n){if(y.delete(e.tileMapURL),t(n))throw n}}_getRefKeys(e,t){const r=this._vectorTileLayer.sourceNameToSource,i=new Array;for(const s in r){const o=r[s].getRefKey(e,t);i.push(o)}return s(i)}_getSourcesData(e,t,r){const i=[];for(let s=0;s<t.length;s++)if(null==t[s].value||null==e[s])i.push(null);else{const o=this._getTilePayload(t[s].value,e[s],r);i.push(o)}return s(i).then((e=>{const s={},r=[];for(let i=0;i<e.length;i++)if(e[i].value&&e[i].value&&e[i].value.protobuff&&e[i].value.protobuff.byteLength>0){const o=t[i].value.id;s[e[i].value.sourceName]={refKey:o,protobuff:e[i].value.protobuff},r.push(e[i].value.protobuff)}return{sourceName2DataAndRefKey:s,transferList:r}}))}}export{f as TileHandler};
