/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{isAborted as e}from"../../../../core/promiseUtils.js";import t from"../../../../core/pbf.js";import{TileClipper as r,SimpleBuilder as s}from"../webgl/TileClipper.js";import{TileStatus as i}from"../../tiling/enums.js";import o from"./Feature.js";import{TriangleIndexBuffer as c}from"./IndexMemoryBuffer.js";import n from"./SourceLayerData.js";import{FillVertexBuffer as a,OutlineVertexBuffer as l,LineVertexBuffer as u,CircleVertexBuffer as f,SymbolVertexBuffer as p}from"./VertexMemoryBuffer.js";import h from"./buckets/CircleBucket.js";import m from"./buckets/FillBucket.js";import _ from"./buckets/LineBucket.js";import y from"./buckets/SymbolBucket.js";const k=1;class d{constructor(e,i,o,c,n){if(this._pbfTiles={},this._tileClippers={},this._client=o,this._tile=i,n){this._styleLayerUIDs=new Set;for(const e of n)this._styleLayerUIDs.add(e)}this._styleRepository=c,this._layers=this._styleRepository.layers;const[a,l,u]=i.tileKey.split("/").map(parseFloat);this._level=a;const f=Math.max(8,Math.round(k*this._level)-8);for(const p of Object.keys(e)){const i=e[p];this._pbfTiles[p]=new t(new Uint8Array(i.protobuff),new DataView(i.protobuff));if(i.refKey){const[e]=i.refKey.split("/").map(parseFloat),t=a-e;if(t>0){const e=(1<<t)-1,s=l&e,i=u&e;this._tileClippers[p]=new r(t,s,i,8,f)}}this._tileClippers[p]||(this._tileClippers[p]=new s)}}_canParseStyleLayer(e){return!this._styleLayerUIDs||this._styleLayerUIDs.has(e)}async parse(e){const t=this._initialize(e),{returnedBuckets:r}=t;this._processLayers(t),this._linkReferences(t),this._filterFeatures(t);const s=new Set,o={};for(const i of r)3===i.type&&i.getResources(i.tileClipper,s,o);if(this._tile.status===i.INVALID)return Promise.resolve([]);const c=this._fetchResources(s,o,e);return Promise.all(c).then((()=>this._processFeatures(t.returnedBuckets)))}_initialize(e){return{signal:e&&e.signal,sourceNameToTileData:this._parseTileData(this._pbfTiles),layers:this._layers,zoom:this._level,sourceNameToTileClipper:this._tileClippers,sourceNameToUniqueSourceLayerBuckets:{},sourceNameToUniqueSourceLayers:{},returnedBuckets:[],layerIdToBucket:{},referencerUIDToReferencedId:new Map}}_processLayers(e){const{sourceNameToTileData:t,layers:r,zoom:s,sourceNameToTileClipper:i,sourceNameToUniqueSourceLayerBuckets:o,sourceNameToUniqueSourceLayers:c,returnedBuckets:n,layerIdToBucket:a,referencerUIDToReferencedId:l}=e;for(let u=r.length-1;u>=0;u--){const e=r[u];if(!this._canParseStyleLayer(e.uid)||e.minzoom&&s<Math.floor(e.minzoom)||e.maxzoom&&s>=e.maxzoom||0===e.type)continue;if(!t[e.source]||!i[e.source])continue;const f=t[e.source],p=i[e.source],h=e.sourceLayer,m=f[h];if(m){let t=c[e.source];if(t||(t=c[e.source]=new Set),t.add(e.sourceLayer),e.refLayerId)l.set(e.uid,e.refLayerId);else{const t=this._createBucket(e);if(t){t.layerUIDs=[e.uid],t.layerExtent=m.extent,t.tileClipper=p;let r=o[e.source];r||(r=o[e.source]={});let s=r[h];s||(s=r[h]=[]),s.push(t),n.push(t),a[e.id.toLowerCase()]=t}}}}}_linkReferences(e){const{layerIdToBucket:t,referencerUIDToReferencedId:r}=e;r.forEach(((e,r)=>{e=e.toLowerCase(),t[e]&&t[e].layerUIDs.push(r)}))}_filterFeatures(t){const{signal:r,sourceNameToTileData:s,sourceNameToUniqueSourceLayerBuckets:i,sourceNameToUniqueSourceLayers:c}=t,n=10*this._level,a=10*(this._level+1),l=[],u=[];for(const e of Object.keys(c)){c[e].forEach((t=>{l.push(t),u.push(e)}))}for(let f=0;f<l.length;f++){const t=u[f],c=l[f];if(!s[t]||!i[t])continue;const p=s[t][c],h=i[t][c];if(!h||0===h.length)continue;if(e(r))return;const m=p.getData();for(;m.nextTag(2);){const e=m.getMessage(),t=new o(e,p);e.release();const r=t.values;if(r){const e=r._minzoom;if(e&&e>=a)continue;const t=r._maxzoom;if(t&&t<=n)continue}for(const s of h)s.pushFeature(t)}}}_fetchResources(e,t,r){const s=[],i=this._tile.getWorkerTileHandler();let o,c;e.size>0&&(o=i.fetchSprites(e,this._client,r),s.push(o));for(const n in t){const e=t[n];e.size>0&&(c=i.fetchGlyphs(this._tile.tileKey,n,e,this._client,r),s.push(c))}return s}_processFeatures(e){const t=e.filter((e=>e.hasFeatures()||this._canParseStyleLayer(e.layer.uid)));for(const r of t)r.processFeatures(r.tileClipper);return t}_parseTileData(e){const t={};for(const r of Object.keys(e)){const s=e[r],i={};for(;s.next();)switch(s.tag()){case 3:{const e=s.getMessage(),t=new n(e);e.release(),i[t.name]=t;break}default:s.skip()}t[r]=i}return t}_createBucket(e){switch(e.type){case 0:return null;case 1:return this._createFillBucket(e);case 2:return this._createLineBucket(e);case 4:return this._createCircleBucket(e);case 3:return this._createSymbolBucket(e)}}_createFillBucket(e){return new m(e,this._level,new a(e.fillMaterial.getStride()),new c,new l(e.outlineMaterial.getStride()),new c)}_createLineBucket(e){return new _(e,this._level,new u(e.lineMaterial.getStride()),new c)}_createCircleBucket(e){return new h(e,this._level,new f(e.circleMaterial.getStride()),new c)}_createSymbolBucket(e){const t=this._tile;return new y(e,this._level,new p(e.iconMaterial.getStride()),new c,new p(e.textMaterial.getStride()),new c,t.placementEngine,t.getWorkerTileHandler())}}export default d;
