/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{isNone as e,isSome as t}from"../../../../../core/maybe.js";import r from"../../../../../core/Logger.js";import s from"../../../../../core/Error.js";import i from"../../../../../layers/graphics/OptimizedFeature.js";import a from"../../../../../layers/graphics/OptimizedGeometry.js";import{convertToGeometry as n,unquantizeOptimizedGeometry as h}from"../../../../../layers/graphics/featureConversionUtils.js";import{FeatureSetReader as o}from"./FeatureSetReader.js";import d from"../../../../../core/pbf.js";import{parseHeader as u}from"./FeatureSetReaderPBFHeader.js";const c=r.getLogger("esri.view.2d.layers.features.support.FeatureSetReaderPBF"),_=268435455;function g(e){return e.toLowerCase().trim()}function l(e){try{const t=2,r=new d(new Uint8Array(e),new DataView(e));for(;r.next();)switch(r.tag()){case t:return f(r.getMessage());default:r.skip()}}catch(t){const e=new s("query:parsing-pbf","Error while parsing FeatureSet PBF payload",{error:t});c.error(e)}return null}function f(e){const t=1;for(;e.next();)switch(e.tag()){case t:return e.getMessage();default:e.skip()}return null}function y(e){const t=1,r=2,s=3,i=4,a=5,n=6,h=7,o=8,d=9,u=e.getLength(),c=e.pos()+u;for(;e.pos()<c&&e.next();)switch(e.tag()){case t:{const t=e.getString();return""===t?null:t}case r:return e.getFloat();case s:return e.getDouble();case i:return e.getSInt32();case a:return e.getUInt32();case n:return e.getInt64();case h:return e.getUInt64();case o:return e.getSInt64();case d:return e.getBool();default:return e.skip(),null}return null}class m extends o{constructor(e,t,r,s){super(e),this._hasNext=!1,this._isPoints=!1,this._isPolygons=!1,this._featureIndex=-1,this._featureOffset=0,this._cache={area:0,unquantGeometry:void 0,geometry:void 0,centroid:void 0,legacyFeature:void 0,optFeature:void 0},this._geometryType=s,this._reader=t,this._header=r,this._hasNext=r.hasFeatures,this._isPoints="esriGeometryPoint"===s,this._isPolygons="esriGeometryPolygon"===s}static fromBuffer(e,t,r=!1){const s=l(e),i=u(s,"esriGeometryPoint"===t,r),a=o.createInstance();return new m(a,s,i,t)}get geometryType(){return this._geometryType}get size(){return this._header.featureCount}get hasZ(){return!1}get hasM(){return!1}get stride(){return 2+(this.hasZ?1:0)+(this.hasM?1:0)}get hasFeatures(){return this._header.hasFeatures}get hasNext(){return this._hasNext}get exceededTransferLimit(){return this._header.exceededTransferLimit}getApproximateSize(){if(this._hasFilter){const e=Math.abs(this._xmax-this._xmin)*Math.abs(this._ymax-this._ymin),t=this.size*e/262144;return Math.max(Math.round(t),0)}return this.size}getQuantizationTransform(){return this._header.transform}getCursor(){return this.copy()}getIndex(){return this._featureIndex}setIndex(e){this._cache.area=0,this._cache.unquantGeometry=void 0,this._cache.geometry=void 0,this._cache.centroid=void 0,this._cache.legacyFeature=void 0,this._cache.optFeature=void 0,this._featureIndex=e}getAttributeHash(){let e="";return this._header.fields.forEach((({index:t})=>{e+=this._readAttributeAtIndex(t)+"."})),e}getObjectId(){return this._readAttributeAtIndex(this._header.objectIdFieldIndex)}getDisplayId(){return this._header.displayIds[this._featureIndex]}setDisplayId(e){this._header.displayIds[this._featureIndex]=e}getGroupId(){return this._header.groupIds[this._featureIndex]}setGroupId(e){this._header.groupIds[this._featureIndex]=e}readLegacyFeature(){if(void 0===this._cache.legacyFeature){var e;const t=this.readCentroid(),r={attributes:this.readAttributes(),geometry:this._isPoints?this.readLegacyPointGeometry():this.readLegacyGeometry(),centroid:null!=(e=t&&{x:t.coords[0],y:t.coords[1]})?e:null};return this._cache.legacyFeature=r,r}return this._cache.legacyFeature}readOptimizedFeature(){if(void 0===this._cache.optFeature){const e=new i(this.readGeometry(),this.readAttributes(),this.readCentroid());return e.objectId=this.getObjectId(),e.displayId=this.getDisplayId(),this._cache.optFeature=e,e}return this._cache.optFeature}getXHydrate(){const t=this._header.centroid[2*this._featureIndex],r=this.getQuantizationTransform();return e(r)?t:t*r.scale[0]+r.translate[0]}getYHydrate(){const t=this._header.centroid[2*this._featureIndex+1],r=this.getQuantizationTransform();return e(r)?t:r.translate[1]-t*r.scale[1]}getX(){return this._header.centroid[2*this._featureIndex]*this._sx+this._tx}getY(){return this._header.centroid[2*this._featureIndex+1]*this._sy+this._ty}readLegacyPointGeometry(){return{x:this.getX(),y:this.getY()}}readLegacyGeometry(){const e=this.readGeometry();return n(e,this.geometryType,!1,!1)}readLegacyCentroid(){const e=this.readCentroid();if(!e)return null;const[t,r]=e.coords;return{x:t,y:r}}readGeometryArea(){return this._cache.area||this.readGeometry(),this._cache.area}readUnquantizedGeometry(){if(void 0===this._cache.unquantGeometry){const e=this.readGeometry();if(!e)return this._cache.unquantGeometry=null,null;const t=e.clone(),r=t.lengths,s=t.coords;for(let i=0,a=2;i<r.length;i++,a+=2){const e=r[i];for(let t=1;t<e;t+=1,a+=2)s[a]+=s[a-2],s[a+1]+=s[a-1]}return this._cache.unquantGeometry=t,t}return this._cache.unquantGeometry}readHydratedGeometry(){if(this._isPoints){const e=this.getXHydrate(),t=this.getYHydrate();return new a([],[e,t])}const e=this.readGeometry();if(!e)return null;const r=e.clone(),s=this.getQuantizationTransform();return t(s)&&h(r,r,this.hasZ,this.hasM,s),r}readGeometry(){if(void 0===this._cache.geometry){let t=null;if(this._isPoints){const e=this.getX(),r=this.getY();t=new a([],[e,r])}else{const r=this._header.offsets.geometry[this._featureIndex],s=this._reader;if(0===r)return null;s.move(r);try{t=this._parseGeometry(s)}catch(e){return console.error("Failed to parse geometry!",e),null}}return this._cache.geometry=t,t}return this._cache.geometry}readCentroid(){if(void 0===this._cache.centroid){let e=null;const t=this._header.centroid[2*this._featureIndex]+this._tx,r=this._header.centroid[2*this._featureIndex+1]+this._ty;return t===_?(e=this._computeCentroid(),e&&(this._header.centroid[2*this._featureIndex]=e.coords[0]-this._tx,this._header.centroid[2*this._featureIndex+1]=e.coords[1]-this._ty)):e=new a([],[t,r]),this._cache.centroid=e,e}return this._cache.centroid}copy(){const e=this._reader.clone(),t=new m(this.instance,e,this._header,this.geometryType);return this.copyInto(t),t}next(){for(this._cache.area=0,this._cache.unquantGeometry=void 0,this._cache.geometry=void 0,this._cache.centroid=void 0,this._cache.legacyFeature=void 0,this._cache.optFeature=void 0;++this._featureIndex<this.size&&!this._passesFilter()&&!this._getExists(););return this._featureIndex<this.size}_readAttribute(e,t){const r=this._header.hasField(e)?e:g(e),s=this._header.getFieldIndex(r);if(null==s)return;const i=this._readAttributeAtIndex(s);if(!t)return i;if(null==i)return i;return this._header.isDateField(r)?new Date(i):i}_readAttributes(){const e={};return this._header.fields.forEach((({fieldName:t,index:r})=>{e[t]=this._readAttributeAtIndex(r)})),e}copyInto(e){super.copyInto(e),e._featureIndex=this._featureIndex,e._featureOffset=this._featureOffset,e._hasNext=this._hasNext}_passesFilter(){if(!this._hasFilter)return!0;let e=this._header.centroid[2*this._featureIndex],t=this._header.centroid[2*this._featureIndex+1];if(e===_){if(this._isPolygons&&!this.readCentroid())return!1;e=this._header.centroid[2*this._featureIndex],t=this._header.centroid[2*this._featureIndex+1]}return e>=this._xmin&&e<=this._xmax&&t>=this._ymin&&t<=this._ymax}_readAttributeAtIndex(e){const t=this._header.offsets.attributes[this._featureIndex*this._header.fieldCount+e],r=this._reader;return r.move(t),y(r)}_preprocessPolygon(e,t){let r=0,s=0,i=0,n=!1,h=!1,o=!1,d=-1;const u=1e6,c=[];let _=0,g=!1;for(let a=0;a<t.length;a++){const l=t[a];let f=e[2*r],y=e[2*r+1],m=0;for(let t=1;t<l;t++){const s=f,i=y,a=f+e[2*(r+t)],n=y+e[2*(r+t)+1];f=a,y=n,m+=.5*((a-s)*(n+i))}const p=m>0;if(p&&g&&(s+=l),p||(d++,g=!1),d>=u)break;_+=m,n&&p&&h&&(o=!0);{e[2*i]=e[2*s],e[2*i+++1]=e[2*s+++1];let t=1,r=e[2*s],a=e[2*s+++1];for(let n=2;n<l;n++){const n=e[2*s],h=e[2*s+++1];0===r*h-n*a&&r*n+a*h>0?(r+=n,a+=h):(e[2*i]=r,e[2*i+++1]=a,t++,r=n,a=h)}e[2*i]=r,e[2*i+++1]=a,t++,c.push(t)}n=!1,h=!0,r+=l}return c.length?(this._cache.area=Math.abs(_),new a(c,e,o)):null}_parseGeometry(e){const t=1,r=2,s=3,i=e.getLength(),n=e.pos()+i,h=[],o=[];for(;e.pos()<n&&e.next();)switch(e.tag()){case r:{const t=e.getUInt32(),r=e.pos()+t;for(;e.pos()<r;)o.push(e.getUInt32());break}case s:{const t=e.getUInt32(),r=e.pos()+t;for(;e.pos()<r;)h.push(e.getSInt32()),h.push(e.getSInt32()),this.hasZ&&e.getSInt32(),this.hasM&&e.getSInt32();break}case t:default:e.skip()}let d=0;for(const a of o)h[2*d]+=this._tx,h[2*d+1]+=this._ty,d+=a;return this._isPolygons?this._preprocessPolygon(h,o):new a(o,h)}}export{m as FeatureSetReaderPBF};
