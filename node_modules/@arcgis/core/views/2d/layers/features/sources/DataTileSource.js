/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import e from"../../../../../core/has.js";import{isSome as s}from"../../../../../core/maybe.js";import{createResolver as t,all as i}from"../../../../../core/promiseUtils.js";import r from"../../../../../core/Evented.js";import o from"../../../../../TimeExtent.js";import{diff as n,hasDiff as a,hasDiffAny as u}from"../../../../../core/accessorSupport/diffUtils.js";import h from"../../../../../tasks/support/Query.js";import{EditsQueue as d}from"../controllers/EditsQueue.js";import{UpdateToken as c}from"../support/UpdateToken.js";import{DataTileSubscription as p}from"./DataTileSubscription.js";function l(e,s){const t=new Set;return e&&e.forEach((e=>t.add(e))),s&&s.forEach((e=>t.add(e))),t.has("*")?["*"]:Array.from(t)}class m{constructor(e){this.events=new r,this._pendingEdits=new Set,this._resolver=t(),this._editsQueue=new d({processEdits:(e,s)=>this._processEdit(e,s)}),this._subscriptions=new Map,this._outSR=e.outSR,this._serviceInfo=e.serviceInfo,this._onTileUpdateMessage=e.onMessage}destroy(){this._editsQueue.clear()}async _onMessage(e){var s;const t=this._subscriptions.get(e.id);if(!t)return;const i={...e,remove:null!=(s=e.remove)?s:[],status:e.status};return this._onTileUpdateMessage(i,t.options)}update(s,t){var i;const r=t.fields.length;t.outFields=l(null==(i=this._schema)?void 0:i.outFields,t.outFields),t.outFields=t.outFields.length>=.75*r?["*"]:t.outFields,t.outFields.sort();const h=n(this._schema,t);if(!h)return;e("esri-2d-update-debug")&&console.debug("Applying Update - Source:",h);const d={returnCentroid:e("esri-2d-query-centroid-enabled")&&"esriGeometryPolygon"===this._serviceInfo.geometryType,returnGeometry:!0,outFields:t.outFields,outSpatialReference:this._outSR,orderByFields:[`${this._serviceInfo.objectIdField} ASC`],where:t.definitionExpression||"1=1",gdbVersion:t.gdbVersion,historicMoment:t.historicMoment?new Date(t.historicMoment):null,timeExtent:o.fromJSON(t.timeExtent)},c=this._schema&&a(h,"outFields");this._schema&&u(h,["timeExtent","definitionExpression","gdbVersion","historicMoment"])&&(s.why.mesh.push("Layer filter changed"),s.why.source.push("Layer filter changed"),s.mesh=!0,s.source=!0,s.queryFilter=!0,this._invalidate("all")),c&&(s.why.source.push("Layer required fields changed"),s.source=!0,this._invalidate("fields")),n(d,this._queryInfo)&&(this._queryInfo=d),this._schema=t,this._resolver.resolve()}whenInitialized(){return this._resolver.promise}async applyUpdate(e){e.queryFilter?this.refresh():(this._subscriptions.forEach((s=>s.applyUpdate(e))),await this.resend())}refresh(){for(const e of this._tiles())this.unsubscribe(e),this.subscribe(e)}_tiles(){const e=[];return this._subscriptions.forEach((s=>e.push(s.tile))),e}pause(){this._subscriptions.forEach((e=>e.abort()))}subscribe(e){const s=new p(e);this._subscriptions.set(e.id,s)}unsubscribe(e){const t=this.get(e.id);s(t)&&t.abort(),this._subscriptions.delete(e.id)}forEachPendingEdit(e){Array.from(this._subscriptions.values()).some((e=>"none"!==e.invalid))?this._pendingEdits.forEach(e):this._pendingEdits.clear()}async edit(e){return this._editsQueue.push(e)}createQuery(e={}){return new h({...this._queryInfo,...e})}get(e){return this._subscriptions.has(e)?this._subscriptions.get(e):null}async queryLastEditDate(){throw new Error("Service does not support query type")}async query(e,s){throw new Error("Service does not support query")}_invalidate(e){this._subscriptions.forEach((s=>s.invalidate(e)))}async _processEdit(e,s){s.forEach((e=>{this._pendingEdits.has(e)&&this._pendingEdits.delete(e)})),e.forEach((e=>this._pendingEdits.add(e)));const t=Array.from(this._subscriptions.values()).map((({tile:e})=>e)).map((s=>{const t=this.createTileQuery(s);return t.objectIds=e,{tile:s,query:t}})).map((async({tile:e,query:s})=>({tile:e,result:await this.query(s)}))),r=(await i(t)).map((async({tile:t,result:i})=>{if(!i.hasFeatures&&!s.length&&!e.length)return;return this._subscriptions.get(t.key.id)?this._onMessage({type:"update",id:t.key.id,addOrUpdate:i,remove:[...e,...s],end:!0,status:c.empty()}):void 0}));await Promise.all(r),this._invalidate("all")}}export{m as DataTileSource};
