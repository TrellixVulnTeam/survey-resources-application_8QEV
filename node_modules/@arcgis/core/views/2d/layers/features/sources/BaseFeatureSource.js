/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import e from"../../../../../core/has.js";import{isSome as t,unwrapOr as r,isNone as s}from"../../../../../core/maybe.js";import i from"../../../../../core/Logger.js";import o from"../../../../../core/Error.js";import{throwIfAborted as a,isAbortError as n}from"../../../../../core/promiseUtils.js";import u from"../../../../../request.js";import c from"../../../../../tasks/support/Query.js";import{QueueProcessor as l}from"../../../../support/QueueProcessor.js";import{createSourceAdapter as p}from"../controllers/support/sourceAdapters.js";import{DataTileSource as d}from"./DataTileSource.js";const y=i.getLogger("esri.views.2d.layers.features.sources.BaseFeatureSource"),h=4;class m extends d{constructor(r){super(r),this.type="feature",this.mode="on-demand",this._adapter=p(r.serviceInfo),this._queue=new l({concurrency:8,process:async r=>{if(a(r),t(r.tile)){const t=r.tile.key.id,{tile:s,signal:i}=r,o={query:e("esri-tiles-debug")?{tile:t.replace(/\//g,"."),depth:r.depth}:void 0,signal:i,transform:s.transform};return this._adapter.executeQuery(r.query,o)}return this._adapter.executeQuery(r.query,r)}}),this._patchQueue=new l({concurrency:8,process:async r=>{if(a(r),t(r.tile)){const t=r.tile.key.id,{tile:s,signal:i}=r,o={query:e("esri-tiles-debug")?{tile:t.replace(/\//g,"."),depth:r.depth}:void 0,signal:i,transform:s.transform};return this._adapter.executeQuery(r.query,o)}return this._adapter.executeQuery(r.query,r)}})}destroy(){super.destroy(),this._adapter.destroy(),this._queue.destroy(),this._patchQueue.destroy()}get updating(){return!!this._queue.length}get maxRecordCountFactor(){const{query:e}=this._serviceInfo.capabilities;return e.supportsMaxRecordCountFactor?h:null}get maxPageSize(){var e;const{query:t}=this._serviceInfo.capabilities;return(null!=(e=t.maxRecordCount)?e:8e3)*r(this.maxRecordCountFactor,1)}get pageSize(){return Math.min(8e3,this.maxPageSize)}enableEvent(e,t){}subscribe(e){super.subscribe(e),this._fetchDataTile(e).catch((t=>{n(t)||y.error(new o("mapview-query-error","Encountered error when fetching tile",{tile:e,error:t}))}))}unsubscribe(e){super.unsubscribe(e)}resume(){this._queue.resume()}forEachRequest(e,t){const r=this._subscriptions.get(e),{requests:s,signal:i}=r;for(const o of s.done)t(o.message,{signal:i})}async query(e,t){return this._adapter.executeQuery(e,t)}async queryLastEditDate(){const e=this._serviceInfo.source,t={...e.query,f:"json"};return(await u(e.path,{query:t,responseType:"json"})).data.editingInfo.lastEditDate}createTileQuery(e){const t=this.createQuery();return t.quantizationParameters=e.getQuantizationParameters(),t.resultType="tile",t.geometry=e.extent,"esriGeometryPolyline"===this._serviceInfo.geometryType&&(t.maxAllowableOffset=e.resolution),this._serviceInfo.capabilities.query.supportsQuantization||(t.quantizationParameters=null,t.maxAllowableOffset=e.resolution),t}_createQuery(e,t){const r=new c({...this._queryInfo,...t});return this._serviceInfo.capabilities.query.supportsQuantization||(t.quantizationParameters=null,r.maxAllowableOffset=e.resolution),t.quantizationParameters&&"esriGeometryPolyline"===this._serviceInfo.geometryType&&(r.maxAllowableOffset=e.resolution),r.resultType="tile",r.geometry=e.extent,r}async _executePatchQuery(e,r,s,i){const o=r.clone();o.outFields=[this._serviceInfo.objectIdField,...s],o.returnCentroid=!1,o.returnGeometry=!1;const a=t(o.start)?o.start/8e3:0,n=i.signal;return this._patchQueue.push({tile:e,query:o,signal:n,depth:a})}async _resend(e,r){const{query:i,message:o}=e,n=t(i.outFields)?i.outFields:[],u=this._queryInfo.outFields,c=u.filter((e=>-1===n.indexOf(e)));if(!s(o.addOrUpdate))if(c.length)try{const e=this._subscriptions.get(o.id).tile,t=await this._executePatchQuery(e,i,c,r);a(r),i.outFields=u,o.addOrUpdate.joinAttributes(t),this._onMessage({...o,end:o.end,type:"append"})}catch(l){}else this._onMessage({...o,end:o.end,type:"append"})}async resend(){let e=0,t=!1;const r=[];for(this._subscriptions.forEach((e=>{e.requests.done.length||this._onMessage({id:e.tile.id,addOrUpdate:null,end:!1,type:"append"})}));!t;)t=!0,this._subscriptions.forEach((({requests:s,signal:i})=>{s.done.length>e&&(t=!1,r.push(this._resend(s.done[e],{signal:i})))})),e++;await Promise.all(r)}}export{m as BaseFeatureSource};
