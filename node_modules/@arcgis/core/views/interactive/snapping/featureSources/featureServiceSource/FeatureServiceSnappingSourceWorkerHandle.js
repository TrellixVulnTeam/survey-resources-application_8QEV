/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../../chunks/tslib.es6.js";import"../../../../../core/has.js";import{isNone as t,isSome as i}from"../../../../../core/maybe.js";import"../../../../../core/Logger.js";import"../../../../../core/accessorSupport/ensureType.js";import{property as r}from"../../../../../core/accessorSupport/decorators/property.js";import{subclass as o}from"../../../../../core/accessorSupport/decorators/subclass.js";import"../../../../../core/urlUtils.js";import"../../../../../core/uuid.js";import"../../../../../portal/support/resourceExtension.js";import{whenOrAbort as a}from"../../../../../core/promiseUtils.js";import n from"../../../../../geometry/Point.js";import{featureGeometryTypeKebabDictionary as s}from"../../../../../geometry/support/typeUtils.js";import{HandleOwner as d}from"../../../../../core/HandleOwner.js";import{WorkerHandle as l}from"../../../../../core/workers/WorkerHandle.js";let p=class extends d{constructor(e){super(e),this.availability=0,this.workerHandleUpdating=!0,this.editId=0}get updating(){return this.updatingHandles.updating||this.workerHandleUpdating}destroy(){this.workerHandle.destroy()}initialize(){this.workerHandle=new u(this.scheduler),this.handles.add([this.workerHandle.on("notify-updating",(({updating:e})=>this.workerHandleUpdating=e)),this.workerHandle.on("notify-availability",(({availability:e})=>this._set("availability",e)))])}async setup(e,i){const r=this.serviceInfoFromLayer(e.layer);if(t(r))return;const o={configuration:this.convertConfiguration(e.configuration),serviceInfo:r,spatialReference:e.spatialReference.toJSON()};await this.updatingHandles.addPromise(this.workerHandle.invokeMethod("setup",o,i)),this.updatingHandles.addPromise(this.workerHandle.invokeMethod("whenNotUpdating",{},i))}async configure(e,t){const i=this.convertConfiguration(e);await this.updatingHandles.addPromise(this.workerHandle.invokeMethod("configure",i,t)),this.updatingHandles.addPromise(this.workerHandle.invokeMethod("whenNotUpdating",{},t))}async refresh(e){await this.updatingHandles.addPromise(this.workerHandle.invokeMethod("refresh",{},e)),this.updatingHandles.addPromise(this.workerHandle.invokeMethod("whenNotUpdating",{},e))}async fetchCandidates(e,t){const r={distance:e.distance,point:e.coordinateHelper.toPoint(e.point,new n).toJSON(),types:e.types,filter:i(e.filter)?e.filter.createQuery().toJSON():null};return this.workerHandle.invoke(r,t)}async updateTiles(e,t){const r={tiles:e.tiles,tileInfo:i(e.tileInfo)?e.tileInfo.toJSON():null,tileSize:e.tileSize};await this.workerHandle.invokeMethod("updateTiles",r,t),this.updatingHandles.addPromise(this.workerHandle.invokeMethod("whenNotUpdating",{},t))}async applyEdits(e,t){var i,r,o,n,s,d;const l=this.editId++,p={id:l};await this.workerHandle.invokeMethod("beginApplyEdits",p,t),this.updatingHandles.addPromise(this.workerHandle.invokeMethod("whenNotUpdating",{},t));const u=await a(e.result,t),c={id:l,edits:{addedFeatures:null!=(i=null==(r=u.addedFeatures)?void 0:r.map((({objectId:e})=>e)))?i:[],deletedFeatures:null!=(o=null==(n=u.deletedFeatures)?void 0:n.map((({objectId:e})=>e)))?o:[],updatedFeatures:null!=(s=null==(d=u.updatedFeatures)?void 0:d.map((({objectId:e})=>e)))?s:[]}};await this.workerHandle.invokeMethod("endApplyEdits",c,t),this.updatingHandles.addPromise(this.workerHandle.invokeMethod("whenNotUpdating",{},t))}getDebugInfo(e){return this.workerHandle.invokeMethod("getDebugInfo",{},e)}convertConfiguration(e){return{filter:i(e.filter)?e.filter.toJSON():null,customParameters:e.customParameters}}serviceInfoFromLayer(e){var t;return"multipatch"===e.geometryType||"mesh"===e.geometryType?null:{url:e.parsedUrl.path,fields:e.fields.map((e=>e.toJSON())),geometryType:s.toJSON(e.geometryType),capabilities:e.capabilities,objectIdField:e.objectIdField,spatialReference:e.spatialReference.toJSON(),timeInfo:null==(t=e.timeInfo)?void 0:t.toJSON()}}};e([r({constructOnly:!0})],p.prototype,"scheduler",void 0),e([r({readOnly:!0})],p.prototype,"updating",null),e([r({readOnly:!0})],p.prototype,"availability",void 0),e([r()],p.prototype,"workerHandleUpdating",void 0),p=e([o("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceSnappingSourceWorkerHandle")],p);class u extends l{constructor(e){super("FeatureServiceSnappingSourceWorker","fetchCandidates",e,{strategy:"dedicated"})}getTransferList(){return[]}}export{p as FeatureServiceSnappingSourceWorkerHandle};
