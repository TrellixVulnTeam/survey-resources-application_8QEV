/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{_ as t}from"../../../chunks/tslib.es6.js";import"../../../core/has.js";import{isSome as e}from"../../../core/maybe.js";import"../../../core/Logger.js";import"../../../core/accessorSupport/ensureType.js";import{property as i}from"../../../core/accessorSupport/decorators/property.js";import{subclass as n}from"../../../core/accessorSupport/decorators/subclass.js";import"../../../core/urlUtils.js";import"../../../core/uuid.js";import"../../../portal/support/resourceExtension.js";import{isAborted as s}from"../../../core/promiseUtils.js";import{reaction as o}from"../../../core/accessorSupport/trackingUtils.js";import r from"../../../geometry/SpatialReference.js";import a from"../../../geometry/Point.js";import d from"../../../core/Evented.js";import{init as c}from"../../../core/watchUtils.js";import{HandleOwner as h}from"../../../core/HandleOwner.js";import{j as p}from"../../../chunks/vec2.js";import{squareDistance as l,anyMapPointToScreenPoint as u,sortCandidatesInPlace as f}from"./snappingUtils.js";import m from"./SnappingOptions.js";import{FeatureSnappingEngine as v}from"./FeatureSnappingEngine.js";import{SelfSnappingEngine as g}from"./SelfSnappingEngine.js";import{IntersectionSnappingCandidate as y}from"./candidates/IntersectionSnappingCandidate.js";let C=class extends(d.EventedMixin(h)){constructor(t){super(t),this.options=new m,this.engines=[],this._currentMainCandidate=null,this._currentOtherActiveCandidates=[],this.options=new m}initialize(){this.handles.add([o((()=>{const{effectiveFeatureEnabled:t,effectiveSelfEnabled:e,touchSensitivityMultiplier:i,distance:n}=this.options;return{effectiveFeatureEnabled:t,effectiveSelfEnabled:e,touchSensitivityMultiplier:i,distance:n}}),(()=>{this.doneSnapping(),this.emit("changed")})),this.watch("options",(t=>{for(const e of this.engines)e.options=t}),!0),c(this.view,"ready",(t=>this.onViewReady(t)),!0)])}destroy(){this.destroyEngines()}get updating(){return this.engines.some((t=>t.updating))}onViewReady(t){var e,i;(this.destroyEngines(),t)&&(this.engines=[new g({view:this.view,options:this.options}),new v({view:this.view,spatialReference:null!=(e=null==(i=this.view)?void 0:i.spatialReference)?e:r.WGS84,options:this.options})])}destroyEngines(){for(const t of this.engines)t.destroy();this.engines.length=0}get squaredMouseProximityTreshold(){return this.options.distance*this.options.distance}get squaredTouchProximityThreshold(){const{distance:t,touchSensitivityMultiplier:e}=this.options,i=t*e;return i*i}async snap(t,i,n){const o=i.coordinateHelper.fromPoint(t),r=await this.fetchCandidates(o,i,n);return{get valid(){return!s(n)},apply:()=>{const{snappedPoint:t,hints:n}=this.processCandidates(o,r,i);return this.removeVisualization(),e(i.visualizer)&&this.handles.add(i.visualizer.draw(n,{coordinateHelper:i.coordinateHelper,elevationInfo:i.elevationInfo,view:this.view}),w),t}}}update(t,i){this.removeVisualization();let n=t;const s=[];if(e(this._currentMainCandidate)){const e=i.coordinateHelper,o=e.fromPoint(t),r=this._currentMainCandidate.constraint.closestTo(o);if(l(u(o,e,i.elevationInfo,this.view),u(r,e,i.elevationInfo,this.view))<this.squaredPointProximityThreshold(i.pointer)){n=e.createDehydratedPoint(r),this._currentMainCandidate.targetPoint=r,s.push(...this._currentMainCandidate.hints);for(const t of this._currentOtherActiveCandidates)t.targetPoint=r,s.push(...t.hints)}else this._currentMainCandidate=null,this._currentOtherActiveCandidates=[]}return e(i.visualizer)&&this.handles.add(i.visualizer.draw(s,{coordinateHelper:i.coordinateHelper,elevationInfo:i.elevationInfo,view:this.view}),w),n}doneSnapping(){this.removeVisualization(),this._currentMainCandidate=null,this._currentOtherActiveCandidates=[]}removeVisualization(){this.handles.remove(w)}async fetchCandidates(t,e,i){return(await Promise.all(this.engines.map((n=>n.fetchCandidates(t,e,i))))).flat()}processCandidates(t,i,n){if(i.length<1)return this.doneSnapping(),{snappedPoint:n.coordinateHelper.toPoint(t,new a),hints:[]};f(t,i);const s=this._currentMainCandidate;if(e(s)){const e=this.findOldConstraintInNewCandidates(s,i);if(e>=0){if(!(i[e]instanceof y))return this.intersectWithOtherCandidates(e,i,t,n);if(p(t,s.targetPoint)<this.squaredPointProximityThreshold(n.pointer))return this.updateSnappingCandidate(s,i,n)}}return this.intersectWithOtherCandidates(0,i,t,n)}findOldConstraintInNewCandidates(t,e){return t instanceof y?this.findOldCandidateIndex(e,t.first)>=0&&this.findOldCandidateIndex(e,t.second)>=0?0:-1:this.findOldCandidateIndex(e,t)}intersectWithOtherCandidates(t,e,i,n){const s=e[t],o=[],r=n.coordinateHelper;for(let a=0;a<e.length;++a){if(a===t)continue;const d=e[a];for(const t of s.constraint.intersect(d.constraint)){const e=r.fromXYZ(t.intersection,s.targetPoint[2]);o.push([new y(r,e,s,d),l(u(i,n.coordinateHelper,n.elevationInfo,this.view),u(e,n.coordinateHelper,n.elevationInfo,this.view))])}}return o.length>0&&(o.sort(((t,e)=>t[1]-e[1])),o[0][1]<this.squaredPointProximityThreshold(n.pointer))?this.updateSnappingCandidate(o[0][0],e,n):this.updateSnappingCandidate(s,e,n)}updateSnappingCandidate(t,e,i){this.doneSnapping(),this._currentMainCandidate=t;const n=this._currentMainCandidate.targetPoint,s=[];s.push(...t.hints);for(const o of e){if(t instanceof y){if(o.constraint.objectEqual(t.first.constraint)||o.constraint.objectEqual(t.second.constraint))continue}else if(o.constraint.objectEqual(t.constraint))continue;o.constraint.check(n)&&(o.targetPoint=n,this._currentOtherActiveCandidates.push(o),s.push(...o.hints))}return{snappedPoint:i.coordinateHelper.createDehydratedPoint(n),hints:s}}squaredPointProximityThreshold(t){return"touch"===t?this.squaredTouchProximityThreshold:this.squaredMouseProximityTreshold}findOldCandidateIndex(t,e){let i=-1;for(let n=0;n<t.length;++n)if(e.constraint.objectEqual(t[n].constraint)){i=n;break}return i}get test(){return{visualizationsActive:this.handles.has(w)}}};t([i({constructOnly:!0})],C.prototype,"view",void 0),t([i()],C.prototype,"options",void 0),t([i({readOnly:!0})],C.prototype,"updating",null),t([i()],C.prototype,"engines",void 0),t([i()],C.prototype,"squaredMouseProximityTreshold",null),t([i()],C.prototype,"squaredTouchProximityThreshold",null),C=t([n("esri.views.interactive.snapping.SnappingManager")],C);const w="visualization-handle";export{C as SnappingManager};
