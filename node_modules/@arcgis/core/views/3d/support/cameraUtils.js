/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{isNone as e,unwrapOr as t,isSome as n}from"../../../core/maybe.js";import r from"../../../core/Logger.js";import{createResolver as i}from"../../../core/promiseUtils.js";import o from"../../../geometry/SpatialReference.js";import a from"../../../geometry/Point.js";import{deg2rad as s,rad2deg as c}from"../../../core/mathUtils.js";import{b as l,c as f}from"../../../chunks/vec3f64.js";import{a as u,b as m,w as p,k as d,g as v}from"../../../chunks/vec3.js";import{Cyclical as h}from"./mathUtils.js";import g from"../../../Camera.js";import{getReferenceEllipsoid as y}from"../../../geometry/projectionEllipsoid.js";import{projectPointToVector as R,projectVectorToVector as M,projectVectorToPoint as w}from"../../../geometry/projection.js";import{isSpatialReferenceSupported as x}from"../../support/spatialReferenceSupport.js";import{getResolutionForScale as j}from"../../../geometry/support/scaleUtils.js";import{getElevationAtPoint as S}from"./ElevationProvider.js";import{getGreatCircleSpanAt as T}from"./earthUtils.js";import{cameraOnContentAlongViewDirection as z}from"../camera/intersectionUtils.js";import{t as C,c as b}from"../../../chunks/cameraUtilsPlanar.js";import{t as U,c as H}from"../../../chunks/cameraUtilsSpherical.js";const P=r.getLogger("esri.views.3d.support.cameraUtils"),k=39.37,A=96,I=1,L=8,E=5,q=1,F=f(),G=f(),O={heading:0,tilt:0},W=new a,X=new h(-20037508.342788905,20037508.342788905),D=new h(-180,180);function Y(e){return e.spatialReference||o.WGS84}function N(e){return"global"===e.viewingMode?H:b}function Z(e,t,n,r,i){return N(e).headingTiltToDirectionUp(t,n,r,i)}function B(t,n){if(e(n))return null;const r=t.renderSpatialReference,i=N(t).headingTiltToDirectionUp,o=f();if(!R(n.position,o,r))return null;const a=i(o,n.heading,n.tilt);u(a.direction,a.direction,t.state.camera.distance),m(a.direction,a.direction,o);const c=z(t,o,a.direction,a.up);return c.fov=s(n.fov),c}const J=f();function K(t,n,r){const i=t.renderSpatialReference,s=ee(t,n.eye,n.viewForward,n.up,O);let l=Y(t);return M(n.eye,i,J,l)||(l=o.WGS84,M(n.eye,i,J,l)),e(r)?new g(new a(J,l),s.heading,s.tilt,c(n.fov)):(r.position.x=J[0],r.position.y=J[1],r.position.z=J[2],r.position.spatialReference=l,r.heading=s.heading,r.tilt=s.tilt,r.fov=c(n.fov),r)}function Q(e,t,n){const r=e.state.camera,i=r.width/2/r.pixelRatio;1===e.renderCoordsHelper.viewingMode&&null!=n&&(t*=Math.cos(s(n))),t/=e.renderCoordsHelper.unitInMeters;return i/(A*k/t)/Math.tan(r.fovX/2)}function V(e,t,n){const r=e.state.camera,i=t*Math.tan(r.fovX/2),o=r.width/2/r.pixelRatio;let a=A*k/(o/i);return 1===e.renderCoordsHelper.viewingMode&&(a/=Math.cos(s(n))),a*=e.renderCoordsHelper.unitInMeters,a}function $(e,t,n,r,i,o){return _(e,t,Q(e,n,t.latitude),r,i,o)}function _(t,n,r,i,o,a){if(xe(a)){const s=new we(a.signal);return oe(t,i.heading,i.tilt,n,r,o,s),void s.resolver.promise.then((n=>{const r=he(t,n,i.fov);if(!e(r))return a.resolver.resolve(r);a.resolver.reject()}),(e=>a.resolver.reject(e)))}const s=oe(t,i.heading,i.tilt,n,r,o);return he(t,s,i.fov,a)}function ee(e,t,n,r,i){return N(e).directionToHeadingTilt(t,n,r,i)}function te(e,n){return!!(e.basemapTerrain&&e.renderCoordsHelper.fromRenderCoords(n,W,e.spatialReference)&&t(S(e.elevationProvider,W),0)>W.z-q)}async function ne(e,n,r){if(!e.renderCoordsHelper.fromRenderCoords(n,W,e.spatialReference))return!1;const i=await e.elevationProvider.queryElevation(W.x,W.y,W.z,W.spatialReference,"ground",r);return t(i,0)>W.z-q}async function re(e,t,r){const i=f();if(t)if(t instanceof a){if(R(t,i,e.renderSpatialReference),null==t.z&&null!=e.basemapTerrain){const o=await e.elevationProvider.queryElevation(t.x,t.y,t.z,t.spatialReference,"ground",r);return n(o)&&e.renderCoordsHelper.setAltitude(o,i),i}}else v(i,t);else v(i,e.state.camera.center);return i}function ie(e,t){const r=f();if(t&&t instanceof a){if(R(t,r,e.renderSpatialReference),null==t.z&&null!=e.basemapTerrain){const i=S(e.elevationProvider,t);n(i)&&e.renderCoordsHelper.setAltitude(i,r)}}else v(r,t||e.state.camera.center);return r}function oe(e,t,n,r,i,o,s){const c=r&&r instanceof a?r:null;if(xe(s))return re(e,r,s.signal).then((r=>{ae(e,t,n,c,r,i,o,s)}),(e=>s.resolver.reject(e))),null;const l=ie(e,r);return ae(e,t,n,c,l,i,o,s)}function ae(t,n,r,i,o,a,s,c){if(e(i)){const n=t.renderSpatialReference;if(i=w(o,n,Y(t)),e(i))return null}a=Math.max(a,t.state.constraints.minimumPoiDistance);const u=fe(t,n,r,o,a,s),m=(0,N(t).eyeForCenterWithHeadingTilt)(o,a,u.heading,u.tilt);if(1===s&&"global"===t.viewingMode&&r>0){const e=()=>{const e=de(t,o,a,pe(t,a,r,o));return ae(t,n,e,i,o,a,s=r-e<1?0:1,c)},f=t.map.ground.navigationConstraint;if(!f||"stay-above"===f.type){if(te(t,m.eye))return e();if(xe(c))return ne(t,m.eye,c.signal).then((t=>t?e():(c.resolver.resolve({eye:m.eye,up:m.up,center:l(o),heading:m.heading,tilt:m.tilt}),null))),null}}const p=!c||xe(c)?{center:f(),eye:f(),up:f(),tilt:0,heading:0}:c;return p.eye=m.eye,p.up=m.up,p.center=l(o),p.heading=m.heading,p.tilt=m.tilt,xe(c)&&c.resolver.resolve(p),p}function se(t,n,r,i,o,s=null){let c,l,f,u,m=0;null!=n.zmax&&null!=n.zmin&&(c=(n.zmax+n.zmin)/2,m=n.zmax-n.zmin);if("global"===t.viewingMode){if(!x(n.spatialReference,"global"))return xe(s)&&s.resolver.reject(),null;const e=new a(n.xmin,n.ymin,n.spatialReference),t=new a(n.xmax,n.ymax,n.spatialReference),r=n.spatialReference.isGeographic?D:X;l=new a(r.center(e.x,t.x),(t.y+e.y)/2,n.spatialReference),null!=c&&(l.z=c);const i=y(n.spatialReference),o=T(l,e,t);f=o.lon,u=o.lat,r.diff(e.x,t.x)>r.range/2&&(f+=i.halfCircumference),f=Math.min(f,i.halfCircumference),u=Math.min(u,i.halfCircumference)}else{const e=Y(t);f=n.xmax-n.xmin,u=n.ymax-n.ymin,l=new a({x:n.xmin+.5*f,y:n.ymin+.5*u,z:c,spatialReference:e})}const p=t.state.camera,d=1/Math.tan(p.fovX/2),v=1/Math.tan(p.fovY/2),h=1/Math.tan(p.fov/2),g=Math.max(.5*f*d,.5*u*v,.5*m*h)/I;if(xe(s)){const n=new we(s.signal);return oe(t,r,i,l,g,o,n),void n.resolver.promise.then((n=>{const r=he(t,n,t.camera.fov);if(!e(r))return s.resolver.resolve(r);s.resolver.reject()}),(e=>s.resolver.reject(e)))}const R=oe(t,r,i,l,g,o);return he(t,R,t.camera.fov,s)}function ce(t,n,r){const i=t.renderSpatialReference,o=w(r,i,Y(t));if(e(o))return null;const a=Math.tan(n.fovX/2),s=Math.tan(n.fovY/2),c=p(n.eye,r),l=2*c*a*I,f=2*c*s*I;return"global"===t.viewingMode?U(t,o,l,f):C(t,o,l,f)}function le(t,n,r){const i=t.pointsOfInterest.centerOnSurfaceFrequent.distance;if(Math.log(r/i)/Math.LN2>L)return!0;const o=t.renderSpatialReference,a=Y(t),s=w(n,o,a),c=w(t.pointsOfInterest.centerOnSurfaceFrequent.renderLocation,o,a);if(e(s)||e(c))return!1;const l=Math.tan(.5*t.state.camera.fov)*i;return c.distance(s)/l>E}function fe(e,t,n,r,i,o){let a=0;return 1===o&&le(e,r,i)?(t=0,a=me(e,i,n,r)):a=ve(e,r,i,n),a=e.state.constraints.clampTilt(i,a),{heading:t,tilt:n=de(e,r,i,a)}}const ue=.7;function me(e,t,n,r){const i=e.state.constraints.tilt(t);i.max=Math.min(i.max,.5*Math.PI);const o=i.min*(1-ue)+i.max*ue,a=ve(e,r,t,n);return Math.min(a,o)}function pe(e,t,n,r){const i=e.state.constraints.tilt(t);let o=ve(e,r,t,n);return o=Math.min(o,.5*Math.PI),i.min*(1-ue)+o*ue}function de(e,t,n,r){return N(e).lookAtTiltToEyeTilt(r,t,n)}function ve(e,t,n,r){return N(e).eyeTiltToLookAtTilt(r,t,n)}function he(t,r,i,o){if(e(r))return null;const a=t.renderSpatialReference,s=w(r.eye,a,Y(t));return e(s)?null:n(o)?(o.position=s,o.heading=r.heading,o.tilt=r.tilt,o.fov=i,o):new g(s,r.heading,r.tilt,i)}function ge(e,t){var n;const r=null==(n=e.basemapTerrain)?void 0:n.tilingScheme;if(r)return r.levelAtScale(t);P.error("#scaleToZoom()","Cannot compute zoom from scale without a tiling scheme")}function ye(e,t){var n;const r=null==(n=e.basemapTerrain)?void 0:n.tilingScheme;if(r)return r.scaleAtLevel(t);P.error("#zoomToScale()","Cannot compute scale from zoom without a tiling scheme")}function Re(e,t){return e.spatialReference?j(t,e.spatialReference):void 0}function Me(e,t,n){const r=e.renderSpatialReference;let i,a;t||(t=e.state.camera);const s=o.WGS84;return t instanceof g?(i=t.position.latitude,R(t.position,F,r),R(n,G,r),a=d(F,G)):(M(t.center,r,G,s),i=G[1],a=t.distance),V(e,a,i)}class we{constructor(e){this.signal=e,this.resolver=i()}}function xe(e){return e&&"resolver"in e}export{we as AsyncContext,Me as computeScale,ee as directionToHeadingTilt,V as distanceToScale,B as externalToInternal,_ as fromCenterDistance,$ as fromCenterScale,se as fromExtent,oe as getObserverForPointAtDistance,Z as headingTiltToDirectionUp,K as internalToExternal,he as observerToCamera,Q as scaleToDistance,Re as scaleToResolution,ge as scaleToZoom,ce as toExtent,ye as zoomToScale};
