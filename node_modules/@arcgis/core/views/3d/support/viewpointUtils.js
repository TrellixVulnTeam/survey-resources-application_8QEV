/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import"../../../core/has.js";import{isSome as e,isNone as t,unwrapOr as n,unwrap as r}from"../../../core/maybe.js";import a from"../../../core/Error.js";import{eachAlways as o}from"../../../core/promiseUtils.js";import i from"../../../geometry/SpatialReference.js";import s from"../../../geometry/Geometry.js";import{canProject as c,project as l}from"../../../geometry/support/webMercatorUtils.js";import m from"../../../geometry/Point.js";import f from"../../../geometry/Extent.js";import"../../../geometry.js";import u from"../../../Graphic.js";import{result as p}from"../../../core/asyncUtils.js";import{c as g}from"../../../chunks/vec3f64.js";import{a as h,b as y,k as d,g as x,f as w,s as v,t as b}from"../../../chunks/vec3.js";import{cyclicalDeg as j}from"./mathUtils.js";import R from"../../../Camera.js";import G from"../../../Viewpoint.js";import{isPoint as z,create as S}from"../../../geometry/support/aaBoundingRect.js";import{projectVectorToPoint as k,projectPointToVector as B,projectBuffer as M,computeLinearTransformation as Z,projectVectorToVector as F}from"../../../geometry/projection.js";import{a as A}from"../../../chunks/mat3f64.js";import{a as U}from"../../../chunks/mat4f64.js";import{f as E,t as P}from"../../../chunks/mat3.js";import{empty as T,center as I,toRect as N,isPoint as O,create as V,expandWithVec3 as q,expandWithAABB as W,width as C,height as D,depth as Y}from"../../../geometry/support/aaBoundingBox.js";import{getElevationAtPoint as $}from"./ElevationProvider.js";import{frustum as X}from"./geometryUtils.js";import{cameraOnContentAlongViewDirection as _}from"../camera/intersectionUtils.js";import{internalToExternal as H,scaleToDistance as J,fromCenterDistance as K,fromExtent as L,scaleToResolution as Q,zoomToScale as ee,externalToInternal as te,computeScale as ne,AsyncContext as re,distanceToScale as ae,fromCenterScale as oe,directionToHeadingTilt as ie}from"./cameraUtils.js";const se=.66;function ce(e){return 360-j.normalize(e)}function le(e){return j.normalize(360-e)}function me(t){return e(t)&&t.resolver&&t.resolver.reject(),null}function fe(t,n){return e(t)&&t.resolver&&t.resolver.resolve(n),n}function ue(n,r,a,o=null){if(!r)return me(o);const s=n.spatialReference||i.WGS84;if(e(r.camera)){const e=r.get("camera.position.spatialReference");if(!c(e,s))return me(o);const t=r.camera.clone();return e.equals(s)||(t.position=l(t.position,s)),fe(o,t)}if(t(r.targetGeometry))return me(o);const m=r.get("targetGeometry.spatialReference");if(m&&!c(m,s))return me(o);const f=H(n,n.state.camera);let u=1;if(null!=r.rotation&&(f.heading=ce(r.rotation),u=0),null!=a&&(f.tilt=a),"point"===r.targetGeometry.type){const e=r.targetGeometry;let t;const a=r.targetGeometry.clone();return t=null!=r.scale?J(n,r.scale,e.latitude):n.state.camera.distance,K(n,a,t,f,u,o)}const p=r.targetGeometry.extent;return L(n,p,f.heading,f.tilt,u,o)}function pe(e,n,r=null){return t(r)&&(r=new G),xe(e,null,n.clone(),r)}async function ge(e,t,n){const r=Fe(e,t);if(!r)throw new a("viewpointutils-create:no-target","Missing target for creating viewpoint");const o=new R({fov:e.camera.fov}),i=new G({camera:o});if(r.target instanceof G){return Ae(await je(e,r.target,r,n,i))}if(r.target instanceof R)return Ae(Re(e,r.target,i));const s=null!=r.scale||null!=r.zoom;if(r.target instanceof f){const t=r.target.xmin===r.target.xmax||r.target.ymin===r.target.ymax;return Ae(s||t?await ze(e,r,r.target.center,o,n,i):await Be(e,r,r.target,o,n,i))}const c={boundingBox:T(),hasZ:!1,screenSpaceObjects:[]},l=s?ye(e,r):void 0;if(await be(e,r.target,l,c),isFinite(c.boundingBox[0])){let t;if(I(c.boundingBox,Ee),Ce.x=Ee[0],Ce.y=Ee[1],Ce.z=Ee[2],Ce.spatialReference=e.spatialReference,isFinite(Ce.z)&&c.hasZ?t=O(c.boundingBox):(Ce.z=void 0,t=z(N(c.boundingBox,Ne))),s||t)return Ae(await ze(e,r,Ce,o,n,i));const a=Ue(e,c.screenSpaceObjects);return Ae(await Ze(e,r,Ce,c.boundingBox,a,o,n,i))}return r.position?Ae(Se(e,r,o,i)):Ae(await ke(e,r,o,n,i))}function he(e,t){return null==t.scale&&null!=t.zoom?ee(e,t.zoom):t.scale}function ye(e,t){return Q(e,he(e,t))}function de(e,t){let n=!1;return null!=t.heading?(e.heading=t.heading,n=!0):null!=t.rotation&&(e.heading=ce(t.rotation),n=!0),null!=t.tilt&&(e.tilt=t.tilt,n=!0),null!=t.fov&&(e.fov=t.fov),n}function xe(n,r,a,o){const s=n.spatialReference||i.WGS84;return r=e(r)?r:te(n,a),t(r)||(o.targetGeometry=k(r.center,n.renderSpatialReference,s),o.scale=ne(n,r),o.rotation=le(a.heading),o.camera=a),o}function we(e,t,r){if(!t)return;if(!c(t.spatialReference,e.spatialReference))throw new a("viewpointutils:incompatible-spatialreference",`Spatial reference (${t.spatialReference?t.spatialReference.wkid:"unknown"}) is incompatible with the view (${e.spatialReference.wkid})`,{geometry:t});const o=[];if(!t.hasZ&&e.basemapTerrain){let r;switch(t.type){case"point":r=t;break;case"multipoint":case"polyline":case"mesh":r=t.extent.center;break;case"extent":r=t.center;break;case"polygon":r=t.centroid}r&&c(r,e.basemapTerrain.spatialReference)?Ee[2]=n($(e.elevationProvider,r),0):Ee[2]=0}(0,De[t.type])(t,(e=>{o.push(e[0],e[1],e[2])}),Ee);const i=o.length/3;if(0===i)return;const s=new Array(o.length);if(M(o,t.spatialReference,0,s,e.spatialReference,0,i)){t.hasZ&&(r.hasZ=!0);for(let e=0;e<s.length;e+=3)t.hasZ?(Ee[0]=s[e+0],Ee[1]=s[e+1],Ee[2]=s[e+2]):(Ee[0]=s[e+0],Ee[1]=s[e+1]),q(r.boundingBox,Ee)}}async function ve(e,n,r,a){const o=await p(e.whenViewForGraphic(n));if(!1===o.ok||t(o.value)||!("whenGraphicBounds"in o.value))return void we(e,n.geometry,a);const i=o.value,s=await p(i.whenGraphicBounds(n,{minDemResolution:r}));if(!1===s.ok)return void we(e,n.geometry,a);const{screenSpaceObjects:c,boundingBox:l}=s.value;W(a.boundingBox,l),c&&c.forEach((e=>{a.screenSpaceObjects.push(e)})),isFinite(l[2])&&(a.hasZ=!0)}async function be(e,t,n,r){if(Array.isArray(t)&&2===t.length){const n=t[0],a=t[1];if("number"==typeof n&&"number"==typeof a)return Ce.x=n,Ce.y=a,Ce.z=void 0,Ce.spatialReference=e.spatialReference.isGeographic?e.spatialReference:i.WGS84,void we(e,Ce,r)}t&&"function"==typeof t.map?await o(t.map((t=>be(e,t,n,r)))):t instanceof s?we(e,t,r):t instanceof u&&await ve(e,t,n,r)}async function je(t,n,r,a,o){if(e(n.camera))return Re(t,n.camera,o);o.scale=n.scale,o.rotation=n.rotation,o.targetGeometry=e(n.targetGeometry)?n.targetGeometry.clone():null,o.camera=null,null!=r.heading?o.rotation=le(r.heading):null!=r.rotation&&(o.rotation=r.rotation);const i=he(t,r);null!=i&&(o.scale=i);const s=new re(a);return ue(t,o,r.tilt,s),o.camera=await s.resolver.promise,o}function Re(e,t,n){const r=e.spatialReference,a=t.position.spatialReference;return c(a,r)?((t=t.clone()).fov=e.camera.fov,a.equals(r)||(t.position=l(t.position,r)),xe(e,null,t,n)):null}function Ge(e,t,n,r,a,o){const i=e.renderSpatialReference;return B(n.position,Ve,i),B(t,qe,i),o.targetGeometry=new m(t),a.position=new m(n.position),w(Oe,qe,Ve),ie(e,Ve,Oe,r.up,a),o.scale=ae(e,d(Ve,qe),o.targetGeometry.latitude),o.rotation=le(a.heading),o.camera=a,o}async function ze(e,n,r,o,i,s){if(t(r))throw new a("createfromcenter","invalid point");s.targetGeometry=r.clone();const c=_(e);if(n.position)return Ge(e,s.targetGeometry,n,c,o,s);if(n.zoomFactor){const t=c.distance/n.zoomFactor,a=h(Ee,c.viewForward,-t);y(c.eye,c.center,a),c.markViewDirty(),s.scale=ae(e,t,r.latitude)}H(e,c,o);const l=de(o,n)?0:1;if(!n.zoomFactor){s.scale=he(e,n),null==s.scale&&(B(r,Ee,e.renderSpatialReference),X.intersectsPoint(c.frustum,Ee)?s.scale=ae(e,d(c.eye,Ee),r.latitude):s.scale=ne(e,c));const t=new re(i);oe(e,s.targetGeometry,s.scale,o,l,t),s.camera=await t.resolver.promise}return s}function Se(e,t,n,r){const a=_(e);return x(Oe,a.viewForward),ie(e,a.eye,Oe,a.up,We),n.position=new m(t.position),n.heading=null!=t.heading?t.heading:We.heading,n.tilt=null!=t.tilt?t.tilt:We.tilt,xe(e,null,n,r)}async function ke(e,t,n,r,a){const o=_(e);return ze(e,t,k(o.center,e.renderSpatialReference,e.spatialReference),n,r,a)}async function Be(e,t,n,r,a,o){o.targetGeometry=n.clone();const i=_(e);H(e,i,r);const s=de(r,t)?0:1,c=new re(a);return L(e,n,r.heading,r.tilt,s,c),o.camera=await c.resolver.promise,o}function Me(e,t,n,a,o){let i=0;n.hasZ?i=n.z:e.basemapTerrain&&(i=r($(e.elevationProvider,n))),v(Ee,n.x,n.y,i),Z(e.spatialReference,Ee,Pe,e.renderSpatialReference),E(Te,Pe),P(Te,Te),T(Ie);const s=[[0,1,2],[3,1,2],[0,4,2],[3,4,2],[0,1,5],[3,1,5],[0,4,5],[3,4,5]];for(let r=0;r<s.length;r++){const t=s[r];let n=a[t[2]];isFinite(n)||(n=i),v(Ee,a[t[0]],a[t[1]],n),F(Ee,e.spatialReference,Ee,e.renderSpatialReference),q(Ie,b(Ee,Ee,Te))}const c=C(Ie),l=D(Ie),m=Y(Ie),f=1/Math.tan(t.fovX/2),u=1/Math.tan(t.fovY/2),p=.5*Math.sqrt(c*c+m*m)*Math.max(u,f)+.5*l,g=.5*l*u+.5*Math.max(c,m);return Math.max(p,g)/o}async function Ze(e,t,n,r,a,o,i,s){s.targetGeometry=n.clone();const c=_(e),l=Me(e,c,n,r,a);H(e,c,o);const m=de(o,t)?0:1;s.scale=ae(e,l,s.targetGeometry.latitude);const f=new re(i);return oe(e,s.targetGeometry,s.scale,o,m,f),s.camera=await f.resolver.promise,s}function Fe(e,t){if(!t||!e.spatialReference)return null;const n={target:null};if("declaredClass"in t||Array.isArray(t))n.target=t;else{for(const e in t)n[e]=t[e];t.center&&!n.target&&(n.target=t.center)}return n}function Ae(t){return t&&e(t.camera)&&(t.rotation=le(t.camera.heading)),t}function Ue(e,t){const n=se;if(!t.length)return n;let r=Number.NEGATIVE_INFINITY;for(let a=0;a<t.length;a++){const e=t[a].screenSpaceBoundingRect;r=Math.max(r,Math.abs(e[0]),Math.abs(e[1]),Math.abs(e[2]),Math.abs(e[3]))}return n-r/Math.min(e.width,e.height)*2}const Ee=g(),Pe=U(),Te=A(),Ie=V(),Ne=S(),Oe=g(),Ve=g(),qe=g(),We={heading:0,tilt:0},Ce=new m,De={point(e,t,n){n[0]=e.x,n[1]=e.y,e.hasZ&&(n[2]=e.z),t(n)},polygon(e,t,n){const r=e.hasZ;for(let a=0;a<e.rings.length;a++){const o=e.rings[a];for(let e=0;e<o.length;e++)n[0]=o[e][0],n[1]=o[e][1],r&&(n[2]=o[e][2]),t(n)}},polyline(e,t,n){const r=e.hasZ;for(let a=0;a<e.paths.length;a++){const o=e.paths[a];for(let e=0;e<o.length;e++)n[0]=o[e][0],n[1]=o[e][1],r&&(n[2]=o[e][2]),t(n)}},multipoint(e,t,n){const r=e.points,a=e.hasZ;for(let o=0;o<r.length;o++)n[0]=r[o][0],n[1]=r[o][1],a&&(n[2]=r[o][2]),t(n)},extent(e,t,n){e.hasZ?(t(v(n,e.xmin,e.ymin,e.zmin)),t(v(n,e.xmax,e.ymin,e.zmin)),t(v(n,e.xmin,e.ymax,e.zmin)),t(v(n,e.xmax,e.ymax,e.zmin)),t(v(n,e.xmin,e.ymin,e.zmax)),t(v(n,e.xmax,e.ymin,e.zmax)),t(v(n,e.xmin,e.ymax,e.zmax)),t(v(n,e.xmax,e.ymax,e.zmax))):(t(v(n,e.xmin,e.ymin,n[2])),t(v(n,e.xmax,e.ymin,n[2])),t(v(n,e.xmin,e.ymax,n[2])),t(v(n,e.xmax,e.ymax,n[2])))},mesh(e,t,n){const r=e.vertexAttributes&&e.vertexAttributes.position;if(r)for(let a=0;a<r.length;a+=3)t(v(n,r[a+0],r[a+1],r[a+2]))}};export{ge as create,pe as fromCamera,le as headingToRotation,ce as rotationToHeading,ue as toCamera};
