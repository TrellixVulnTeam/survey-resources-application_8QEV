/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{isNone as e,isSome as t,unwrapOr as r}from"../../../../core/maybe.js";import i from"../../../../core/PooledArray.js";import{castRenderScreenPointArray3 as n,createRenderScreenPointArray as s}from"../../../../core/screenUtils.js";import{c as o}from"../../../../chunks/vec3f64.js";import{b as a,n as l,a as c,l as d,k as h}from"../../../../chunks/vec3.js";import{sv3d as u}from"../../support/stack.js";import{c as m,f as p,a as y}from"../../../../chunks/ray.js";import{sliceFilterPredicate as g}from"../../webgl-engine/lib/intersectorUtils.js";import{Intersector as f}from"../../webgl-engine/lib/Intersector.js";class v{constructor(e,t,r){this.viewingMode=e,this.layerProvider=t,this.view=r,this.externalIntersectionHandlers=new i,this.tolerance=f.DEFAULT_TOLERANCE,this.tmpRay=m(),this.validateHUDIntersector=new f(this.viewingMode),this.validateHUDIntersector.options.hud=!1}intersectScreen(e,t){return this.intersectRay(this.getPickRay(e,this.tmpRay),I(this.viewingMode),t)}intersectScreenFreePointFallback(e,t){return this.intersectRayFreePointFallback(this.getPickRay(e,this.tmpRay),t)}intersectRayFreePointFallback(e,t){return this.intersectRay(e,I(this.viewingMode),t)||this.intersectRayFreePointLocal(e,t)}intersectRay(e,t,r,i){return t.options.selectionMode=!1,t.options.store=0,this.computeIntersection(e,t,i),!!t.results.min&&t.results.min.getIntersectionPoint(r)}getCenterRayWithSubpixelOffset(e,t,r=.5,i=.5){return e.getRenderCenter(b,r,i),b[0]+=.0466,b[1]-=.0123,p(e,b,t)}intersectIntersectorScreen(e,t,r){this.computeIntersection(this.getPickRay(e,this.tmpRay),t,r)}intersectToolIntersectorScreen(e,t,r){const i=this.getPickRay(e,this.tmpRay);this.intersectToolIntersectorRay(i,t,r)}intersectToolIntersectorRay(e,t,r){t.options.selectionMode=!0,this.computeIntersection(e,t,r);const i=t.results.min;!!this.view.basemapTerrain&&this.view.basemapTerrain.opaque||i.hasIntersectionPoint&&"TerrainRenderer"!==i.intersector||(t.options.selectionMode=!1,this.computeIntersection(e,t,r))}setTolerance(e=f.DEFAULT_TOLERANCE){this.tolerance=e}addIntersectionHandler(e){this.externalIntersectionHandlers.push(e),this.externalIntersectionHandlers.sort(((e,t)=>"Terrain"===e.type?1:"Terrain"===t.type?-1:0))}removeIntersectionHandler(e){this.externalIntersectionHandlers.removeUnordered(e),this.externalIntersectionHandlers.sort(((e,t)=>"Terrain"===e.type?1:"Terrain"===t.type?-1:0))}getPickRay(e,t=m()){const r=this.view.state.camera;return y(r,e,t)}intersectRayFreePointLocal(t,r){if(2!==this.viewingMode||e(t))return!1;const i=this.view.dataExtent,n={x:i.xmax-i.xmin,y:i.ymax-i.ymin,z:8*Math.max(i.xmax-i.xmin,i.ymax-i.ymin)},s=Math.max(n.x,n.y,n.z);if(0===s)return a(r,t.origin,l(u.get(),t.direction)),!0;const o=this.view.state.camera,h=Math.max(0,i.xmin-o.eye[0],o.eye[0]-i.xmax),m=Math.max(0,i.ymin-o.eye[1],o.eye[1]-i.ymax),p=Math.sqrt(h*h+m*m),y=Math.abs(o.relativeElevation)+Number.MIN_VALUE,g=Math.max(0,Math.log(s/y))**2;let f=s/Math.max(1,g);f=Math.max(f,Math.min(p,s));const v=c(u.get(),t.direction,f/d(t.direction));return a(r,t.origin,v),!0}intersectElevationFromScreen(e,t,r=0,i=null){return this.intersectElevation(this.getPickRay(e,this.tmpRay),t,r,i)}intersectElevation(i,s,o=0,l=null){if(e(i))return null;const c=t(s)?s.mode:"absolute-height",d=t(s)?r(s.offset,0):0,h="on-the-ground"!==c?d+o:0,m=h/this.view.renderCoordsHelper.unitInMeters;if("absolute-height"===c){if(this.view.renderCoordsHelper.intersectManifold(i,h,P)){const e=this.view.computeMapPointFromVec3d(P);return e.z-=d,e}return null}const p=this.view.state.camera,y=n(u.get());p.projectToRenderScreen(i.origin,y);const v=this.prepareFilters(null,w),R=this.view.slicePlane,x=t(R)?g(R):null,I=new f(this.viewingMode);I.options.store=0,I.options.verticalOffset=m;const b=i.origin,M=a(u.get(),b,i.direction);I.reset(b,M),I.point=y,I.camera=p,I.filterPredicate=null;const H=t(l)?"type"in l&&"graphics"===l.type?e=>e.metadata.layerUid!==l.uid:e=>e.metadata.graphicUid!==l.uid:null;switch(c){case"relative-to-scene":{const t=t=>(e(H)||H(t))&&t.metadata&&t.metadata.isElevationSource;I.intersect(v.layers,y,p,this.tolerance,null,t),this.externalIntersectionHandlers.forAll((e=>{if("I3S"===e.type||"Terrain"===e.type){const t=e.slicePlane?x:null;e.intersect(I,t,I.rayBeginPoint,I.rayEndPoint,y)}}))}break;case"on-the-ground":case"relative-to-ground":this.externalIntersectionHandlers.forAll((e=>{if(e.isGround){const t=e.slicePlane?x:null;e.intersect(I,t,I.rayBeginPoint,I.rayEndPoint,y)}}))}if(I.results.min.getIntersectionPoint(P)){const e=this.view.computeMapPointFromVec3d(P);return e.z=o,e}return null}computeIntersection(i,s,o){if(e(i))return;const l=this.view.state.camera,c=n(u.get());l.projectToRenderScreen(i.origin,c);const d=this.prepareFilters(o,w);s.options.selectOpaqueTerrainOnly=!o||!("include"in o||"exclude"in o);const m=i.origin,p=a(u.get(),i.origin,i.direction);s.reset(m,p),s.intersect(d.layers,c,l,this.tolerance);const y=this.view.slicePlane,f=t(y)?g(y):null;s.intersect(d.sliceableLayers,c,l,this.tolerance,f);const v=o&&(o.requiresGroundFeedback||o.enableDraped);this.externalIntersectionHandlers.forAll((e=>{if(s.options.isFiltered=!d.filterLayerUid(e.intersectionHandlerId),e.isGround&&v||!s.options.isFiltered){const t=e.slicePlane?f:null;e.intersect(s,t,m,p,c)}}));const R=u.get();if(o&&o.enableDraped&&s.results.ground.getIntersectionPoint(R)){const e=this.view.basemapTerrain.overlayManager.renderer,t=this.view.renderCoordsHelper.spatialReference,i=u.get();this.view.renderCoordsHelper.fromRenderCoords(R,i,this.view.spatialReference),i[2]=r(this.view.elevationProvider.getElevation(R[0],R[1],R[2],t,"ground"),0),e.intersect(s,i,d.filterRenderGeometry)}s.sortResults();const x=s.results.hud;if(x.hasIntersectionPoint){const e=n(u.get()),t=u.get(),r=u.get();this.unprojectHUDResultRay(x.center,e,t,r);const i=h(x.center,t)/h(t,r)*.99;this.validateHUDIntersector.reset(t,r),this.validateHUDIntersector.intersect(d.layers,e,l,this.tolerance),this.validateHUDIntersector.intersect(d.sliceableLayers,e,l,this.tolerance,f),this.externalIntersectionHandlers.forAll((i=>{if(!d.filterLayerUid(i.intersectionHandlerId))return;const n=i.slicePlane?f:null;i.intersect(this.validateHUDIntersector,n,t,r,e)}));const o=this.validateHUDIntersector.results.min;(null==o.dist||i<=o.dist)&&(s.results.min.copyFrom(x),s.results.all.splice(0,0,x))}}prepareFilters(e,t){const r=[],i=[];return this.layerProvider.forEachLayer((e=>{e.isPickable&&(e.isSliceable?i:r).push(e)})),t.include=e&&e.include,t.exclude=e&&e.exclude,t.layers.length=0,t.sliceableLayers.length=0,R(r,t.filterLayer,t.layers),R(i,t.filterLayer,t.sliceableLayers),t}unprojectHUDResultRay(e,t,r,i){const s=this.view.state.camera;s.projectToRenderScreen(e,t);const o=n(u.get());o[0]=t[0],o[1]=t[1],o[2]=0,s.unprojectFromRenderScreen(o,r),o[2]=1,s.unprojectFromRenderScreen(o,i)}}function R(e,t,r){for(const i of e)t&&!t(i)||r.push(i);return r}let x;function I(e){return x||(x=new f(e)),x.viewingMode=e,x}const w={include:null,exclude:null,layers:[],sliceableLayers:[],filterLayer:e=>w.filterLayerUid(e.apiLayerUid),filterLayerUid(t){const{include:r,exclude:i}=w;return e(t)?null==r&&null==i:(null==r||r.has(t))&&(null==i||!i.has(t))},filterRenderGeometry:e=>w.filterLayerUid(e.layerUid)},P=o(),b=s();export{v as SceneIntersectionHelper};
