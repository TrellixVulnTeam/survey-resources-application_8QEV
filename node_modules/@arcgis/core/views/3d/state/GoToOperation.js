/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{isSome as t,isNone as i}from"../../../core/maybe.js";import e from"../../../core/Error.js";import{createAbortController as a,onAbort as n,createAbortError as r}from"../../../core/promiseUtils.js";import s from"../../../Camera.js";import o from"../../../Viewpoint.js";import{whenOnce as l}from"../../../core/watchUtils.js";import{applySurfaceCollisionConstraint as c}from"../camera/constraintUtils/surfaceCollision.js";import{named as m}from"../../animation/easing.js";import{applyAll as h}from"../camera/constraintUtils.js";import{State as w}from"./controllers/CameraController.js";import{PointToPointAnimationController as p}from"./controllers/PointToPointAnimationController.js";import{externalToInternal as v}from"../support/cameraUtils.js";import{SurfaceCollisionCorrectionController as f}from"./controllers/SurfaceCollisionCorrectionController.js";import{create as g}from"../support/viewpointUtils.js";class u{constructor(i,e,r){this.target=i,this.options=e,this.view=r,this.state="pending",this.abortController=null,this.animationController=null,this.promise=new Promise(((i,e)=>{this.resolveCallback=i,this.rejectCallback=e;const r=a();t(this.options.signal)&&n(this.options.signal,(()=>{this.abort()})),this.abortController=r,this.waitForReady()}))}then(t,i){return this.promise.then(t,i)}catch(t){return this.promise.catch(t)}resolve(t){return this.state="finished",this.resolveCallback(t)}reject(t){return this.state="finished",this.rejectCallback(t)}abort(i=!1){switch(this.state){case"pending":case"wait-for-ready":case"wait-for-viewpoint":this.reject(r());break;case"wait-for-animation-finish":!i&&t(this.animationController)&&this.view.stateManager.view.state.cameraController===this.animationController&&this.animationController.active&&this.animationController.stopController(),this.reject(r())}}waitForReady(){this.state="wait-for-ready",this.view.stateManager.view.ready?this.createViewPoint():l(this.view.stateManager.view,"ready",this.abortController.signal).then((()=>{this.createViewPoint()}),(t=>{this.reject(t)}))}createViewPoint(){"finished"!==this.state&&(this.state="wait-for-viewpoint",this.animationController=this.options.animate?this.getAnimationController():null,g(this.view.stateManager.view,this.target,this.abortController.signal).then((t=>{if("finished"===this.state)return;const e=this.getCameraFromViewpoint(t);if(!i(e))if(this.options.animate){if(i(this.animationController))return;this.startAnimation(e,this.animationController)}else this.view.stateManager.setStateCamera(e.camera,{applyConstraints:!e.isFullySpecified,positionAndOrientationOnly:!0,doNotCancelGoToOperation:!0}),this.resolve()}),(t=>{this.reject(t)})))}internalAnimateOptions(t){const i={};return t&&(null!=t.speedFactor&&(i.speedFactor=t.speedFactor),null!=t.duration&&(i.duration=t.duration/1e3),null!=t.maxDuration&&(i.maxDuration=t.maxDuration/1e3),null!=t.easing&&("string"==typeof t.easing?i.easing=m[t.easing]:i.easing=t.easing)),i}getCameraFromViewpoint(t){const a=!!(this.target instanceof o&&this.target.camera||this.target instanceof s),n=t.camera;if(i(n))return null;if(!this.view.stateManager.isCompatible(n)){const t=n.position,i=t&&t.spatialReference,a=i?i.wkid:"none",r=this.view.stateManager.view.spatialReference.wkid;return this.reject(new e("GotoAnimation:incompatible-spatialreference",`Resulting camera has an incompatible spatial reference (camera: ${a}, view: ${r})`,{camera:n})),null}const r=v(this.view.stateManager.view,n);return i(r)?(this.reject(new e("GotoAnimation:invalid-camera","Resulting camera is invalid")),null):{viewpoint:t,camera:r,isFullySpecified:a}}startAnimation(a,n){this.state="wait-for-animation-finish";const r=n.viewAnimation;if(i(r))return void this.reject(new e("GotoAnimation:missing-animation","Unreachable code in view.stateManager"));if(r.update(a.viewpoint,"running"),!n.active||i(n.viewAnimation)||n.viewAnimation.target!==a.viewpoint||this.view.stateManager.view.state.cameraController!==n)return this.abort();let s;a.isFullySpecified?(s=new f({view:this.view.stateManager.view,desiredCamera:a.camera}),c(this.view.stateManager.view,a.camera,1)):h(this.view.stateManager.view,a.camera),n.begin(a.camera,this.internalAnimateOptions(this.options));const o=()=>{const i=this.view.stateManager.view.state.cameraController;s&&(i&&i.active?i instanceof p&&t(i.viewAnimation)&&i.viewAnimation.target===a.viewpoint&&(this.view.stateManager.view.state.cameraController=s):t(n.viewAnimation)&&n.viewAnimation.target===a.viewpoint&&"finished"===n.state&&(this.view.stateManager.view.state.cameraController=s))},l=t=>{if(!i(this.view.stateManager.view.state))switch(n.state){case w.Finished:switch(this.state){case"pending":case"wait-for-ready":case"wait-for-viewpoint":case"wait-for-animation-finish":this.resolve()}break;case w.Ready:case w.Rejected:case w.Running:case w.Stopped:switch(this.state){case"pending":case"wait-for-ready":case"wait-for-viewpoint":case"wait-for-animation-finish":this.reject(t)}}};r.when(o,(t=>l(t))),n.asyncResult={resolve:()=>l(),reject:t=>l(t)}}getAnimationController(){let i,a=null;const n=this.view.stateManager.view.state.cameraController;return n instanceof p&&(n.updateStateFromViewAnimation(),n.active&&(i=n,a=i.viewAnimation)),null!=i||(i=new p({view:this.view.stateManager.view,mode:"animation"}),a=i.viewAnimation,this.view.stateManager.view.state.switchCameraController(i))?i:(t(a)&&a.stop(),this.reject(new e("GotoAnimation:goto-cannot-interrupt","Cannot start an animation while interacting")),null)}}export{u as GoToOperation};
