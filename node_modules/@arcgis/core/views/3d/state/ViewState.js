/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import"../../../core/has.js";import{isSome as t}from"../../../core/maybe.js";import"../../../core/Logger.js";import"../../../core/accessorSupport/ensureType.js";import{property as r}from"../../../core/accessorSupport/decorators/property.js";import{subclass as o}from"../../../core/accessorSupport/decorators/subclass.js";import"../../../core/urlUtils.js";import"../../../core/uuid.js";import"../../../portal/support/resourceExtension.js";import{afterDispatch as a}from"../../../core/accessorSupport/watch.js";import s from"../../../core/Accessor.js";import i from"../../../core/Evented.js";import{f as n}from"../../../chunks/vec3f64.js";import{getReferenceEllipsoid as l}from"../../../geometry/projectionEllipsoid.js";import p from"../../ViewAnimation.js";import c from"./Constraints.js";import m from"../webgl-engine/lib/Camera.js";import{State as u}from"./controllers/CameraController.js";import{AnimationController as h}from"./controllers/AnimationController.js";import{PropertiesPool as d}from"../support/PropertiesPool.js";let C=class extends s{constructor(){super(),this._propertiesPool=new d({camera:m},this),this._lastSeenCameraProjectionValues=new m,this.events=new i,this.mode=1,this._cameraChanged=!1,this.updateQueue=new Array,this.processingUpdates=!1}exit(){this.cameraController=null,this._propertiesPool.destroy(),this._propertiesPool=new d({camera:m},this)}init(e,t){this._set("mode",e),this._set("spatialReference",t),this.camera=f(this.mode,t),this._set("constraints",new c({mode:this.mode}))}get animation(){return this.cameraController instanceof h&&t(this.cameraController.viewAnimation)?this.cameraController.viewAnimation:null}get camera(){return this._get("camera")}set camera(e){e!==y&&y.copyFrom(e),y.markViewDirty(),y.computeUp(this.mode),j.camera=y,this.events.emit("before-camera-change",j);const t=this._get("camera");if(this.cameraProjectionChanged(this._lastSeenCameraProjectionValues,y)&&(this._lastSeenCameraProjectionValues.copyFrom(y),_.camera=this._lastSeenCameraProjectionValues,this.events.emit("camera-projection-changed",_)),(!t||!t.equals(y))&&(this._set("camera",this._propertiesPool.get("camera").copyFrom(y)),this._cameraChanged=!t||!t.almostEquals(y),this._cameraChanged)){const e=a((()=>{this._cameraChanged=!1,e.remove()}))}}get contentCamera(){return t(this._contentCamera)?this._contentCamera:this.camera}set contentCamera(e){this._contentCamera=t(e)?e.clone():null}get fixedContentCamera(){return!!t(this._contentCamera)}get isGlobal(){return!this.isLocal}get isLocal(){return 2===this.mode}get navigating(){return!(!this.cameraController||!this.cameraController.isInteractive)}get stationary(){return!this._cameraChanged&&!this.navigating}get cameraController(){return this._get("cameraController")}set cameraController(e){this.stopActiveCameraController()?(e&&(e.watch("state",(t=>{t!==u.Finished&&t!==u.Stopped||(this._set("cameraController",null),this.updateCamera((t=>e.onControllerEnd(t))))}),!0),e.onControllerStart(this.camera)),this._set("cameraController",e)):e&&(e.state=u.Rejected)}switchCameraController(e){return this.cameraController=e,e.state!==u.Rejected}stopActiveCameraController(){return!(this.cameraController&&!this.cameraController.stopController())}updateCamera(e){this.updateQueue.push(e),this.processUpdateQueue()}processUpdateQueue(){if(0===this.updateQueue.length||this.processingUpdates)return;this.processingUpdates=!0;const e=this.updateQueue.shift();y.copyFrom(this._get("camera")),e(y),this.camera=y,this.processingUpdates=!1,this.processUpdateQueue()}cameraProjectionChanged(e,t){return e.fov!==t.fov||(e.fullViewport[0]!==t.fullViewport[0]||e.fullViewport[1]!==t.fullViewport[1]||e.fullViewport[2]!==t.fullViewport[2]||e.fullViewport[3]!==t.fullViewport[3]||(e.padding[0]!==t.padding[0]||e.padding[1]!==t.padding[1]||e.padding[2]!==t.padding[2]||e.padding[3]!==t.padding[3]))}};e([r({readOnly:!0,type:p})],C.prototype,"animation",null),e([r({type:m})],C.prototype,"camera",null),e([r({})],C.prototype,"_contentCamera",void 0),e([r({type:m})],C.prototype,"contentCamera",null),e([r({readOnly:!0})],C.prototype,"fixedContentCamera",null),e([r({readOnly:!0})],C.prototype,"constraints",void 0),e([r({readOnly:!0})],C.prototype,"events",void 0),e([r({readOnly:!0})],C.prototype,"isGlobal",null),e([r({readOnly:!0})],C.prototype,"isLocal",null),e([r({readOnly:!0})],C.prototype,"mode",void 0),e([r({constructOnly:!0})],C.prototype,"spatialReference",void 0),e([r({readOnly:!0})],C.prototype,"navigating",null),e([r({readOnly:!0})],C.prototype,"stationary",null),e([r()],C.prototype,"_cameraChanged",void 0),e([r()],C.prototype,"cameraController",null),C=e([o("esri.views.3d.state.ViewState")],C);var g=C;const y=new m;function f(e,t){if(1===e){const e=l(t).radius;return new m(n(4*e,0,0),n(e,0,0),n(0,0,1))}return new m(n(0,0,100),n(0,0,0),n(0,1,0))}const j={camera:null},_={camera:null};export default g;
