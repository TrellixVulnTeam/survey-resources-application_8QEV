/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../../chunks/tslib.es6.js";import"../../../../../core/has.js";import{isNone as t}from"../../../../../core/maybe.js";import"../../../../../core/Logger.js";import"../../../../../core/accessorSupport/ensureType.js";import{property as s}from"../../../../../core/accessorSupport/decorators/property.js";import{subclass as i}from"../../../../../core/accessorSupport/decorators/subclass.js";import"../../../../../core/urlUtils.js";import"../../../../../core/uuid.js";import"../../../../../portal/support/resourceExtension.js";import r from"../../../../../core/Accessor.js";import o from"../../../../../geometry/Polyline.js";import{rad2deg as a,acosClamped as n,deg2rad as c}from"../../../../../core/mathUtils.js";import{c as m}from"../../../../../chunks/vec3f64.js";import{k as l}from"../../../../../chunks/vec3.js";import p from"../../../../../core/Handles.js";import{whenOnce as d}from"../../../../../core/watchUtils.js";import{getSphericalPCPF as h,getReferenceEllipsoid as u,SphericalECEFSpatialReference as j,WGS84ECEFSpatialReference as f}from"../../../../../geometry/projectionEllipsoid.js";import{canProjectWithoutEngine as _,projectPointToVector as g,projectPointToWGS84ComparableLonLat as b}from"../../../../../geometry/projection.js";import z from"../../../../../core/Quantity.js";import{isSupported as w,geodesicLengths as v,inverseGeodeticSolver as D}from"../../../../../geometry/support/geodesicUtils.js";import{geodesicLength as P}from"../../../../../geometry/geometryEngine.js";import M from"../../measurementTools/support/UnitNormalizer.js";let y=class extends r{constructor(e){super(e),this._tempStartPosition=m(),this._tempEndPosition=m(),this._tempCornerPosition=m(),this._unitNormalizer=new M,this._handles=new p}initialize(){this._handles.add(d(this.view,"ready",(()=>this._initialize()),!0))}_initialize(){const e=this.view.spatialReference,t=h(e),s=t===j?f:t;this._sphericalPCPF=s;const i=_(e,s);this._unitNormalizer.spatialReference=i?s:e,this._handles.add([this.dataObject.watch("startPoint",(()=>this._updateMeasurement()),!0),this.dataObject.watch("endPoint",(()=>this._updateMeasurement()),!0),this.dataObject.watch("settings",(()=>this._updateMeasurement()),!0)],"model"),this._updateMeasurement()}_updateMeasurement(){const e=this.dataObject.startPoint,s=this.dataObject.endPoint;if(t(e)||t(s))return void(this.dataObject.measurement=null);const i=this._euclideanDistances(e,s),r=this._exactGeodesicDistanceAndAngle(e,s,i.horizontal.value);this.dataObject.measurement={directDistance:i.direct,horizontalDistance:i.horizontal,verticalDistance:i.vertical,geodesicDistance:r.distance,geodesicAngle:r.angle}}_euclideanDistances(e,t){e.z>t.z&&(e=[e,e=t][0]);const s=e.clone();s.z=t.z;const i=this._tempStartPosition,r=this._tempEndPosition,o=this._tempCornerPosition,a=this.view.spatialReference,n=this._sphericalPCPF,c=_(a,n)?n:a;g(e,i,c),g(t,r,c),g(s,o,c);const m=l(i,r),p=l(o,r),d=Math.abs(t.z-e.z),h=e=>this._unitNormalizer.normalizeDistance(e),u=h(m),j=h(p),f=h(d);return{direct:new z(u,"meters"),horizontal:new z(j,"meters"),vertical:new z(f,"meters")}}_exactGeodesicDistanceAndAngle(e,t,s){const i=e.spatialReference,r=new o({paths:[e,t],spatialReference:i}),a=i.isGeographic&&w(i)?v([r],"meters")[0]:i.isWebMercator?P(r,"meters"):void 0,{distance:n,angle:c}=a?{distance:a,angle:this._fallbackGeodesicAngle(a,i)}:this._fallbackGeodesicDistance(e,t,s);return{distance:new z(n,"meters"),angle:new z(c,"degrees")}}_fallbackGeodesicAngle(e,t){return e/u(t).metersPerDegree}_fallbackGeodesicDistance(e,t,s){if(b(e,k)){b(t,A);const e=c(k[0]),s=c(k[1]),i=c(A[0]),r=c(A[1]),o=Math.abs(i-e),m=n(Math.sin(s)*Math.sin(r)+Math.cos(s)*Math.cos(r)*Math.cos(o)),l=a(m),p={distance:0};return D(p,[k[0],k[1]],[A[0],A[1]]),{distance:p.distance,angle:l}}{const t=e.spatialReference,i=s;return{distance:i,angle:this._fallbackGeodesicAngle(i,t)}}}};e([s()],y.prototype,"view",void 0),e([s()],y.prototype,"dataObject",void 0),y=e([i("esri.views.3d.interactive.graphics.DirectLineMeasurement3D.DirectLineMeasurement3DController")],y);const k=m(),A=m();export{y as DirectLineMeasurement3DController};
