/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{sign as t,acosClamped as e,reciprocalClamped as i}from"../../../../core/mathUtils.js";import{c as s}from"../../../../chunks/vec3f64.js";import{d as r,g as o,b as h,n,a,f as l,c as u,p,s as f,l as c,i as x}from"../../../../chunks/vec3.js";import{t as d,i as v,r as m}from"../../../../chunks/mat4.js";import{a as g}from"../../../../chunks/mat4f64.js";import{a as V,b,f as A}from"../../../../chunks/vec2f64.js";import{s as C,g as D,o as I,d as N,a as R,h as U,e as P,l as S}from"../../../../chunks/vec2.js";import{plane as _,ray as y}from"../../support/geometryUtils.js";import T from"./GeometryUtil.js";import{intersectTriangles as k}from"../materials/internal/MaterialUtil.js";import{s as L}from"../../../../chunks/mat2.js";import{c as w}from"../../../../chunks/mat2f64.js";function B(){return{up:s(),right:s()}}function F(t,e,i){x(t.up,e.up,i),x(t.right,e.right,i)}function M(t,e,i){t[0]=i[0]*e.right[0]+i[1]*e.up[0],t[1]=i[0]*e.right[1]+i[1]*e.up[1],t[2]=i[0]*e.right[2]+i[1]*e.up[2]}function G(t,e,i){C(t,r(i,e.right),r(i,e.up))}class j{constructor(){this.pos=s(),this.posES=s(),this.posGS=s(),this.vRight=s(),this.vLeft=s(),this.frame=B(),this.rotationFrame=B(),this.rotationRight=V(),this.rotationAngle=0,this.miterStretch=w()}setFrameFromUpVector(t){o(this.frame.up,t),h(nt,this.vLeft,this.vRight),n(nt,nt),a(ht,this.frame.up,r(nt,this.frame.up)),l(ut,nt,ht),n(ut,ut),u(this.frame.right,ut,this.frame.up)}computeRotationAxisAndAngleFromUpVector(){o(this.rotationFrame.up,this.frame.up),o(this.rotationFrame.right,this.frame.right),C(this.rotationRight,1,0),a(ht,this.frame.up,r(this.frame.up,this.vLeft)),l(ht,this.vLeft,ht),p(ht,ht),n(ht,ht),a(nt,this.frame.up,r(this.frame.up,this.vRight)),l(nt,this.vRight,nt),n(nt,nt),u(at,this.rotationFrame.up,this.vLeft);const s=t(r(at,this.vRight));if(this.rotationAngle=s*(Math.PI-e(r(ht,nt))),Math.abs(this.rotationAngle)>0){const t=i(Math.cos(.5*this.rotationAngle));L(this.miterStretch,t-1+1,0,0,1)}const h=Math.PI-this.rotationAngle;this.maxStretchDistance=Math.abs(Math.min(this.vLeftLength,this.vRightLength)/Math.cos(.5*h))}}class z{constructor(){this.vertices=[],this.vertexIndices=[],this.vertexNormals=[],this.poles=[],this.poleIndices=[],this.uvs=null,this.uvIndices=null}addVertex(t,e){return this.vertices.push(b(t)),this.vertexNormals.push(b(e)),this.vertices.length-1}addUV(t){return this.uvs||(this.uvs=[],this.uvIndices=[]),this.uvs.push(t),this.uvs.length-1}addPole(t,e=null){return this.poles.push({position:b(t),normal:e?b(e):null}),this.poles.length-1}addSegment(t,e=null,i=null){this.vertexIndices.push(t.v0),this.vertexIndices.push(t.v1),e&&(this.uvIndices.push(e.v0),this.uvIndices.push(e.v1)),i&&(this.poleIndices.push(i.v0),this.poleIndices.push(i.v1))}get numSegments(){return this.vertexIndices.length/2}hasUV(){return null!=this.uvs}translate(t,e){for(const i of this.vertices)i[0]+=t,i[1]+=e;for(const i of this.poles)i.position[0]+=t,i.position[1]+=e}static circle(t=20){const e=.5,i=new z,s={v0:0,v1:0};i.addPole(A(0,0));for(let h=0;h<t;++h){const s=2*h*Math.PI/t,r=Math.cos(s),o=Math.sin(s),n=A(r*e,o*e),a=A(r,o);i.addVertex(n,a),i.addUV(h/t)}i.addUV(1);for(let h=0;h<t-1;++h){const t={v0:h,v1:h+1},e=t;i.addSegment(t,e,s)}const r={v0:t-1,v1:0},o={v0:t-1,v1:t};return i.addSegment(r,o,s),i}static rect(){const t=1,e=1,i=new z,s=A(.5*-t,.5*-e),r=A(.5*t,.5*-e),o=A(.5*t,.5*e),h=A(.5*-t,.5*e),n=A(0,-1),a=A(1,0),l=A(0,1),u=A(-1,0);i.addUV(0),i.addUV(1),i.addPole(A(0,.5*e),l),i.addPole(A(0,.5*e)),i.addPole(A(0,.5*-e)),i.addPole(A(0,.5*-e),n);const p={v0:0,v1:1};return i.addVertex(s,n),i.addVertex(r,n),i.addSegment({v0:0,v1:1},p,{v0:3,v1:3}),i.addVertex(r,a),i.addVertex(o,a),i.addSegment({v0:2,v1:3},p,{v0:2,v1:1}),i.addVertex(o,l),i.addVertex(h,l),i.addSegment({v0:4,v1:5},p,{v0:0,v1:0}),i.addVertex(h,u),i.addVertex(s,u),i.addSegment({v0:6,v1:7},p,{v0:1,v1:2}),i}}class E{constructor(t){this.vertices=[],this.offset=s(),this.xform=g(),this.vertices=t;const e=Math.floor((t.length-1)/2);o(this.offset,this.vertices[e].pos);for(const i of this.vertices)l(i.pos,i.pos,this.offset);d(this.xform,this.xform,this.offset),this.updatePathVertexInformation()}updatePathVertexInformation(){const t=this.vertices.length;let e=this.vertices[0];e.index=0,f(e.vLeft,0,0,0),e.vLeftLength=0,l(e.vRight,this.vertices[1].pos,e.pos),e.vRightLength=c(e.vRight),n(e.vRight,e.vRight);let i=e;for(let s=1;s<t;++s)e=this.vertices[s],e.index=s,o(e.vLeft,i.vRight),e.vLeftLength=i.vRightLength,s<t-1?(l(e.vRight,this.vertices[s+1].pos,e.pos),e.vRightLength=c(e.vRight),n(e.vRight,e.vRight)):(o(e.vRight,e.vLeft),e.vRightLength=e.vLeftLength),i=e}}function O(t,e){let i=null;const r=t.vertices.length,a=.99619469809,p=s(),x=s(),d=s(),v=s(),m=s(),g=s(),V=_.create();let b=t.vertices[0];o(x,e),f(p,0,1,0),T.makeOrthoBasisDirUpFallback(b.vRight,x,p,p,d,x,a),o(b.frame.up,x),o(b.frame.right,d),i=b;for(let s=1;s<r;++s){b=t.vertices[s],h(m,b.vLeft,b.vRight);let e=c(m);e>0?(e=1/Math.sqrt(e),m[0]=m[0]*e,m[1]=m[1]*e,m[2]=m[2]*e):(m[0]=b.vRight[0],m[1]=b.vRight[1],m[2]=b.vRight[2]),h(g,i.pos,i.frame.up),_.fromPositionAndNormal(b.pos,m,V);_.intersectRay(V,y.wrap(g,b.vLeft),v)?(l(v,v,b.pos),n(x,v),u(d,m,x),n(d,d)):T.makeOrthoBasisDirUpFallback(m,i.frame.up,i.frame.right,p,d,x,a),o(b.frame.up,x),o(b.frame.right,d),i=b}}class J{}class q{numProfilesPerJoin(){return 1}extrude(t,e,i){for(let s=0;s<e.vertices.length;++s)i(t.index,t.frame,e.vertices[s],e.vertexNormals[s],!1)}}class H{constructor(t=.8*Math.PI,e=1){this.cutoffAngle=t,this.numBendSubdivisions=e}numProfilesPerJoin(){return this.numBendSubdivisions+1}extrude(t,e,i){const s=pt;if(Math.abs(t.rotationAngle)>=this.cutoffAngle)for(let r=0;r<this.numBendSubdivisions+1;++r){v(ft),m(ft,ft,.5*-t.rotationAngle+r*t.rotationAngle/this.numBendSubdivisions,t.rotationFrame.up),F(s,t.frame,ft);for(let r=0;r<e.vertices.length;++r){D(e.vertices[r],t.rotationRight)*t.rotationAngle>=0?i(t.index,s,e.vertices[r],e.vertexNormals[r],!1):(I(st,e.vertices[r],t.miterStretch),i(t.index,t.frame,st,e.vertexNormals[r],!0))}}else for(let r=0;r<this.numBendSubdivisions+1;++r)for(let s=0;s<e.vertices.length;++s){const r=D(e.vertices[s],t.rotationRight)*t.rotationAngle>=0;I(st,e.vertices[s],t.miterStretch),i(t.index,t.frame,st,e.vertexNormals[s],!r)}}}const K={generateUV:!1};class Q{rebuildConnectingProfileGeometry(t,e,i){for(let s=0;s<e.vertices.length;++s)i(t.index,t.frame,e.vertices[s],e.vertexNormals[s],0,0)}}class W extends Q{constructor(){super()}getNumVertices(){return 0}getNumIndices(){return 0}rebuildCapGeometry(){}buildTopology(){}}class X extends Q{constructor(t,e=0,i=!1){super(),this.profile=t,this.profilePlaneOffset=e,this.flip=i}getNumVertices(){return this.profile.vertices.length}getNumIndices(){return 3*this.profile.numSegments}rebuildConnectingProfileGeometry(t,e,i){for(let s=0;s<e.vertices.length;++s)i(t.index,t.frame,e.vertices[s],e.vertexNormals[s],this.profilePlaneOffset,0)}rebuildCapGeometry(t,e){const i=rt;C(i,0,0);const s=this.flip?1:-1;for(let r=0;r<this.profile.vertices.length;++r)e(t.index,t.frame,this.profile.vertices[r],i,this.profilePlaneOffset,s)}buildTopology(t,e){const i=this.vertexBufferStart+this.profile.vertexIndices[0];for(let s=1;s<this.profile.numSegments;++s){const t=this.profile.vertexIndices[2*s+0],r=this.profile.vertexIndices[2*s+1],o=this.vertexBufferStart+t,h=this.vertexBufferStart+r;this.flip?e(h,o,i):e(i,o,h)}}}class Y extends Q{constructor(t){super(),this.flip=!1,this.sign=0,this.breakNormals=!1,this.numSegments=3,this.profile=t.profile,this.flip=t.flip,this.sign=this.flip?1:-1,this.breakNormals=t.breakNormals,this.numSegments=t.subdivisions}getNumVertices(){let t=0;return t=this.profile.vertices.length*(this.numSegments-1),this.breakNormals&&(t+=this.profile.vertices.length),t+=this.profile.poles.length,t}getNumIndices(){let t=0;t+=2*this.profile.numSegments*(this.numSegments-1);for(let e=0;e<this.profile.numSegments;++e){const i=this.profile.vertexIndices[2*e+0],s=this.profile.vertexIndices[2*e+1];this.profile.poleIndices[i]===this.profile.poleIndices[s]?t+=1:t+=2}return 3*t}rebuildCapGeometry(t,e){const i=t.frame,s=.5*this.sign,r=st,o=rt;C(o,0,0);for(let h=0;h<this.profile.poles.length;++h){const r=this.profile.poles[h];r.normal?e(t.index,i,r.position,r.normal,s,0):e(t.index,i,r.position,o,s,this.sign)}if(this.breakNormals)for(let h=0;h<this.profile.vertices.length;++h)e(t.index,i,this.profile.vertices[h],this.profile.vertexNormals[h],0,0);for(let h=0;h<this.numSegments-1;++h){const n=(1-(h+1)/this.numSegments)*Math.PI*.5,a=Math.sin(n),l=Math.cos(n);for(let h=0;h<this.profile.vertices.length;++h){const n=this.profile.poles[this.profile.poleIndices[h]];N(r,this.profile.vertices[h],n.position),R(r,r,a),n.normal?(U(r,r,n.position),e(t.index,i,r,n.normal,s*l,0)):(P(o,r),R(o,o,a),U(r,r,n.position),e(t.index,i,r,o,s*l,this.sign*l))}}}buildTopology(t,e){const i=this.breakNormals?this.vertexBufferStart+this.profile.poles.length:this.firstProfileVertexIndex,s=this.breakNormals?this.vertexBufferStart+this.profile.poles.length+this.profile.vertices.length:this.vertexBufferStart+this.profile.poles.length;for(let r=0;r<this.profile.numSegments;++r){const t=this.profile.vertexIndices[2*r+0],o=this.profile.vertexIndices[2*r+1],h=this.vertexBufferStart+this.profile.poleIndices[t],n=this.vertexBufferStart+this.profile.poleIndices[o];let a=i+t,l=i+o;for(let i=0;i<this.numSegments-1;++i){const r=s+i*this.profile.vertices.length+t,h=s+i*this.profile.vertices.length+o;this.flip?(e(r,l,a),e(l,r,h)):(e(a,l,r),e(h,r,l)),a=r,l=h}this.flip?(e(h,l,a),h!==n&&e(h,n,l)):(e(a,l,h),h!==n&&e(l,n,h))}}}class Z{constructor(t,e,i,s,r,o=K){this.options=o,this._extrusionVertexCount=0,this._triangleCount=0,this.numExtrusionProfiles=0,this.numVerticesTotal=0,this.numNormalsTotal=0,this.numUVTotal=0,this.profile=e,this.path=t,this.extruder=i,this.startCap=s,this.endCap=r;const h=this.path.vertices.length-2;this.numExtrusionProfiles=i.numProfilesPerJoin()*h+2,this.numVerticesTotal=e.vertices.length*this.numExtrusionProfiles,this.numNormalsTotal=this.numVerticesTotal,this.startCap.vertexBufferStart=this.numVerticesTotal;const n=this.startCap.getNumVertices();this.numVerticesTotal+=n,this.numNormalsTotal+=n,this.endCap.vertexBufferStart=this.numVerticesTotal;const a=this.endCap.getNumVertices();this.numVerticesTotal+=a,this.numNormalsTotal+=a,this.pathVertexData=new Float32Array(1*this.numVerticesTotal),this.profileRightAxisData=new Float32Array(4*this.numVerticesTotal),this.profileUpAxisData=new Float32Array(4*this.numVerticesTotal),this.profileVertexAndNormalData=new Float32Array(4*this.numVerticesTotal),this.profile.hasUV()&&this.options.generateUV&&(this.numUVTotal=this.profile.uvs.length,this.uvData=new Float32Array(2*this.numUVTotal)),this.originData=new Float32Array(3*this.path.vertices.length),this.rebuildGeometry(),this.buildTopology()}emitVertex(t,e,i,s,r){if(this.profileRightAxisData[4*this._extrusionVertexCount+0]=e.right[0],this.profileRightAxisData[4*this._extrusionVertexCount+1]=e.right[1],this.profileRightAxisData[4*this._extrusionVertexCount+2]=e.right[2],this.profileUpAxisData[4*this._extrusionVertexCount+0]=e.up[0],this.profileUpAxisData[4*this._extrusionVertexCount+1]=e.up[1],this.profileUpAxisData[4*this._extrusionVertexCount+2]=e.up[2],this.profileVertexAndNormalData[4*this._extrusionVertexCount+0]=i[0],this.profileVertexAndNormalData[4*this._extrusionVertexCount+1]=i[1],this.profileVertexAndNormalData[4*this._extrusionVertexCount+2]=s[0],this.profileVertexAndNormalData[4*this._extrusionVertexCount+3]=s[1],this.pathVertexData[this._extrusionVertexCount]=t,r){const e=this.path.vertices[t];this.profileRightAxisData[4*this._extrusionVertexCount+3]=e.rotationRight[0]*e.maxStretchDistance,this.profileUpAxisData[4*this._extrusionVertexCount+3]=e.rotationRight[1]*e.maxStretchDistance}else this.profileRightAxisData[4*this._extrusionVertexCount+3]=0,this.profileUpAxisData[4*this._extrusionVertexCount+3]=0;++this._extrusionVertexCount}emitCapVertex(t,e,i,s,r,o){this.profileRightAxisData[4*this._extrusionVertexCount+0]=e.right[0],this.profileRightAxisData[4*this._extrusionVertexCount+1]=e.right[1],this.profileRightAxisData[4*this._extrusionVertexCount+2]=e.right[2],this.profileUpAxisData[4*this._extrusionVertexCount+0]=e.up[0],this.profileUpAxisData[4*this._extrusionVertexCount+1]=e.up[1],this.profileUpAxisData[4*this._extrusionVertexCount+2]=e.up[2],this.profileVertexAndNormalData[4*this._extrusionVertexCount+0]=i[0],this.profileVertexAndNormalData[4*this._extrusionVertexCount+1]=i[1],this.profileVertexAndNormalData[4*this._extrusionVertexCount+2]=s[0],this.profileVertexAndNormalData[4*this._extrusionVertexCount+3]=s[1],this.pathVertexData[this._extrusionVertexCount]=t,this.profileRightAxisData[4*this._extrusionVertexCount+3]=r,this.profileUpAxisData[4*this._extrusionVertexCount+3]=o,++this._extrusionVertexCount}emitTriangle(t,e,i){this.vertexIndices[3*this._triangleCount+0]=t,this.vertexIndices[3*this._triangleCount+1]=e,this.vertexIndices[3*this._triangleCount+2]=i,this.pathVertexIndices[3*this._triangleCount+0]=this.pathVertexData[t],this.pathVertexIndices[3*this._triangleCount+1]=this.pathVertexData[e],this.pathVertexIndices[3*this._triangleCount+2]=this.pathVertexData[i],this.normalIndices[3*this._triangleCount+0]=t,this.normalIndices[3*this._triangleCount+1]=e,this.normalIndices[3*this._triangleCount+2]=i,++this._triangleCount}rebuildGeometry(){const t=(t,e,i,s,r)=>this.emitVertex(t,e,i,s,r),e=(t,e,i,s,r,o)=>this.emitCapVertex(t,e,i,s,r,o);this._extrusionVertexCount=0;for(const i of this.path.vertices)this.originData[3*i.index+0]=i.pos[0],this.originData[3*i.index+1]=i.pos[1],this.originData[3*i.index+2]=i.pos[2];this.startCap.rebuildConnectingProfileGeometry(this.path.vertices[0],this.profile,e);for(let i=1;i<this.path.vertices.length-1;++i)this.extruder.extrude(this.path.vertices[i],this.profile,t);if(this.endCap.rebuildConnectingProfileGeometry(this.path.vertices[this.path.vertices.length-1],this.profile,e),this.startCap.rebuildCapGeometry(this.path.vertices[0],e),this.endCap.rebuildCapGeometry(this.path.vertices[this.path.vertices.length-1],e),this.profile.hasUV()&&this.options.generateUV)for(let i=0;i<this.profile.uvs.length;++i)this.uvData[2*i+0]=this.profile.uvs[i],this.uvData[2*i+1]=0}buildTopology(){const t=(t,e,i)=>this.emitTriangle(t,e,i);this._triangleCount=0;const e=this.profile.vertices.length,i=this.profile.numSegments,s=this.numExtrusionProfiles-1;let r=3*(2*(i*s));this.startCap.indexBufferStart=r,this.startCap.firstProfileVertexIndex=0,r+=this.startCap.getNumIndices(),this.endCap.indexBufferStart=r,this.endCap.firstProfileVertexIndex=e*(this.numExtrusionProfiles-1),r+=this.endCap.getNumIndices(),this.vertexIndices=new Uint32Array(r),this.normalIndices=new Uint32Array(r),this.pathVertexIndices=new Uint32Array(r),this.profile.hasUV()&&this.options.generateUV&&(this.uvIndices=new Uint32Array(r));for(let o=0;o<i;++o){const i=this.profile.vertexIndices[2*o],r=this.profile.vertexIndices[2*o+1];for(let o=0;o<s;++o){const s=o*e+i,h=(o+1)*e+r,n=o*e+r;t(s,(o+1)*e+i,h),t(s,h,n)}}this.startCap.buildTopology(this.path.vertices[0],t),this.endCap.buildTopology(this.path.vertices[this.path.vertices.length-1],t)}onPathChanged(){this.rebuildGeometry()}}class ${constructor(t){this.builder=t}get xform(){return this.builder.path.xform}onPathChanged(){this.builder.onPathChanged()}}class tt extends ${constructor(t){super(t),this.vertexAttributePosition=null,this.vertexAttributeNormal=null,this.vertexAttributeColor=null,this.vertexAttributePosition=new Float32Array(3*this.builder.numVerticesTotal),this.vertexAttributeNormal=new Float32Array(3*this.builder.numNormalsTotal),this.vertexAttributeColor=new Uint8Array(4),this.vertexAttributeColor[0]=255,this.vertexAttributeColor[1]=255,this.vertexAttributeColor[2]=255,this.vertexAttributeColor[3]=255}bakeVertexColors(t){this.vertexAttributeColor[0]=255*t[0],this.vertexAttributeColor[1]=255*t[1],this.vertexAttributeColor[2]=255*t[2],this.vertexAttributeColor[3]=255*(t.length>3?t[3]:1)}bake(e){this.size=e;for(let i=0;i<this.builder.numVerticesTotal;++i){const s=this.builder.pathVertexData[i],r=0===s||s===this.builder.path.vertices.length-1,o=it;f(o,this.builder.originData[3*s+0],this.builder.originData[3*s+1],this.builder.originData[3*s+2]);const h=ht,n=st,a=nt,l=at,p=lt;let c=0,x=0;if(f(l,this.builder.profileRightAxisData[4*i+0],this.builder.profileRightAxisData[4*i+1],this.builder.profileRightAxisData[4*i+2]),f(p,this.builder.profileUpAxisData[4*i+0],this.builder.profileUpAxisData[4*i+1],this.builder.profileUpAxisData[4*i+2]),C(n,this.builder.profileVertexAndNormalData[4*i+0]*e[0],this.builder.profileVertexAndNormalData[4*i+1]*e[1]),r)u(a,p,l),c=this.builder.profileRightAxisData[4*i+3]*e[0],x=this.builder.profileUpAxisData[4*i+3];else{const e=rt,s=ot;C(e,this.builder.profileRightAxisData[4*i+3],this.builder.profileUpAxisData[4*i+3]);const r=S(e);P(e,e);const o=D(n,e);if(Math.abs(o)>r){C(s,-e[1],e[0]);const i=D(n,s);R(e,e,r*t(o)),R(s,s,i),U(n,e,s)}f(a,0,0,0)}f(h,l[0]*n[0]+p[0]*n[1],l[1]*n[0]+p[1]*n[1],l[2]*n[0]+p[2]*n[1]),this.vertexAttributePosition[3*i+0]=o[0]+h[0]+a[0]*c,this.vertexAttributePosition[3*i+1]=o[1]+h[1]+a[1]*c,this.vertexAttributePosition[3*i+2]=o[2]+h[2]+a[2]*c;const d=st;C(d,this.builder.profileVertexAndNormalData[4*i+2],this.builder.profileVertexAndNormalData[4*i+3]),this.vertexAttributeNormal[3*i+0]=l[0]*d[0]+p[0]*d[1]+a[0]*x,this.vertexAttributeNormal[3*i+1]=l[1]*d[0]+p[1]*d[1]+a[1]*x,this.vertexAttributeNormal[3*i+2]=l[2]*d[0]+p[2]*d[1]+a[2]*x}}createGeometryData(){const t=[["position",this.builder.vertexIndices],["normal",this.builder.normalIndices]],e=[["position",{size:3,data:this.vertexAttributePosition,exclusive:!0}],["normal",{size:3,data:this.vertexAttributeNormal,exclusive:!0}]];if(this.vertexAttributeColor){const i=this.builder.vertexIndices.length;t.push(["color",new Uint32Array(i)]),e.push(["color",{size:4,data:this.vertexAttributeColor}])}return{vertexAttributes:e,indices:t}}onPathChanged(){super.onPathChanged(),this.bake(this.size)}intersect(t,e,i){const s=this.builder.vertexIndices,r={size:3,data:this.vertexAttributePosition},o=s.length/3;k(t,e,0,o,s,r,void 0,void 0,i)}}class et extends ${constructor(t,e,i,s){super(t),this.sizeAttributeValue=e,this.colorAttributeValue=i,this.opacityAttributeValue=s,this.vvData=null,this.baked=new tt(t),this.vvData=new Float32Array(4*this.builder.path.vertices.length);for(let r=0;r<this.builder.path.vertices.length;++r){this.vvData[4*r+0]=e,this.vvData[4*r+1]=i,this.vvData[4*r+2]=s;const t=0===r||r===this.builder.path.vertices.length-1;this.vvData[4*r+3]=t?1:0}}createGeometryData(){return{vertexAttributes:[["position",{size:3,data:this.builder.originData,exclusive:!0}],["profileRight",{size:4,data:this.builder.profileRightAxisData,exclusive:!0}],["profileUp",{size:4,data:this.builder.profileUpAxisData,exclusive:!0}],["profileVertexAndNormal",{size:4,data:this.builder.profileVertexAndNormalData,exclusive:!0}],["featureValue",{size:4,data:this.vvData,exclusive:!0}]],indices:[["position",this.builder.pathVertexIndices],["profileRight",this.builder.vertexIndices],["profileUp",this.builder.vertexIndices],["profileVertexAndNormal",this.builder.vertexIndices],["featureValue",this.builder.pathVertexIndices]]}}}const it=s(),st=V(),rt=V(),ot=V(),ht=s(),nt=s(),at=s(),lt=s(),ut=s(),pt=B(),ft=g();export{Z as Builder,Q as CapBuilder,J as Extruder,et as FastUpdatePathGeometry,H as MiterExtruder,W as NoCapBuilder,E as Path,$ as PathGeometryData,j as PathVertex,z as Profile,Y as RoundCapBuilder,q as SimpleExtruder,tt as StaticPathGeometry,X as TriangulationCapBuilder,O as computeMinimumRotationTangentFrame,B as makeFrame,M as profileSpaceToVertexSpace,G as vertexSpaceToProfileSpace};
