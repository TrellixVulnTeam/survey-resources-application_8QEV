/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{forEach as e}from"../../../../../core/typedArrayUtil.js";import{range as t}from"../../../../../core/arrayUtils.js";import{deg2rad as o,acosClamped as n}from"../../../../../core/mathUtils.js";import{c as r}from"../../../../../chunks/vec3f64.js";import{k as s,s as c,g as a,d as i,c as l,f as g,n as f}from"../../../../../chunks/vec3.js";import{directionFromTo as m}from"../../../support/mathUtils.js";const p=-1;function u(n,r,l,g=V){const f=n.vertices.position,m=n.vertices.componentIndex,u=o(g.anglePlanar),I=o(g.angleSignificantEdge),j=Math.cos(I),N=Math.cos(u),x=y.edge,F=x.position0,U=x.position1,k=x.faceNormal0,E=x.faceNormal1,D=w(n),M=v(n),P=M.length/4,S=r.allocate(P);let b=0;const L=P,q=l.allocate(L);let z=0,B=0,C=0;const G=t(0,P),H=new Float32Array(P);e(H,((e,t,o)=>{f.getVec(M[4*t+0],F),f.getVec(M[4*t+1],U),o[t]=s(F,U)})),G.sort(((e,t)=>H[t]-H[e]));const J=new Array,K=new Array;for(let e=0;e<P;e++){const t=G[e],o=H[t],n=M[4*t+0],s=M[4*t+1],g=M[4*t+2],v=M[4*t+3],w=v===p;if(f.getVec(n,F),f.getVec(s,U),w)c(k,D[3*g+0],D[3*g+1],D[3*g+2]),a(E,k),x.componentIndex=m.get(n),x.cosAngle=i(k,E);else{if(c(k,D[3*g+0],D[3*g+1],D[3*g+2]),c(E,D[3*v+0],D[3*v+1],D[3*v+2]),x.componentIndex=m.get(n),x.cosAngle=i(k,E),d(x,N))continue;x.cosAngle<-.9999&&a(E,k)}B+=o,C++,w||h(x,j)?(r.write(S,b++,x),J.push(o)):A(x,u)&&(l.write(q,z++,x),K.push(o))}const O=new Float32Array(J.reverse()),Q=new Float32Array(K.reverse());return{regular:{instancesData:r.trim(S,b),lodInfo:{lengths:O}},silhouette:{instancesData:l.trim(q,z),lodInfo:{lengths:Q}},averageEdgeLength:B/C}}function h(e,t){return e.cosAngle<t}function d(e,t){return e.cosAngle>t}function A(e,t){const o=n(e.cosAngle),r=y.fwd,s=y.ortho;m(r,e.position1,e.position0);return o*(i(l(s,e.faceNormal0,e.faceNormal1),r)>0?-1:1)>t}function v(e){const t=e.faces.length/3,o=e.faces,n=e.neighbors;let r=0;for(let a=0;a<t;a++){const e=n[3*a+0],t=n[3*a+1],s=n[3*a+2],c=o[3*a+0],i=o[3*a+1],l=o[3*a+2];r+=e===p||c<i?1:0,r+=t===p||i<l?1:0,r+=s===p||l<c?1:0}const s=new Int32Array(4*r);let c=0;for(let a=0;a<t;a++){const e=n[3*a+0],t=n[3*a+1],r=n[3*a+2],i=o[3*a+0],l=o[3*a+1],g=o[3*a+2];(e===p||i<l)&&(s[c++]=i,s[c++]=l,s[c++]=a,s[c++]=e),(t===p||l<g)&&(s[c++]=l,s[c++]=g,s[c++]=a,s[c++]=t),(r===p||g<i)&&(s[c++]=g,s[c++]=i,s[c++]=a,s[c++]=r)}return s}function w(e){const t=e.faces.length/3,o=e.vertices.position,n=e.faces,r=I.v0,s=I.v1,c=I.v2,a=new Float32Array(3*t);for(let i=0;i<t;i++){const e=n[3*i+0],t=n[3*i+1],m=n[3*i+2];o.getVec(e,r),o.getVec(t,s),o.getVec(m,c),g(s,s,r),g(c,c,r),l(r,s,c),f(r,r),a[3*i+0]=r[0],a[3*i+1]=r[1],a[3*i+2]=r[2]}return a}const y={edge:{position0:r(),position1:r(),faceNormal0:r(),faceNormal1:r(),componentIndex:0,cosAngle:0},ortho:r(),fwd:r()},I={v0:r(),v1:r(),v2:r()},V={anglePlanar:4,angleSignificantEdge:35};export{u as extractEdges};
