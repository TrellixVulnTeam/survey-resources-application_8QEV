/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../../chunks/tslib.es6.js";import"../../../../../core/has.js";import{isUint16Array as t}from"../../../../../core/typedArrayUtil.js";import{disposeMaybe as r,destroyMaybe as s,isNone as o,isSome as i}from"../../../../../core/maybe.js";import"../../../../../core/Logger.js";import"../../../../../core/accessorSupport/ensureType.js";import{property as n}from"../../../../../core/accessorSupport/decorators/property.js";import{subclass as a}from"../../../../../core/accessorSupport/decorators/subclass.js";import"../../../../../core/urlUtils.js";import"../../../../../core/uuid.js";import"../../../../../portal/support/resourceExtension.js";import{equals as c}from"../../../../../core/arrayUtils.js";import{createAbortController as d}from"../../../../../core/promiseUtils.js";import l from"../../../../../core/Accessor.js";import{clamp as m}from"../../../../../core/mathUtils.js";import{c as h}from"../../../../../chunks/vec3f64.js";import{s as g,g as u,k as p}from"../../../../../chunks/vec3.js";import{c as f}from"../../../../../chunks/mat4.js";import{WatchUpdatingTracking as b}from"../../../../support/WatchUpdatingTracking.js";import{a as y}from"../../../../../chunks/mat3f64.js";import{a as j}from"../../../../../chunks/mat4f64.js";import{f as w,t as v,d as O}from"../../../../../chunks/mat3.js";import{g as E}from"../../../../../chunks/sphere.js";import x from"../../../../webgl/BufferObject.js";import R from"../../../../webgl/VertexArrayObject.js";import{Object3D as M}from"../Object3D.js";import T from"../GridLocalOriginFactory.js";import{VertexPosition as C}from"../../core/shaderLibrary/attributes/VertexPosition.glsl.js";import{c as k}from"../../../../../chunks/vec33.js";import{TwoVectorPosition as P}from"../../core/util/TwoVectorPosition.js";import{BufferManager as B}from"../TextureBackedBuffer/BufferManager.js";import{applyToModelMatrix as D}from"../localOriginHelper.js";import{LocalOriginManager as L}from"../LocalOriginManager.js";import{VertexLayout as V,EdgeShaderAttributeLocations as A,glVertexLayout as U,EdgeInputBufferLayout as H}from"./bufferLayouts.js";import{RegularEdgeBufferWriter as I,SilhouetteEdgeBufferWriter as z}from"./edgeBufferWriters.js";import{EdgeRenderer as S,LINE_WIDTH_FRACTION_FACTOR as F,EXTENSION_LENGTH_OFFSET as G}from"./EdgeRenderer.js";import K from"./EdgeWorkerHandle.js";import{generateStrokesTexture as N}from"./strokes.js";import{determineRendererType as q,estimateLengthAtDistance as W,determineEdgeTransparency as _,determineObjectTransparency as Y,fillComponenBufferIndices as J,computeEdgeCount as Q}from"./util.js";let X=class extends l{constructor(e){super(e),this.updatingHandles=new b,this.perObjectData=new Map,this.renderers=new Map,this.localOrigins=new L(new T),this.numberOfRenderedEdges=0,this.gpuMemoryUsage=0,this.workerAbort=d(),this.tmpModelPosition=h(),this.tmpCameraPosition=h()}initialize(){this.worker=new K(this.scheduler),this.componentColorManager=new B(this.rctx,2);const e=V.createBuffer(4);for(let t=0;t<4;t++)e.sideness.set(t,0,0===t||3===t?0:1),e.sideness.set(t,1,0===t||1===t?0:1);this.verticesBufferObject=x.createVertex(this.rctx,35044,e.buffer)}destroy(){this.destroyed||(this.perObjectData.forEach(((e,t)=>{this.perObjectData.delete(t),e.renderables.forEach((e=>{this.removeRenderable(e)}))})),this.strokesTexture=r(this.strokesTexture),this.componentColorManager=s(this.componentColorManager),this.workerAbort.abort(),this.worker.destroy(),this.verticesBufferObject=r(this.verticesBufferObject),this.perObjectData.clear(),this.renderers.clear(),this.updatingHandles.destroy())}get updating(){return this.updatingHandles.updating}get usedMemory(){return this.gpuMemoryUsage}get numberOfRenderedPrimitives(){return this.numberOfRenderedEdges}shouldRender(){return this.renderers.size>0}async addComponentObject(e,t,r,s,o,i,n,a){if(this.hasObject(e))return;let c;const d=new ee(new Promise((e=>c=e)),r);this.perObjectData.set(e,d),await this.updatingHandles.addPromise(this.addComponentGeometry(t,d,s,o,i,n,a)),this.setNeedsRender(),c()}async addOrUpdateObject3D(e,t,r,s){const o=new Array;let i;const n=new ee(new Promise((e=>i=e))),a=this.perObjectData.get(e);if(this.perObjectData.set(e,n),r.mergeGeometries&&e.geometries.length>1&&$(e))o.push(this.addObjectMergedGeometries(e,n,t,r,s));else for(let c=0;c<e.geometries.length;c++){const i=e.geometries[c],a=e.geometryRecords[c];a.material.supportsEdges&&o.push(this.addGeometry(e,n,i,a,t[0],r,s))}await this.updatingHandles.addPromise(Promise.all(o)),a&&a.waitLoaded((()=>{a.renderables.forEach((e=>this.removeRenderable(e))),this.setNeedsRender()}),this.updatingHandles),this.setNeedsRender(),i()}hasObject(e){return this.perObjectData.has(e)}async updateAllComponentOpacities(e,t){const r=t instanceof Array?e=>t[e]:()=>t;(await this.updatingHandles.addPromise(this.getObjectEntry(e))).renderables.forEach((e=>{const t=e.components.meta.length;for(let s=0;s<t;s++){const t=r(s),o=e.components.meta[s],i=o.index;o.material.opacity=t,e.components.buffer.textureBuffer.setDataElement(i,1,3,255*t)}this.updateTransparency(e)})),this.setNeedsRender()}async updateAllComponentMaterials(e,t,r,s){const o=e instanceof M,i=!!r.slicePlaneEnabled,n=q(t),a=S.getKey(n,i,o);(await this.updatingHandles.addPromise(this.getObjectEntry(e))).renderables.forEach((e=>{if(a!==e.rendererKey){const t=this.renderers.get(e.rendererKey),r=this.acquireRenderer(n,i,o);t.removeRenderable(e),t.refCount.decrement(),e.rendererKey=a,r.addRenderable(e)}for(let r=0;r<t.length;r++)e.components.meta[r].material=t[r];s&&this.updateComponentBuffer(e.components),this.updateTransparency(e)})),this.setNeedsRender()}async updateObjectVisibility(e,t){(await this.updatingHandles.addPromise(this.getObjectEntry(e))).renderables.forEach((e=>e.visible=t)),this.setNeedsRender()}removeObject(e){const t=this.perObjectData.get(e);t&&(this.perObjectData.delete(e),t.waitLoaded((()=>{t.renderables.forEach((e=>this.removeRenderable(e))),this.setNeedsRender()}),this.updatingHandles))}async getObjectEntry(e){const t=this.perObjectData.get(e);if(!t)throw"no object";return await t.loaded,t}removeAll(){this.perObjectData.forEach(((e,t)=>this.removeObject(t)))}render(e,t){if(o(this.componentColorManager))return;this.localOrigins.updateViewMatrices(e.camera.viewMatrix);const r=e.camera.viewInverseTransposeMatrix,s=h(),i=new P,n=new C.ViewProjectionTransform,a=y();g(s,r[3],r[7],r[11]),i.set(s),u(n.worldFromView_TH,i.high),u(n.worldFromView_TL,i.low),w(n.viewFromCameraRelative_RS,e.camera.viewMatrix),f(n.projFromView,e.camera.projectionMatrix);const c=y();v(c,n.viewFromCameraRelative_RS),O(a,c),this.renderers.forEach((e=>{0===e.refCount.value&&(this.renderers.delete(e.key),e.dispose())})),this.componentColorManager.garbageCollect(),this.componentColorManager.updateTextures();let d=0,l=0;if(this.renderers.forEach((e=>e.forEachRenderable((e=>{d+=e.statistics.averageEdgeLength,l++}),t))),0===l)return;const m={distanceFalloffFactor:40*d/l,minimumEdgeLength:W(e.camera.fullViewport[3],e.camera.fovY,1,3.5*e.camera.pixelRatio),transparency:t,viewProjectionTransform:n,transformNormal_ViewFromGlobal:a};this.updateObjectCameraDistances(e),this.numberOfRenderedEdges=0,this.renderers.forEach((t=>{this.renderRegularEdges(t,e,m),this.renderSilhouetteEdges(t,e,m)}))}updateTransparency(e){const t=_(e.components.meta),r=Y(e.components.meta);t===e.edgeTransparency&&r===e.objectTransparency||(e.edgeTransparency=t,e.objectTransparency=r,this.renderers.get(e.rendererKey).setRenderablesDirty())}computeModelTransformWithLocalOrigin(e,t,r){if(e.getCombinedStaticTransformation(t,r),t.origin)this.localOrigins.register(t.origin);else{const e=g(this.tmpModelPosition,r[12],r[13],r[14]);t.origin=this.localOrigins.acquire(e)}return D(t.origin.vec3,r),r}updateComponentBuffer(e){const{meta:t,buffer:r}=e;for(let s=0;s<t.length;s++){const e=t[s].material,o=t[s].index,i=m(Math.round(e.size*F),0,255),n=m(e.extensionLength,-G,255-G)+G,a="solid"===e.type?0:1,c=255*e.opacity,d=e.color,l=255*d[0],h=255*d[1],g=255*d[2],u=255*d[3];r.textureBuffer.setData(o,0,l,h,g,u),r.textureBuffer.setData(o,1,i,n,a,c)}}createComponentBuffers(e){if(o(this.componentColorManager))return null;const t=new Array,r=this.componentColorManager.getBuffer(e.length);for(let o=0;o<e.length;o++){const s=e[o],i=r.acquireIndex();t.push({index:i,material:s})}const s={meta:t,buffer:r};return this.updateComponentBuffer(s),s}extractEdges(e,t,r,s,o,i=o.length){return this.worker.process({data:t,indices:o,indicesLength:i,writerSettings:e,skipDeduplicate:r},this.workerAbort.signal,s)}createEdgeResources(e){const t={};if(o(this.verticesBufferObject))return t;if(e.regular.lodInfo.lengths.length>0){const r=new R(this.rctx,A,{vertices:U,instances:I.glLayout},{vertices:this.verticesBufferObject,instances:x.createVertex(this.rctx,35044,e.regular.instancesData.buffer)});t.regular={vao:r,lod:e.regular.lodInfo}}if(e.silhouette.lodInfo.lengths.length>0){const r=new R(this.rctx,A,{vertices:U,instances:z.glLayout},{vertices:this.verticesBufferObject,instances:x.createVertex(this.rctx,35044,e.silhouette.instancesData.buffer)});t.silhouette={vao:r,lod:e.silhouette.lodInfo}}return t}async addGeometry(e,t,r,s,o,i,n){const a={position:r.vertexAttributes.get("position"),indices:r.indices.get("position"),modelTransform:this.computeModelTransformWithLocalOrigin(e,s,j()),origin:s.origin};return this.addPositionData(t,a,r.edgeIndicesLength,o,i,n)}async addPositionData(e,t,r,s,i,n=!1){const a=this.createComponentBuffers([s]);if(o(a)||r<=0)return;const c=this.acquireRenderer(s.type,!!i.slicePlaneEnabled),{modelTransform:d,origin:l}=t,m=t.indices,h=t.position,g=h.data.length/h.size,u=H.createBuffer(g);for(let o=0;o<g;o++)u.position.set(o,0,h.data[o*h.size+0]),u.position.set(o,1,h.data[o*h.size+1]),u.position.set(o,2,h.data[o*h.size+2]);J(a.meta,[0,u.componentIndex.count],u.componentIndex);const p=await this.updatingHandles.addPromise(this.extractEdges(c.writerSettings,u,!1,n,m,r)),{regular:f,silhouette:b}=this.createEdgeResources(p),y=(f?f.vao.size:0)+(b?b.vao.size:0),j={regular:f,silhouette:b,transform:{modelMatrix:d,origin:l},statistics:{gpuMemoryUsage:y,averageEdgeLength:p.averageEdgeLength},components:a,visible:!0,edgeTransparency:_(a.meta),objectTransparency:Y(a.meta),distanceToCamera:0,rendererKey:c.key};e.renderables.push(j),c.addRenderable(j),this.gpuMemoryUsage+=y}async addComponentGeometry(e,t,r,s,i,n,a){const c=this.createComponentBuffers(n);if(o(c))return;const d=q(n),l=this.acquireRenderer(d,a.slicePlaneEnabled||!1,!1),m=H.createBuffer(r.count);k(m.position,r),J(c.meta,i,m.componentIndex,s);const h=!0,g=l.writerSettings,u=await this.updatingHandles.addPromise(this.extractEdges(g,m,h,!1,s)),{regular:p,silhouette:f}=this.createEdgeResources(u),b=(p?p.vao.size:0)+(f?f.vao.size:0),y={regular:p,silhouette:f,transform:e,statistics:{gpuMemoryUsage:b,averageEdgeLength:u.averageEdgeLength},components:c,visible:!0,edgeTransparency:_(c.meta),objectTransparency:Y(c.meta),distanceToCamera:0,rendererKey:l.key};t.renderables.push(y),l.addRenderable(y),this.gpuMemoryUsage+=b}async addObjectMergedGeometries(e,r,s,o,i){const n=new Map;let a=0,c=null,d=null;for(let b=0;b<e.geometries.length;b++){const r=e.geometries[b],s=e.geometryRecords[b];if(!s.material.supportsEdges)continue;!d&&s.origin&&(d=s);const o=r.indices.get("position");a+=r.edgeIndicesLength,null!=c&&c!==Uint16Array||(c=t(o)?Uint16Array:Uint32Array)}const l=a?new c(a):null,m=[];let h=0;for(let t=0;t<e.geometries.length;t++){const r=e.geometries[t];if(!e.geometryRecords[t].material.supportsEdges)continue;const s=r.vertexAttributes.get("position"),o=r.indices.get("position");let i=n.get(s.data);if(null==i){i=m.length/3;for(let e=0;e<s.data.length;e+=s.size)m.push(s.data[e+0]),m.push(s.data[e+1]),m.push(s.data[e+2]);n.set(s.data,i)}if(o)for(let e=0;e<r.edgeIndicesLength;e++)l[h++]=i+o[e]}const g=d||e.geometryRecords[0],u=this.computeModelTransformWithLocalOrigin(e,g,j()),p=g.origin;for(let t=0;t<e.geometryRecords.length;t++)e.geometryRecords[t].origin=p;const f={position:{data:m,size:3},indices:l,modelTransform:u,origin:p};await this.updatingHandles.addPromise(this.addPositionData(r,f,l.length,s[0],o,i))}acquireRenderer(e,t,r=!0){const s=S.getKey(e,t,r);let i=this.renderers.get(s);return o(this.strokesTexture)&&(this.strokesTexture=N(this.rctx)),i||(i=new S(this.rctx,this.techniqueRepository,{type:e,slicePlaneEnabled:t,strokesTexture:this.strokesTexture,legacy:r}),this.renderers.set(s,i)),i.refCount.increment(),i}removeRenderable(e){const t=this.renderers.get(e.rendererKey);if(t){t.removeRenderable(e),t.refCount.decrement(),Z(e),"origin"in e.transform&&this.localOrigins.release(e.transform.origin),this.gpuMemoryUsage-=e.statistics.gpuMemoryUsage;for(const t of e.components.meta)e.components.buffer.releaseIndex(t.index)}}updateObjectCameraDistances(e){const t=e.camera.viewInverseTransposeMatrix;g(this.tmpCameraPosition,t[3],t[7],t[11]),this.perObjectData.forEach(((e,t)=>{const r=i(e.center)?e.center:E(t.getBounds()),s=p(r,this.tmpCameraPosition);e.renderables.forEach((e=>e.distanceToCamera=s))}))}renderRegularEdges(e,t,r){e.bindRegularEdges(t,r);const s=r.transparency;e.forEachRenderable((s=>{if(!s.visible||!s.regular)return;const o=Q(s.regular.lod.lengths,s.distanceToCamera,r);"origin"in s.transform&&(t.localViewMatrixForEdges=this.localOrigins.getViewMatrix(s.transform.origin)),e.renderRegularEdges(s,t,o),this.numberOfRenderedEdges+=o}),s)}renderSilhouetteEdges(e,t,r){e.bindSilhouetteEdges(t,r);const s=r.transparency;e.forEachRenderable((s=>{if(!s.visible||!s.silhouette)return;const o=Q(s.silhouette.lod.lengths,s.distanceToCamera,r);"origin"in s.transform&&(t.localViewMatrixForEdges=this.localOrigins.getViewMatrix(s.transform.origin)),e.renderSilhouetteEdges(s,t,o),this.numberOfRenderedEdges+=o}),s)}};function Z(e){e.regular&&(e.regular.vao.vertexBuffers.instances.dispose(),e.regular.vao.dispose(!1),e.regular.vao=null),e.silhouette&&(e.silhouette.vao.vertexBuffers.instances.dispose(),e.silhouette.vao.dispose(!1),e.silhouette.vao=null)}function $(e){let t=null,r=null;for(let s=0;s<e.geometries.length;s++){const o=e.geometryRecords[s];if(o.material.supportsEdges){if(t){if(!c(t,o.transformation))return!1}else t=o.transformation;if(!r&&o.origin)r=o;else if(r&&o.origin&&r.origin.id!==o.origin.id)return!1}}return!0}e([n({constructOnly:!0})],X.prototype,"rctx",void 0),e([n({constructOnly:!0})],X.prototype,"techniqueRepository",void 0),e([n({constructOnly:!0})],X.prototype,"setNeedsRender",void 0),e([n({constructOnly:!0})],X.prototype,"scheduler",void 0),e([n({readOnly:!0})],X.prototype,"updatingHandles",void 0),e([n({readOnly:!0})],X.prototype,"updating",null),X=e([a("esri.views.3d.webgl-engine.lib.edgeRendering.EdgeView")],X);class ee{constructor(e,t=null){this.center=t,this.renderables=new Array,this.loaded=e,this.loaded.then((()=>this.loaded=!0))}waitLoaded(e,t){!0===this.loaded?e():t.addPromise(this.loaded.then((()=>e())))}}export{X as EdgeView};
