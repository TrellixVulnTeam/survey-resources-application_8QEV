/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{_ as r}from"../../../../chunks/tslib.es6.js";import{ReloadableShaderModule as e}from"../core/shaderTechnique/ReloadableShaderModule.js";import{ShaderTechnique as t}from"../core/shaderTechnique/ShaderTechnique.js";import{ShaderTechniqueConfiguration as o,parameter as i}from"../core/shaderTechnique/ShaderTechniqueConfiguration.js";import{Default3D as s}from"../lib/DefaultVertexAttributeLocations.js";import a from"../../../webgl/Program.js";import{makePipelineState as n,defaultDepthWriteParams as p,defaultColorWriteParams as l,separateBlendingParams as c}from"../../../webgl/renderState.js";import{View as m}from"../core/shaderLibrary/util/View.glsl.js";import{OITBlending as d,OITDepthTest as h,OITDepthWrite as u}from"../lib/OrderIndependentTransparency.js";import{bindMultipassTerrainUniforms as f}from"../core/shaderLibrary/shading/MultipassTerrainTest.glsl.js";import{C as g}from"../../../../chunks/CheckerBoard.glsl.js";class b extends t{initializeProgram(r){const e=b.shader.get(),t=this.configuration,o=e.build({OITEnabled:0===t.transparencyPassType,multipassTerrainEnabled:t.multipassTerrainEnabled,cullAboveGround:t.cullAboveGround});return new a(r.rctx,o.generateSource("vertex"),o.generateSource("fragment"),s)}bindPass(r,e,t){m.bindProjectionMatrix(this.program,t.camera.projectionMatrix),this.program.setUniform2fv("size",e.size),this.program.setUniform4fv("color1",e.color1),this.program.setUniform4fv("color2",e.color2),t.multipassTerrainEnabled&&(this.program.setUniform2fv("cameraNearFar",t.camera.nearFar),this.program.setUniform2fv("inverseViewport",t.inverseViewport),f(this.program,r,t))}bindDraw(r){m.bindView(this.program,r)}setPipelineState(r){const e=this.configuration,t=3===r,o=2===r;return n({blending:e.transparent?t?T:d(r):null,depthTest:{func:h(r)},depthWrite:t?e.writeDepth&&p:u(r),colorWrite:l,polygonOffset:t||o?e.polygonOffset&&y:{factor:-1,units:-25}})}initializePipeline(){return this.setPipelineState(this.configuration.transparencyPassType)}}b.shader=new e(g,(()=>import("./CheckerBoard.glsl.js")));const y={factor:0,units:-25},T=c(770,1,771,771);class v extends o{constructor(){super(...arguments),this.transparent=!1,this.writeDepth=!0,this.polygonOffset=!1,this.transparencyPassType=3,this.multipassTerrainEnabled=!1,this.cullAboveGround=!0}}r([i()],v.prototype,"transparent",void 0),r([i()],v.prototype,"writeDepth",void 0),r([i()],v.prototype,"polygonOffset",void 0),r([i({count:4})],v.prototype,"transparencyPassType",void 0),r([i()],v.prototype,"multipassTerrainEnabled",void 0),r([i()],v.prototype,"cullAboveGround",void 0);export{b as CheckerBoardTechnique,v as CheckerBoardTechniqueConfiguration};
