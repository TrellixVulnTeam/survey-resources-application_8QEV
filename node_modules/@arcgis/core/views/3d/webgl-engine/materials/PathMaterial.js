/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{isNone as e}from"../../../../core/maybe.js";import{clamp as t}from"../../../../core/mathUtils.js";import{BufferViewVec4f as i}from"../../support/buffer/BufferView.js";import{fromValues as s}from"../../../../geometry/support/aaBoundingBox.js";import{newLayout as a}from"../../support/buffer/InterleavedLayout.js";import{assert as r}from"../lib/Util.js";import{computeAttachmentOriginLines as n}from"../lib/geometryDataUtils.js";import o from"../lib/GLMaterial.js";import{intersectAabbInvDir as u}from"./internal/MaterialUtil.js";import{Material as h,materialParametersDefaults as c}from"../lib/Material.js";import{writeDefaultAttributes as l,writeBufferVec4 as p}from"./internal/bufferWriterUtils.js";import d from"./VisualVariableMaterialParameters.js";import{isPathGeometry as f}from"../lib/PathGeometry.js";import{pathVertexAttributeLocations as m,PathTechniqueConfiguration as b,PathTechnique as v}from"./PathTechnique.js";const g=r;class S extends h{constructor(e){super(e,y),this.supportsEdges=!0,this._vertexAttributeLocations=m,this.techniqueConfig=new b,this.vertexBufferLayout=S.getVertexBufferLayout(this.params)}getTechniqueConfig(e,t){return this.techniqueConfig.output=e,this.techniqueConfig.vvSize=this.params.vvSizeEnabled,this.techniqueConfig.vvColor=this.params.vvColorEnabled,this.techniqueConfig.vvOpacity=this.params.vvOpacityEnabled,this.techniqueConfig.slicePlaneEnabled=this.params.slicePlaneEnabled,this.techniqueConfig.transparent=this.params.transparent,this.techniqueConfig.sceneHasOcludees=this.params.sceneHasOcludees,0!==e&&7!==e||(this.techniqueConfig.doubleSidedMode=this.params.doubleSided&&"normal"===this.params.doubleSidedType?1:this.params.doubleSided&&"winding-order"===this.params.doubleSidedType?2:0,this.techniqueConfig.receiveShadows=this.params.receiveShadows,this.techniqueConfig.receiveSSAO=!(!t||!t.ssaoEnabled)&&this.params.receiveSSAO),this.techniqueConfig.transparencyPassType=t?t.transparencyPassType:3,this.techniqueConfig.multipassTerrainEnabled=!!t&&t.multipassTerrainEnabled,this.techniqueConfig.cullAboveGround=!t||t.cullAboveGround,this.techniqueConfig}getPassParameters(){return this.params}isVisibleInPass(e){return 4!==e&&6!==e&&7!==e||this.params.castShadows}isVisible(){const e=this.params;return!!super.isVisible()&&e.opacity>0}intersect(i,a,r,n,o,h,c){const l=i;if(!f(l))return;const p=l.path,d=[this.params.size[0],this.params.size[1]];if(this.params.vvSizeEnabled){const e=this.params.vvSizeOffset,i=this.params.vvSizeFactor,s=this.params.vvSizeMinSize,a=this.params.vvSizeMaxSize,r=p.sizeAttributeValue;d[0]*=t(e[0]+r*i[0],s[0],a[0]),d[1]*=t(e[2]+r*i[2],s[2],a[2])}const m=Math.max(d[0],d[1]),b=i.boundingInfo;if(e(b))return void this._intersectTriangles(p,d,o,h,c);const v=s(b.bbMin[0]-m,b.bbMin[1]-m,b.bbMin[2]-m,b.bbMax[0]+m,b.bbMax[1]+m,b.bbMax[2]+m),g=[h[0]-o[0],h[1]-o[1],h[2]-o[2]],S=Math.sqrt(g[0]*g[0]+g[1]*g[1]+g[2]*g[2]),q=[S/g[0],S/g[1],S/g[2]];u(v,o,q,n.tolerance)&&this._intersectTriangles(p,d,o,h,c)}_intersectTriangles(e,t,i,s,a){e.baked.size&&e.baked.size[0]===t[0]&&e.baked.size[1]===t[1]||e.baked.bake(t),e.baked.intersect(i,s,a)}computeAttachmentOrigin(e,t){const i=e.vertexAttributes;if(!i)return null;const s=i.get("position");return n(s,null,!1,t)}createBufferWriter(){return new x(this.vertexBufferLayout)}getGLMaterial(e){if(0===e.output||7===e.output||1===e.output||2===e.output||4===e.output||3===e.output&&this.params.castShadows)return new q(e)}static getVertexBufferLayout(e){let t=a().vec3f("position").vec4f("profileRight").vec4f("profileUp").vec4f("profileVertexAndNormal");return(e.vvColorEnabled||e.vvSizeEnabled||e.vvOpacityEnabled)&&(t=t.vec4f("featureValue")),t}}class q extends o{constructor(e){super(e),this.updateParameters()}updateParameters(e){this.technique=this.techniqueRep.acquireAndReleaseExisting(v,this.material.getTechniqueConfig(this.output,e),this.technique)}beginSlot(e){return e===(this.technique.configuration.transparent?5:3)}_updateOccludeeState(e){e.hasOccludees!==this.material.params.sceneHasOcludees&&this.material.setParameterValues({sceneHasOcludees:e.hasOccludees})}_updateShadowState(e){e.shadowMappingEnabled!==this.technique.configuration.receiveShadows&&this.material.setParameterValues({receiveShadows:e.shadowMappingEnabled})}ensureParameters(e){0!==this.output&&7!==this.output||(this._updateShadowState(e),this._updateOccludeeState(e)),this.updateParameters(e)}bind(e,t){e.bindProgram(this.technique.program),this.technique.bindPass(e,this.material.getPassParameters(),t)}}const y={size:[1,1,1],ambient:[.2,.2,.2],diffuse:[.8,.8,.8],specular:[0,0,0],opacity:1,doubleSided:!1,doubleSidedType:"normal",receiveSSAO:!0,receiveShadows:!1,castShadows:!0,slicePlaneEnabled:!1,transparent:!1,sceneHasOcludees:!1,...d.Default,...c};class x{constructor(e){this.vertexBufferLayout=e}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return e.indices.get("position").length}write(e,t,s,a){const r=e=>{if(t.vertexAttributes.has(e)){const r=t.vertexAttributes.get(e),n=t.indices.get(e);g(4===r.size);const o=s.getField(e,i);if(!o)throw new Error("unable to acquire view for "+e);p(n,r.data,o,a)}};r("profileRight"),r("profileUp"),r("profileVertexAndNormal"),this.vertexBufferLayout.hasField("featureValue")&&r("featureValue"),l(t,this.vertexBufferLayout,e.transformation,e.invTranspTransformation,s,a)}}export{S as PathMaterial};
