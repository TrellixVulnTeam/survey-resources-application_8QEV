/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{c as e}from"../../../../chunks/vec3f64.js";import{s as t,n as s,f as r,c as i,k as n,i as o}from"../../../../chunks/vec3.js";import{newLayout as a}from"../../support/buffer/InterleavedLayout.js";import c from"../lib/GLMaterial.js";import{Material as u,materialParametersDefaults as f}from"../lib/Material.js";import{MeasurementArrowTechniqueConfiguration as l,MeasurementArrowTechnique as p}from"../shaders/MeasurementArrowTechnique.js";class h extends u{constructor(e){super(e,g),this.techniqueConfig=new l}getTechniqueConfig(){return this.techniqueConfig.polygonOffsetEnabled=this.params.polygonOffset,this.techniqueConfig}dispose(){}getPassParameters(){return this.params}intersect(){}createBufferWriter(){return new w}getGLMaterial(e){return 0===e.output?new m(e):void 0}}class m extends c{constructor(e){super(e),this.updateParameters()}updateParameters(){this.technique=this.techniqueRep.acquireAndReleaseExisting(p,this.material.getTechniqueConfig(),this.technique)}beginSlot(e){return 3===e}bind(e,t){e.bindProgram(this.technique.program),this.technique.bindPass(e,this.material.getPassParameters(),t)}}const g={width:32,outlineSize:.2,outlineColor:[1,.5,0,1],stripeLength:1,stripeEvenColor:[1,1,1,1],stripeOddColor:[1,.5,0,1],polygonOffset:!1,...f},d=a().vec3f("position").vec3f("normal").vec2f("uv0").f32("auxpos1"),v=e(),q=e(),b=e(),x=e(),C=e();class w{constructor(){this.vertexBufferLayout=d}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return 2*(e.indices.get("position").length/2+1)}write(e,a,c,u){const f=a.vertexAttributes.get("position").data,l=a.vertexAttributes.get("normal").data,p=f.length/3,h=a&&a.indices&&a.indices.get("position");h&&h.length!==2*(p-1)&&console.warn("MeasurementArrowMaterial does not support indices");const m=v,g=q,d=b,w=x,P=C,j=e.transformation,y=e.invTranspTransformation,L=c.position,M=c.normal,A=c.uv0;let T=0;for(let v=0;v<p;++v){const e=3*v;if(t(m,f[e],f[e+1],f[e+2]),v<p-1){const e=3*(v+1);t(g,f[e],f[e+1],f[e+2]),t(P,l[e],l[e+1],l[e+2]),s(P,P),r(d,g,m),s(d,d),i(w,P,d),s(w,w)}const a=n(m,g);j&&y&&(o(m,m,j),o(g,g,j),o(w,w,y));const c=u+2*v,h=c+1;L.setVec(c,m),L.setVec(h,m),M.setVec(c,w),M.setVec(h,w),A.set(c,0,T),A.set(c,1,-1),A.set(h,0,T),A.set(h,1,1),v<p-1&&(T+=a)}const B=c.auxpos1;for(let t=0;t<2*p;++t)B.set(u+t,T)}}export{h as MeasurementArrowMaterial};
