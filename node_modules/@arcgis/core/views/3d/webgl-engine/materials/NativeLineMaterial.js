/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{isSome as e,isNone as t}from"../../../../core/maybe.js";import s from"../../../../core/Logger.js";import{createRenderScreenPointArray3 as r}from"../../../../core/screenUtils.js";import{c as i}from"../../../../chunks/vec3f64.js";import{s as n,f as o,d as a,a as c,b as u,g as l,l as p,k as m}from"../../../../chunks/vec3.js";import{c as f}from"../../../../chunks/vec2.js";import{BufferViewVec3f as h}from"../../support/buffer/BufferView.js";import{plane as d,lineSegment as g}from"../../support/geometryUtils.js";import{isTranslationMatrix as P}from"../lib/Util.js";import{computeAttachmentOriginLines as b}from"../lib/geometryDataUtils.js";import{isInstanceHidden as j}from"./renderers/utils.js";import q from"../lib/GLMaterial.js";import{intersectDrapedRenderLineGeometry as v}from"./internal/MaterialUtil.js";import{Material as C,materialParametersDefaults as x}from"../lib/Material.js";import{writeDefaultAttributes as y}from"./internal/bufferWriterUtils.js";import{PositionColorLayout as L,PositionLayout as O,DefaultBufferWriter as w}from"./internal/DefaultBufferWriter.js";import{NativeLineTechniqueConfiguration as D,NativeLineTechnique as S}from"../shaders/NativeLineTechnique.js";const A=s.getLogger("esri.views.3d.webgl-engine.materials.NativeLineMaterial");class B extends C{constructor(e){super(e,T),this.techniqueConfig=new D}getTechniqueConfig(t){this.techniqueConfig.output=t,this.techniqueConfig.slicePlaneEnabled=this.params.slicePlaneEnabled,this.techniqueConfig.vertexColors=this.params.vertexColors,this.techniqueConfig.transparent=this.params.color[3]<1||this.params.width<1;const s=e(this.params.stipplePattern);return this.techniqueConfig.stippleEnabled=s,this.techniqueConfig.stippleOffColorEnabled=s&&e(this.params.stippleOffColor),this.techniqueConfig.stippleIntegerRepeatsEnabled=s&&this.params.stippleIntegerRepeats,this.techniqueConfig.sceneHasOcludees=this.params.sceneHasOcludees,this.techniqueConfig}getPassParameters(){return this.params}intersect(e,t,s,r,i,n,o,a,c){c?v(e,r,n,1,o):this.intersectLineGeometry(e,t,s,r,o)}intersectLineGeometry(e,t,s,r,i){if(!r.options.selectionMode||j(t))return;if(!P(s))return void A.error("intersection assumes a translation-only matrix");const h=e.vertexAttributes.get("position").data,b=r.camera,q=F;f(q,r.point);const v=2;n(X[0],q[0]-v,q[1]+v,0),n(X[1],q[0]+v,q[1]+v,0),n(X[2],q[0]+v,q[1]-v,0),n(X[3],q[0]-v,q[1]-v,0);for(let n=0;n<4;n++)if(!b.unprojectFromRenderScreen(X[n],z[n]))return;d.fromPoints(b.eye,z[0],z[1],J),d.fromPoints(b.eye,z[1],z[2],K),d.fromPoints(b.eye,z[2],z[3],Q),d.fromPoints(b.eye,z[3],z[0],Y);let C=Number.MAX_VALUE;for(let n=0;n<h.length-5;n+=3){if(M[0]=h[n]+s[12],M[1]=h[n+1]+s[13],M[2]=h[n+2]+s[14],U[0]=h[n+3]+s[12],U[1]=h[n+4]+s[13],U[2]=h[n+5]+s[14],d.signedDistance(J,M)<0&&d.signedDistance(J,U)<0||d.signedDistance(K,M)<0&&d.signedDistance(K,U)<0||d.signedDistance(Q,M)<0&&d.signedDistance(Q,U)<0||d.signedDistance(Y,M)<0&&d.signedDistance(Y,U)<0)continue;if(b.projectToRenderScreen(M,G),b.projectToRenderScreen(U,N),G[2]<0&&N[2]>0){o(H,M,U);const e=b.frustum,t=-d.signedDistance(e[4],M)/a(H,d.normal(e[4]));c(H,H,t),u(M,M,H),b.projectToRenderScreen(M,G)}else if(G[2]>0&&N[2]<0){o(H,U,M);const e=b.frustum,t=-d.signedDistance(e[4],U)/a(H,d.normal(e[4]));c(H,H,t),u(U,U,H),b.projectToRenderScreen(U,N)}else if(G[2]<0&&N[2]<0)continue;G[2]=0,N[2]=0;const e=g.distance2(g.fromPoints(G,N,I),q);e<C&&(C=e,l(V,M),l(_,U))}const x=r.rayBeginPoint,y=r.rayEndPoint;if(C<v*v){let e=Number.MAX_VALUE;if(g.closestLineSegmentPoint(g.fromPoints(V,_,I),g.fromPoints(x,y,W),k)){o(k,k,x);const t=p(k);c(k,k,1/t),e=t/m(x,y)}i(e,k)}}computeAttachmentOrigin(e,t){const s=e.vertexAttributes;if(!s)return!1;const r=s.get("position");return b(r,null,!1,t)}createBufferWriter(){const e=this.params.vertexColors?L:O;return t(this.params.stipplePattern)?new w(e):new R(e.clone().vec3f("auxpos1"))}getGLMaterial(e){return 0===e.output||4===e.output?new E(e):void 0}}class E extends q{constructor(e){super(e),this.updateParameters()}updateParameters(){this.technique=this.techniqueRep.acquireAndReleaseExisting(S,this.material.getTechniqueConfig(this.output),this.technique)}beginSlot(e){return 3===e}_updateOccludeeState(e){e.hasOccludees!==this.material.params.sceneHasOcludees&&(this.material.setParameterValues({sceneHasOcludees:e.hasOccludees}),this.updateParameters())}ensureParameters(e){0===this.output&&this._updateOccludeeState(e)}bind(e,t){e.bindProgram(this.technique.program),this.technique.bindPass(e,this.material.getPassParameters(),t)}getPipelineState(e,t){return this.technique.getPipelineState(t)}}class R{constructor(e){this.vertexBufferLayout=e}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return e.indices.get("position").length}write(e,t,s,r){y(t,this.vertexBufferLayout,e.transformation,e.invTranspTransformation,s,r),this.writeAuxpos1(e,t,s,r)}writeAuxpos1(e,t,s,r){const i=s.getField("auxpos1",h),n=t.indices.get("position"),o=t.vertexAttributes.get("position").data,a=e.transformation,c=i.typedBufferStride,u=i.typedBuffer;r*=c;for(let l=0;l<n.length;l+=2){const e=3*n[l],t=o[e],s=o[e+1],i=o[e+2],p=a[0]*t+a[4]*s+a[8]*i+a[12],m=a[1]*t+a[5]*s+a[9]*i+a[13],f=a[2]*t+a[6]*s+a[10]*i+a[14];for(let n=0;n<2;++n)u[r]=p,u[r+1]=m,u[r+2]=f,r+=c}}}const T={color:[1,1,1,1],vertexColors:!1,slicePlaneEnabled:!1,width:1,stipplePattern:null,stippleIntegerRepeats:!1,stippleOffColor:null,sceneHasOcludees:!1,...x},M=i(),U=i(),H=i(),k=i(),G=r(),N=r(),V=i(),_=i(),I=g.create(),W=g.create(),F=i(),X=[r(),r(),r(),r()],z=[i(),i(),i(),i()],J=d.create(),K=d.create(),Q=d.create(),Y=d.create();export{B as NativeLineMaterial};
