/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{isSome as e}from"../../../../core/maybe.js";import{clamp as t,sign as i}from"../../../../core/mathUtils.js";import{createRenderScreenPointArray3 as s}from"../../../../core/screenUtils.js";import{c as r,f as n}from"../../../../chunks/vec3f64.js";import{s as a,i as o,n as c,f as l,a as u,g as f,l as p,k as h,t as m,d,b as g}from"../../../../chunks/vec3.js";import{a as v}from"../../../../chunks/mat4.js";import{create as x}from"../../../../geometry/support/aaBoundingRect.js";import{a as b}from"../../../../chunks/mat3f64.js";import{a as S}from"../../../../chunks/mat4f64.js";import{a as P,f as q}from"../../../../chunks/vec2f64.js";import{f as O}from"../../../../chunks/mat3.js";import{c as y}from"../../../../chunks/vec2.js";import{newLayout as z}from"../../support/buffer/InterleavedLayout.js";import{assert as A}from"../lib/Util.js";import{computeAttachmentOriginPoints as C}from"../lib/geometryDataUtils.js";import{isInstanceHidden as T}from"./renderers/utils.js";import{applyScaleFactor as w,applyPrecomputedScaleFactor as j,precomputeScaleFactor as D}from"../lib/screenSizePerspectiveUtils.js";import{isMat4 as E}from"../../../../core/libs/gl-matrix-2/types/mat4.js";import M from"../lib/GLMaterialTexture.js";import{verticalOffsetAtDistance as V}from"./internal/MaterialUtil.js";import{Material as R,materialParametersDefaults as I}from"../lib/Material.js";import{writePosition as U,writeNormal as B,writeColor as G,writeBufferVec4 as k}from"./internal/bufferWriterUtils.js";import{c as H}from"../../../../chunks/HUDMaterial.glsl.js";import{HUDMaterialTechniqueConfiguration as F,HUDMaterialTechnique as W}from"../shaders/HUDMaterialTechnique.js";class L extends R{constructor(e){super(e,me),this.techniqueConfig=new F}getTechniqueConfig(e,t){return this.techniqueConfig.output=e,this.techniqueConfig.slicePlaneEnabled=this.params.slicePlaneEnabled,this.techniqueConfig.verticalOffset=!!this.params.verticalOffset,this.techniqueConfig.screenSizePerspective=!!this.params.screenSizePerspective,this.techniqueConfig.screenCenterOffsetUnitsEnabled="screen"===this.params.centerOffsetUnits?1:0,this.techniqueConfig.polygonOffsetEnabled=this.params.polygonOffset,this.techniqueConfig.isDraped=this.params.isDraped,this.techniqueConfig.occlusionTestEnabled=this.params.occlusionTest,this.techniqueConfig.pixelSnappingEnabled=this.params.pixelSnappingEnabled,this.techniqueConfig.sdf=this.params.textureIsSignedDistanceField,this.techniqueConfig.vvSize=!!this.params.vvSizeEnabled,this.techniqueConfig.vvColor=!!this.params.vvColorEnabled,0===e&&(this.techniqueConfig.debugDrawBorder=!!this.params.debugDrawBorder),4===e&&(this.techniqueConfig.binaryHighlightOcclusion=this.params.binaryHighlightOcclusion),this.techniqueConfig.depthEnabled=this.params.depthEnabled,this.techniqueConfig.transparencyPassType=t?t.transparencyPassType:3,this.techniqueConfig.multipassGeometryEnabled=!!t&&t.multipassGeometryEnabled,this.techniqueConfig}intersect(e,t,i,s,r,n,a,o,c){c?this.intersectDrapedHudGeometry(e,n,a,o):this.intersectHudGeometry(e,t,i,s,a,o)}intersectDrapedHudGeometry(t,i,s,r){const n=t.vertexAttributes.get("position"),a=t.vertexAttributes.get("size"),o=this.params,c=H(o);let l=1,u=1;if(e(r)){const e=r(le);l=e[0],u=e[5]}l*=t.screenToWorldRatio,u*=t.screenToWorldRatio;const f=fe*t.screenToWorldRatio;for(let e=0;e<n.data.length/n.size;e++){const r=e*n.size,p=n.data[r],h=n.data[r+1],m=e*a.size;let d;pe[0]=a.data[m]*l,pe[1]=a.data[m+1]*u,o.textureIsSignedDistanceField&&(d=o.outlineSize*t.screenToWorldRatio/2),Y(i,p,h,pe,f,d,o,c)&&s()}}intersectHudGeometry(t,i,s,n,m,d){if(!n.options.selectionMode||!n.options.hud)return;if(T(i))return;const g=this.params;let x=1,b=1;if(O(re,s),e(d)){const e=d(le);x=e[0],b=e[5],X(re)}const S=t.vertexAttributes.get("position"),P=t.vertexAttributes.get("size"),q=t.vertexAttributes.get("normal"),y=t.vertexAttributes.get("auxpos1");A(S.size>=3);const z=n.point,C=n.camera,D=H(g);x*=C.pixelRatio,b*=C.pixelRatio;const E="screen"===this.params.centerOffsetUnits;for(let e=0;e<S.data.length/S.size;e++){const t=e*S.size;a(_,S.data[t],S.data[t+1],S.data[t+2]),o(_,_,s);const i=e*P.size;pe[0]=P.data[i]*x,pe[1]=P.data[i+1]*b,o(_,_,C.viewMatrix);const d=e*y.size;if(a(oe,y.data[d+0],y.data[d+1],y.data[d+2]),!E&&(_[0]+=oe[0],_[1]+=oe[1],0!==oe[2])){const e=oe[2];c(oe,_),l(_,_,u(oe,oe,e))}const O=e*q.size;if(a(ee,q.data[O],q.data[O+1],q.data[O+2]),this.normalAndViewAngle(ee,re,C,ce),this.applyVerticalOffsetTransformationView(_,ce,C,Z),C.applyProjection(_,te),te[0]>-1){let e=Math.floor(te[0])+this.params.screenOffset[0],t=Math.floor(te[1])+this.params.screenOffset[1];E&&(e+=oe[0],0!==oe[1]&&(t+=w(oe[1],Z.factorAlignment))),j(pe,Z.factor,pe);const i=ue*C.pixelRatio;let s;if(g.textureIsSignedDistanceField&&(s=g.outlineSize*C.pixelRatio/2),Y(z,e,t,pe,i,s,g,D)){const e=n.ray;if(o(se,_,v(ae,C.viewMatrix)),te[0]=z[0],te[1]=z[1],C.unprojectFromRenderScreen(te,_)){const t=r();f(t,e.direction);const i=1/p(t);u(t,t,i);m(h(e.origin,_)*i,t,-1,1,!0,se)}}}}}computeAttachmentOrigin(e,t){const i=e.vertexAttributes;if(!i)return!1;const s=i.get("position"),r=e.indices.get("position");return C(s,r,t)}createBufferWriter(){return new ge(this)}normalAndViewAngle(e,t,i,s){return E(t)&&(t=O(ne,t)),m(s.normal,e,t),o(s.normal,s.normal,i.viewInverseTransposeMatrix),s.cosAngle=d(ie,he),s}updateScaleInfo(e,t,i){const s=this.params;s.screenSizePerspective?D(i,t,s.screenSizePerspective,e.factor):(e.factor.scale=1,e.factor.factor=0,e.factor.minPixelSize=0,e.factor.paddingPixels=0),s.screenSizePerspectiveAlignment?D(i,t,s.screenSizePerspectiveAlignment,e.factorAlignment):(e.factorAlignment.factor=e.factor.factor,e.factorAlignment.scale=e.factor.scale,e.factorAlignment.minPixelSize=e.factor.minPixelSize,e.factorAlignment.paddingPixels=e.factor.paddingPixels)}applyShaderOffsetsView(e,t,i,s,r,n,a){const o=this.normalAndViewAngle(t,i,r,ce);return this.applyVerticalGroundOffsetView(e,o,r,a),this.applyVerticalOffsetTransformationView(a,o,r,n),this.applyPolygonOffsetView(a,o,s[3],r,a),this.applyCenterOffsetView(a,s,a),a}applyShaderOffsetsNDC(t,i,s,r,n){return this.applyCenterOffsetNDC(t,i,s,r),e(n)&&f(n,r),this.applyPolygonOffsetNDC(r,i,s,r),r}applyPolygonOffsetView(e,s,r,n,a){const o=n.aboveGround?1:-1;let c=i(r);0===c&&(c=o);const l=o*c;if(this.params.shaderPolygonOffset<=0)return f(a,e);const p=t(Math.abs(s.cosAngle),.01,1),h=1-Math.sqrt(1-p*p)/p/n.viewport[2];return u(a,e,l>0?h:1/h),a}applyVerticalGroundOffsetView(e,t,i,s){const r=p(e),n=i.aboveGround?1:-1,a=.5*i.computeRenderPixelSizeAtDist(r),o=u(_,t.normal,n*a);return g(s,e,o),s}applyVerticalOffsetTransformationView(e,t,i,s){const r=this.params;if(!r.verticalOffset||!r.verticalOffset.screenLength){if(r.screenSizePerspective||r.screenSizePerspectiveAlignment){const i=p(e);this.updateScaleInfo(s,i,t.cosAngle)}else s.factor.scale=1,s.factorAlignment.scale=1;return e}const n=p(e),a=r.screenSizePerspectiveAlignment||r.screenSizePerspective,o=V(i,n,r.verticalOffset,t.cosAngle,a);return this.updateScaleInfo(s,n,t.cosAngle),u(t.normal,t.normal,o),g(e,e,t.normal)}applyCenterOffsetView(e,t,i){const s="screen"!==this.params.centerOffsetUnits;return i!==e&&f(i,e),s&&(i[0]+=t[0],i[1]+=t[1],t[2]&&(c(ee,i),g(i,i,u(ee,ee,t[2])))),i}applyCenterOffsetNDC(e,t,i,s){const r="screen"!==this.params.centerOffsetUnits;return s!==e&&f(s,e),r||(s[0]+=t[0]/i.fullWidth*2,s[1]+=t[1]/i.fullHeight*2),s}applyPolygonOffsetNDC(e,t,s,r){const n=this.params.shaderPolygonOffset;if(e!==r&&f(r,e),n){const e=s.aboveGround?1:-1,a=e*i(t[3]);r[2]-=(a||e)*n}return r}getGLMaterial(e){return 0===e.output||7===e.output?new J(e):4===e.output?new K(e):void 0}calculateRelativeScreenBounds(e,t,i=x()){return Q(this.params,e,t,i),i[2]=i[0]+e[0],i[3]=i[1]+e[1],i}}class N extends M{constructor(e){super({...e,...e.material.params}),this.updateParameters()}beginSlot(e){return e===(this.material.params.drawInSecondSlot?19:18)}updateParameters(e){this.updateTexture(this.material.params.textureId),this.selectProgram(e)}selectProgram(e){this.technique=this.techniqueRep.acquireAndReleaseExisting(W,this.material.getTechniqueConfig(this.output,e),this.technique)}ensureParameters(e){this.updateParameters(e)}bind(e,t){e.bindProgram(this.technique.program),this.bindTexture(e,this.technique.program),this.bindTextureScale(e,this.technique.program),this.technique.bindPass(e,this.material.params,t)}}class J extends N{constructor(e){super(e),this.isOcclusionSlot=!1}beginSlot(e){const t=this.material.params.drawInSecondSlot?19:18;return this.material.params.occlusionTest?(this.isOcclusionSlot=12===e,12===e||e===t):(this.isOcclusionSlot=!1,e===t)}getTechnique(){return this.isOcclusionSlot?this.occlusionTechnique:this.technique}selectProgram(e){this.technique=this.techniqueRep.acquireAndReleaseExisting(W,this.material.getTechniqueConfig(this.output,e),this.technique),this.occlusionTechnique=this.techniqueRep.acquireAndReleaseExisting(W,this.material.getTechniqueConfig(6,e),this.occlusionTechnique)}bind(e,t){const i=this.getTechnique();e.bindProgram(i.program),this.isOcclusionSlot||(this.bindTexture(e,i.program),this.bindTextureScale(e,i.program)),i.bindPass(e,this.material.params,t)}}class K extends N{constructor(e){super({...e,output:4})}}function Q(e,t,i,s=$){return y(s,e.anchorPos),s[0]*=-t[0],s[1]*=-t[1],s[0]+=e.screenOffset[0]*i,s[1]+=e.screenOffset[1]*i,s}function X(e){const t=e[0],i=e[1],s=e[2],r=e[3],n=e[4],a=e[5],o=e[6],c=e[7],l=e[8],u=1/Math.sqrt(t*t+i*i+s*s),f=1/Math.sqrt(r*r+n*n+a*a),p=1/Math.sqrt(o*o+c*c+l*l);return e[0]=t*u,e[1]=i*u,e[2]=s*u,e[3]=r*f,e[4]=n*f,e[5]=a*f,e[6]=o*p,e[7]=c*p,e[8]=l*p,e}function Y(e,t,i,s,r,n,a,o){let c=t-r-(o[0]>0?s[0]*o[0]:0),l=c+s[0]+2*r,u=i-r-(o[1]>0?s[1]*o[1]:0),f=u+s[1]+2*r;if(a.textureIsSignedDistanceField){const e=a.distanceFieldBoundingBox;c+=s[0]*e[0],u+=s[1]*e[1],l-=s[0]*(1-e[2]),f-=s[1]*(1-e[3]),c-=n,l+=n,u-=n,f+=n}return e[0]>c&&e[0]<l&&e[1]>u&&e[1]<f}const Z={factor:{scale:0,factor:0,minPixelSize:0,paddingPixels:0},factorAlignment:{scale:0,factor:0,minPixelSize:0,paddingPixels:0}},$=P(),_=r(),ee=r(),te=s(),ie=r(),se=r(),re=b(),ne=b(),ae=S(),oe=r(),ce={normal:ie,cosAngle:0},le=S(),ue=1,fe=2,pe=[0,0],he=n(0,0,1),me={texCoordScale:[1,1],occlusionTest:!0,binaryHighlightOcclusion:!0,drawInSecondSlot:!1,color:[1,1,1,1],outlineColor:[1,1,1,1],outlineSize:0,textureIsSignedDistanceField:!1,distanceFieldBoundingBox:null,vvSizeEnabled:!1,vvSizeMinSize:[1,1,1],vvSizeMaxSize:[100,100,100],vvSizeOffset:[0,0,0],vvSizeFactor:[1,1,1],vvColorEnabled:!1,vvColorValues:[0,0,0,0,0,0,0,0],vvColorColors:[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],screenOffset:[0,0],verticalOffset:null,screenSizePerspective:null,screenSizePerspectiveAlignment:null,slicePlaneEnabled:!1,anchorPos:q(.5,.5),shaderPolygonOffset:1e-5,polygonOffset:!1,textureId:null,centerOffsetUnits:"world",depthEnabled:!0,pixelSnappingEnabled:!0,debugDrawBorder:!1,isDraped:!1,...I},de=z().vec3f("position").vec3f("normal").vec2f("uv0").vec4u8("color").vec2f("size").vec4f("auxpos1").vec4f("auxpos2");class ge{constructor(e){this.material=e,this.vertexBufferLayout=de}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return 6*e.indices.get("position").length}write(e,t,i,s){U(t.indices.get("position"),t.vertexAttributes.get("position").data,e.transformation,i.position,s,6),B(t.indices.get("normal"),t.vertexAttributes.get("normal").data,e.invTranspTransformation,i.normal,s,6);{const e=t.vertexAttributes.get("uv0").data;let r,n,a,o;if(null==e||e.length<4){const e=this.material.params;r=0,n=0,a=e.texCoordScale[0],o=e.texCoordScale[1]}else r=e[0],n=e[1],a=e[2],o=e[3];a=Math.min(1.99999,a+1),o=Math.min(1.99999,o+1);const c=t.indices.get("position").length,l=i.uv0;let u=s;for(let t=0;t<c;++t)l.set(u,0,r),l.set(u,1,n),u+=1,l.set(u,0,a),l.set(u,1,n),u+=1,l.set(u,0,a),l.set(u,1,o),u+=1,l.set(u,0,a),l.set(u,1,o),u+=1,l.set(u,0,r),l.set(u,1,o),u+=1,l.set(u,0,r),l.set(u,1,n),u+=1}G(t.indices.get("color"),t.vertexAttributes.get("color").data,4,i.color,s,6);{const e=t.indices.get("size"),r=t.vertexAttributes.get("size").data,n=e.length,a=i.size;let o=s;for(let t=0;t<n;++t){const i=r[2*e[t]],s=r[2*e[t]+1];for(let e=0;e<6;++e)a.set(o,0,i),a.set(o,1,s),o+=1}}t.indices.get("auxpos1")&&t.vertexAttributes.get("auxpos1")&&k(t.indices.get("auxpos1"),t.vertexAttributes.get("auxpos1").data,i.auxpos1,s,6),t.indices.get("auxpos2")&&t.vertexAttributes.get("auxpos2")&&k(t.indices.get("auxpos2"),t.vertexAttributes.get("auxpos2").data,i.auxpos2,s,6)}}export{L as HUDMaterial};
