/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import e from"../../../../core/has.js";import{isInt16Array as t,isInt32Array as r}from"../../../../core/typedArrayUtil.js";import{isSome as o,isNone as n}from"../../../../core/maybe.js";import a from"../../../../core/Error.js";import{binaryIndexOf as s,flatten as i,splitIntoChunks as c}from"../../../../core/arrayUtils.js";import{eachAlways as l}from"../../../../core/promiseUtils.js";import u from"../../../../geometry/SpatialReference.js";import{canProject as f}from"../../../../geometry/support/webMercatorUtils.js";import p from"../../../../request.js";import{s as m,g as h,r as d,q as y,a as g,b,i as w}from"../../../../chunks/vec3.js";import{getSphericalPCPF as S,getReferenceEllipsoid as x}from"../../../../geometry/projectionEllipsoid.js";import{a as M}from"../../../../chunks/mat4.js";import{create as v,empty as j,expandPointInPlace as R,intersects as k}from"../../../../geometry/support/aaBoundingRect.js";import{projectBoundingSphere as q,projectBuffer as T,computeLinearTransformation as I,projectVectorToVector as z}from"../../../../geometry/projection.js";import A from"../../../../tasks/support/Query.js";import{a as F}from"../../../../chunks/mat4f64.js";import{a as C}from"../../../../chunks/vec4f64.js";import{a as B,m as G,c as U}from"../../../../chunks/quat.js";import{create as K}from"../../../../geometry/support/aaBoundingBox.js";import{createSolidEdgeMaterial as L,createMaterialFromEdges as W}from"../support/edgeUtils.js";import{Texture as E}from"../../webgl-engine/lib/Texture.js";import{parseColorMixMode as O}from"../support/symbolColorUtils.js";import{b as P}from"../../../../chunks/quatf32.js";import{corners as D,compute as N,create as _}from"../../support/orientedBoundingBox.js";import{readBinaryAttribute as $}from"./I3SBinaryReader.js";import{computeGlobalTransformation as V}from"./I3SProjectionUtil.js";function Q(e){return e&&parseInt(e.substring(e.lastIndexOf("/")+1,e.length),10)}function Z(t){const r=t._stage.renderView.has(1),o=t._stage.renderView.has(0),n=e("disable-feature:i3s-basis")?0:1;return 12|(r?2|n:0)|(o?n:0)}function H(e,t){return e.find((e=>0!=(e.encoding&t)))}function J(e){switch(e){case 1:return E.BASIS_ENCODING;case 2:return E.DDS_ENCODING;case 4:return"image/png";case 8:return"image/jpeg";case 16:return"image/ktx";default:return""}}function X(t){if(e("disable-feature:i3s-draco")||!t)return!1;for(const e of t)for(const t of e.geometryBuffers)if("draco"===t.compressedAttributes.encoding)return!0;return!1}function Y(e,t,r,o,n,a){n.traverse(r,(r=>{let n=r.mbs;t!==o&&(n=ne,q(r.mbs,o,n,t));const s=ae(e,n);return 0!==s&&(a(r,s),!0)}))}function ee(e,t,r){let o=0,n=0;for(let a=0;a<t.length&&o<e.length;a++)e[o]===t[a]&&(r(a)&&(e[n]=e[o],n++),o++);e.length=n}function te(e,t,r){let o=0,n=0;for(;o<r.length;){s(e,r[o])>=0===t&&(r[n]=r[o],n++),o++}r.length=n}const re=K();function oe(e,t){if(0===t.rotationScale[1]&&0===t.rotationScale[2]&&0===t.rotationScale[3]&&0===t.rotationScale[5]&&0===t.rotationScale[6]&&0===t.rotationScale[7])return re[0]=(e[0]-t.position[0])/t.rotationScale[0],re[1]=(e[1]-t.position[1])/t.rotationScale[4],re[2]=(e[2]-t.position[2])/t.rotationScale[8],re[3]=(e[3]-t.position[0])/t.rotationScale[0],re[4]=(e[4]-t.position[1])/t.rotationScale[4],re[5]=(e[5]-t.position[2])/t.rotationScale[8],re}const ne=C();function ae(e,t){const r=t[0],o=t[1],n=t[3],a=e[0]-r,s=r-e[2],i=e[1]-o,c=o-e[3],l=Math.max(a,s,0),u=Math.max(i,c,0),f=l*l+u*u;if(f>n*n)return 0;if(f>0)return 1;return-Math.max(a,s,i,c)>n?3:2}function se(e,t){const r=t[0],o=t[1],n=t[2],a=t[3],s=e[0]-r,i=r-e[3],c=e[1]-o,l=o-e[4],u=e[2]-n,f=n-e[5],p=Math.max(s,i,0),m=Math.max(c,l,0),h=Math.max(u,f,0),d=p*p+m*m+h*h;if(d>a*a)return 0;if(d>0)return 1;return-Math.max(s,i,c,l,u,f)>a?3:2}function ie(e,t,r){const o=[],n=r&&r.missingFields,a=r&&r.originalFields;for(const s of e){const e=s.toLowerCase();let r=!1;for(const n of t)if(e===n.name.toLowerCase()){o.push(n.name),r=!0,a&&a.push(s);break}!r&&n&&n.push(s)}return o}async function ce(e,t,r,s,c){if(0===t.length)return[];const l=e.attributeStorageInfo;if(o(e.associatedLayer))try{return await ue(e.associatedLayer,t,r,s)}catch(u){if(e.associatedLayer.loaded)throw u}if(l){const o=le(t,r,c);if(n(o))throw new a("scenelayer:features-not-loaded","Tried to query attributes for unloaded features");const u=e.parsedUrl.path,f=await Promise.all(o.map((e=>pe(u,l,e.node,e.indices,s).then((t=>{for(let r=0;r<e.graphics.length;r++){const o=e.graphics[r],n=t[r];if(o.attributes)for(const e in o.attributes)e in n||(n[e]=o.attributes[e]);o.attributes=n}return e.graphics})))));return i(f)}throw new a("scenelayer:no-attribute-source","This scene layer does not have a source for attributes available")}function le(e,t,r){const o=new Map,n=[],a=r();for(const s of e){const e=s.attributes[t];for(let t=0;t<a.length;t++){const r=a[t],i=r.featureIds.indexOf(e);if(i>=0){let e=o.get(r.node);e||(e={node:r.node,indices:[],graphics:[]},n.push(e),o.set(r.node,e)),e.indices.push(i),e.graphics.push(s);for(let r=t;r>0;r--)a[r]=a[r-1];a[0]=r;break}}}return n}async function ue(e,t,r,o){t.sort(((e,t)=>e.attributes[r]-t.attributes[r]));const n=t.map((e=>e.attributes[r])),a=[],s=ie(o,e.fields,{originalFields:a}),i=await fe(e,n,s);for(let c=0;c<t.length;c++){const e=t[c],r=i[c],o={};if(e.attributes)for(const t in e.attributes)o[t]=e.attributes[t];for(let t=0;t<a.length;t++)o[a[t]]=r[s[t]];e.attributes=o}return t}function fe(e,t,r){const o=e.capabilities.query.maxRecordCount;if(null!=o&&t.length>o){const n=c(t,o);return Promise.all(n.map((t=>fe(e,t,r)))).then(i)}const n=new A({objectIds:t,outFields:r,orderByFields:[e.objectIdField]});return e.queryFeatures(n).then((e=>{if(e&&e.features&&e.features.length===t.length)return e.features.map((e=>e.attributes));throw new a("scenelayer:feature-not-in-associated-layer","Feature not found in associated feature layer")}))}function pe(e,t,r,o,n){const a=[];for(const s of t)if(s&&-1!==n.indexOf(s.name)){const t=`${e}/nodes/${r.resources.attributes}/attributes/${s.key}/0`;a.push({url:t,storageInfo:s})}return l(a.map((e=>p(e.url,{responseType:"array-buffer"}).then((t=>$(e.storageInfo,t.data)))))).then((e=>{const t=[];for(const r of o){const o={};for(let t=0;t<e.length;t++)null!=e[t].value&&(o[a[t].storageInfo.name]=de(e[t].value,r));t.push(o)}return t}))}const me=-32768,he=-(2**31);function de(e,o){if(!e)return null;const n=e[o];if(t(e))return n===me?null:n;if(r(e))return n===he?null:n;return n!=n?null:n}function ye(e){const t=e.store.indexCRS||e.store.geographicCRS,r=void 0===t?e.store.indexWKT:void 0;if(r){if(!e.spatialReference)throw new a("layerview:no-store-spatial-reference-wkt-index-and-no-layer-spatial-reference","Found indeWKT in the scene layer store but no layer spatial reference",{});if(r!==e.spatialReference.wkt)throw new a("layerview:store-spatial-reference-wkt-index-incompatible","The indeWKT of the scene layer store does not match the WKT of the layer spatial reference",{})}const o=t?new u(Q(t)):e.spatialReference;return o.equals(e.spatialReference)?e.spatialReference:o}function ge(e){const t=e.store.vertexCRS||e.store.projectedCRS,r=void 0===t?e.store.vertexWKT:void 0;if(r){if(!e.spatialReference)throw new a("layerview:no-store-spatial-reference-wkt-vertex-and-no-layer-spatial-reference","Found vertexWKT in the scene layer store but no layer spatial reference",{});if(r!==e.spatialReference.wkt)throw new a("layerview:store-spatial-reference-wkt-vertex-incompatible","The vertexWKT of the scene layer store does not match the WKT of the layer spatial reference",{})}const o=t?new u(Q(t)):e.spatialReference;return o.equals(e.spatialReference)?e.spatialReference:o}function be(e,t){return n(t)?"@null":t===S(t)?"@ECEF":e.equals(t)?"":null!=t.wkid?"@"+t.wkid:null}function we(e,t,r){if(!f(e,t))throw new a("layerview:spatial-reference-incompatible","The spatial reference of this scene layer is incompatible with the spatial reference of the view",{});if("local"===r&&e.isGeographic)throw new a("layerview:local-gcs-not-supported","Geographic coordinate systems are not supported in local scenes",{})}function Se(e,t,r){const o=ye(e),n=ge(e);we(o,t,r),we(n,t,r)}function xe(e){return(null==e.geometryType||"triangles"===e.geometryType)&&((null==e.topology||"PerAttributeArray"===e.topology)&&(null!=e.vertexAttributes&&null!=e.vertexAttributes.position))}function Me(e){if(null==e.store||null==e.store.defaultGeometrySchema||!xe(e.store.defaultGeometrySchema))throw new a("scenelayer:unsupported-geometry-schema","The geometry schema of this scene layer is not supported.",{url:e.parsedUrl.path})}function ve(e,t){Se(e,t.spatialReference,t.viewingMode)}function je(e){return null!=e.geometryType&&"points"===e.geometryType&&((null==e.topology||"PerAttributeArray"===e.topology)&&((null==e.encoding||""===e.encoding||"lepcc-xyz"===e.encoding)&&(null!=e.vertexAttributes&&null!=e.vertexAttributes.position)))}function Re(e){if(null==e.store||null==e.store.defaultGeometrySchema||!je(e.store.defaultGeometrySchema))throw new a("pointcloud:unsupported-geometry-schema","The geometry schema of this point cloud scene layer is not supported.",{})}function ke(e,t){we(e.spatialReference,t.spatialReference,t.viewingMode)}function qe(e){return"simple"===e.type||"class-breaks"===e.type||"unique-value"===e.type}function Te(e){return"mesh-3d"===e.type}function Ie(e){if(null==e||!qe(e))return!0;if(("unique-value"===e.type||"class-breaks"===e.type)&&null==e.defaultSymbol)return!0;const t=e.getSymbols();if(0===t.length)return!0;for(const r of t){if(!Te(r)||0===r.symbolLayers.length)return!0;for(const e of r.symbolLayers.items)if("fill"!==e.type||n(e.material)||n(e.material.color)||"replace"!==e.material.colorMixMode)return!0}return!1}const ze=L({color:[0,0,0,0],opacity:0});class Ae{constructor(){this.edgeMaterial=null,this.material=null,this.castShadows=!0}}function Fe(e){const t=new Ae;let r=!1,n=!1;for(const a of e.symbolLayers.items)if("fill"===a.type&&a.enabled){const e=a.material,s=a.edges;if(o(e)&&!r){const n=e.color,s=O(e.colorMixMode);o(n)?t.material={color:[n.r/255,n.g/255,n.b/255],alpha:n.a,colorMixMode:s}:t.material={color:[1,1,1],alpha:1,colorMixMode:1},t.castShadows=a.castShadows,r=!0}o(s)&&!n&&(t.edgeMaterial=W(s,{}),n=!0)}return t.material||(t.material={color:[1,1,1],alpha:1,colorMixMode:1}),t}function Ce(e,t){return(0|e)+(0|t)|0}function Be(e,t,r,o,n=0){o===S(o)?t.isGeographic?Ue(e,r,t,n):Ge(e,r,t,n):e===r?(r.center[2]+=n,T(r.center,t,0,r.center,o,0,1)):(m(r.center,e.center[0],e.center[1],e.center[2]+n),T(r.center,t,0,r.center,o,0,1),B(r.quaternion,e.quaternion),h(r.halfSize,e.halfSize))}function Ge(e,t,r,o){D(e,Ee),m(t.center,e.center[0],e.center[1],e.center[2]+o),I(r,t.center,Le,S(r)),m(t.center,Le[12],Le[13],Le[14]);const n=2*Math.sqrt(1+Le[0]+Le[5]+Le[10]);We[0]=(Le[6]-Le[9])/n,We[1]=(Le[8]-Le[2])/n,We[2]=(Le[1]-Le[4])/n,We[3]=.25*n,G(t.quaternion,We,e.quaternion),U(We,t.quaternion);let a=0,s=0,i=0;for(const c of Ee)c[2]+=o,T(c,r,0,c,S(r),0,1),d(Ne,c,t.center),y(Ne,Ne,We),a=Math.max(a,Math.abs(Ne[0])),s=Math.max(s,Math.abs(Ne[1])),i=Math.max(i,Math.abs(Ne[2]));m(t.halfSize,a,s,i)}function Ue(e,t,r,o){const n=x(r),a=1+Math.max(0,o)/(n.radius+e.center[2]);m(t.center,e.center[0],e.center[1],e.center[2]+o),T(t.center,r,0,t.center,S(r),0,1),B(t.quaternion,e.quaternion),U(We,e.quaternion),m(Ne,0,0,1),y(Ne,Ne,We),m(Ne,e.halfSize[0]*Math.abs(Ne[0]),e.halfSize[1]*Math.abs(Ne[1]),e.halfSize[2]*Math.abs(Ne[2])),g(Ne,Ne,n.inverseFlattening),b(t.halfSize,e.halfSize,Ne),g(t.halfSize,t.halfSize,a)}function Ke(e,t,r,a,s,i){if(!i||0===i.length||n(t))return null;const c=V(e.mbs,s,r,t);let l;M($e,c);const u=()=>{if(!l)if(l=Ee,j(Pe),o(e.serviceObb)){Be(e.serviceObb,r,De,t,s),D(De,l);for(const e of l)w(e,e,$e),R(Pe,e)}else{const o=e.mbs,n=o[3];z(o,r,Ne,t),w(Ne,Ne,$e),Ne[2]+=s;for(let e=0;e<8;++e){const t=1&e?n:-n,r=2&e?n:-n,o=4&e?n:-n,a=l[e];h(a,[Ne[0]+t,Ne[1]+r,Ne[2]+o]),R(Pe,a)}}};let f=1/0,p=-1/0;const m=e=>{if("replace"!==e.type)return;const r=e.geometry;if(!r.hasZ)return;j(Oe);const o=r.spatialReference||a,n=r.rings.reduce(((e,r)=>r.reduce(((e,r)=>(z(r,o,Ne,t),w(Ne,Ne,$e),R(Oe,Ne),Math.min(Ne[2],e))),e)),1/0);u(),k(Pe,Oe)&&(f=Math.min(f,n),p=Math.max(p,n))};if(i.forEach((e=>m(e))),f===1/0)return null;const d=(e,t,r)=>{w(Ne,r,c),e[t+0]=Ne[0],e[t+1]=Ne[1],e[t+2]=Ne[2],t+=24,r[2]=f,w(Ne,r,c),e[t+0]=Ne[0],e[t+1]=Ne[1],e[t+2]=Ne[2],t+=24,r[2]=p,w(Ne,r,c),e[t+0]=Ne[0],e[t+1]=Ne[1],e[t+2]=Ne[2]};for(let o=0;o<8;++o)d(_e.data,3*o,l[o]);return N(_e)}const Le=F(),We=P(),Ee=[[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]],Oe=v(),Pe=v(),De=_(),Ne=[0,0,0],_e={data:new Array(72),size:3},$e=F();export{Ae as SymbolInfo,Ce as addWraparound,ke as checkPointCloudLayerCompatibleWithView,Re as checkPointCloudLayerValid,ve as checkSceneLayerCompatibleWithView,Me as checkSceneLayerValid,we as checkSpatialReference,Se as checkSpatialReferences,Ke as computeVisibilityObb,X as containsDraco,J as encodingToMimeType,Q as extractWkid,ee as filterInPlace,ie as findFieldsCaseInsensitive,Y as findIntersectingNodes,be as getCacheKeySuffix,de as getCachedAttributeValue,oe as getClipAABB,ye as getIndexCrs,Z as getSupportedEncodings,Fe as getSymbolInfo,ge as getVertexCrs,se as intersectBoundingBoxWithMbs,ae as intersectBoundingRectWithMbs,te as objectIdFilter,Ie as rendererNeedsTextures,H as selectEncoding,Be as transformObb,ze as transparentEdgeMaterial,ce as whenGraphicAttributes};
