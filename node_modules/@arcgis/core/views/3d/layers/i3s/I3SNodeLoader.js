/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import e from"../../../../core/has.js";import{clone as t}from"../../../../core/lang.js";import{isNone as r,isSome as i}from"../../../../core/maybe.js";import{makeAbsolute as o}from"../../../../core/urlUtils.js";import{eachAlways as n,isAbortError as s}from"../../../../core/promiseUtils.js";import{result as a,assertResult as u}from"../../../../core/asyncUtils.js";import{readBinaryAttribute as l,createGeometryDescriptor as f}from"./I3SBinaryReader.js";import{selectEncoding as d}from"./I3SUtil.js";import{getMaterialAndTextures as c,getMaterialAndTexturesFromShared as m}from"./I3SMaterialUtil.js";class h{constructor(e,t,r,i,o,n){if(this.streamDataController=t,this.logger=r,this.defaultGeometrySchema=i,this.requiredAttributes=o,this.options=n,this.logLayer=e,this.layerUrl=e.parsedUrl.path,this.geometryDefinitions=e.geometryDefinitions,e.materialDefinitions){const t=e.textureSetDefinitions;this.materialAndTextures=e.materialDefinitions.map((e=>c(t,e)))}}load(e,t,r){return this.streamDataController.request(e,t,{signal:r})}loadAttribute(e,t,r){const i=`${this.layerUrl}/nodes/${e.resources.attributes}/attributes/${t.key}/0`;return this.load(i,"binary",r).then((e=>l(t,e)))}loadAttributes(e,t,r){return n(t.map((t=>this.loadAttribute(e,t.attributeStorageInfo,r)))).then((r=>{const i={};for(let o=0;o<t.length;++o)if(r[o].value)i[t[o].name]=r[o].value;else{if(s(r[o].error))throw r[o].error;this.logger.error("#loadAttributes",this.logLayer,`Failed to load attributeData for '${t[o].name}' on node '${e.id}'`,r[o].error)}return i}))}async loadNodeData(e,t){const o=null!=this.requiredAttributes&&e.resources.attributes?a(this.loadAttributes(e,this.requiredAttributes,t)):null,{bufferDefinition:n,bufferIndex:s}=x(this.geometryDefinitions,e),l=!!e.resources.geometry,d=l?a(this.loadGeometry(e.resources.geometry,s,t)):null,c=e.resources.hasSharedResource?await this.loadShared(e,t):null,h=this.materialAndTextures&&e.resources.materialDefinition>=0?this.materialAndTextures[e.resources.materialDefinition]:null!=c?m(c):null,p=h&&h.material,A=h&&h.textures,$=`${e.id}`,j=!l&&this.options.loadFeatureData,T=j?await this.loadFeatureData($,t):null,w=j?y(T):g(p),I=r(w)&&b(T),U=null!=A&&A.length>0?a(this.loadTextures(e,A,t)):null;let S=null,q=null;if(d){S=u(await d);const e=D(this.defaultGeometrySchema,c);q=f(n,e)}const v=U?u(await U):null,P=o?u(await o):{},k=P?{attributeData:P,loadedAttributes:this.requiredAttributes}:null;return i(w)?{geometryData:w,attributeDataInfo:k,geometryBuffer:S,geometryDescriptor:q,requiredTextures:A,textureData:v}:i(I)?{pointData:I,attributeDataInfo:k,geometryBuffer:S,geometryDescriptor:q,requiredTextures:A,textureData:v}:Promise.reject()}static addAbsoluteHrefTexture(e,t){const r=e.textureDefinitions;if(null!=r)for(const i of Object.keys(r))for(const e of r[i].images)Array.isArray(e.href)?e.hrefConcat=e.href.map((e=>o(e,t))):e.hrefConcat=o(e.href,t)}static fixTextureEncodings(e){const t=e.textureDefinitions;if(null!=t)for(const r in t){const e=t[r];if(Array.isArray(e.encoding))for(let t=0;t<e.encoding.length;t++){const r=e.encoding[t];"data:"===r.substring(0,5)&&(e.encoding[t]=r.substring(5))}else{const t=e.encoding;"data:"===t.substring(0,5)&&(e.encoding=t.substring(5))}}}loadShared(e,t){const r=`${this.layerUrl}/nodes/${e.resources.geometry}/shared`;return this.load(r,"json",t).then((e=>(h.fixTextureEncodings(e),h.addAbsoluteHrefTexture(e,r),e)))}loadTexture(e,t,r,i,o,n){return 2===o||1===o?this.load(e,"binary",n).then((e=>({id:t,usage:r,data:e,encoding:o}))):this.load(e,"image",n).then((e=>{let n=e;const s=4096,a=2;if(i&&e.width*e.height>=s){const t=Math.ceil(e.width/a),r=Math.ceil(e.height/a),i=document.createElement("canvas");i.width=t,i.height=r;i.getContext("2d").drawImage(e,0,0,t,r),n=i}return{id:t,usage:r,data:n,encoding:o}}))}loadTextures(e,t,r){const i=this.options.uncompressedTextureDownsamplingEnabled,o=this.options.textureUsageMask;return Promise.all(t.map((t=>{if(0==(t.usage&o))return null;const n=d(t.encodings,this.options.textureEncodings);if(null==n)return this.logger.error("#loadTextures",this.logLayer,`No known encoding for texture found on node ${e.id}`),Promise.reject();const s=e.resources.texture||e.id,a=`${this.layerUrl}/nodes/${s}/textures/${n.name}`;return this.loadTexture(a,t.id,t.usage,i,n.encoding,r)})))}loadFeatureData(e,t){const r=`${this.layerUrl}/nodes/${e}/features/0`;return this.load(r,"json",t)}loadGeometry(e,t,r){const i=`${this.layerUrl}/nodes/${e}/geometries/${t}`;return this.load(i,"binary",r)}}function g(e){return{featureIds:[],geometries:[{type:"ArrayBufferView",params:{material:e}}],featureDataPosition:[0,0,0]}}function y(e){for(const t of e.featureData){const e=t.geometries;if(null!=e)for(const r of e)return{featureIds:[t.id],featureDataPosition:t.position,geometries:[r]}}return null}function b(e){const t=new Array;for(const r of e.featureData)null!=r.position&&t.push({featureIds:[r.id],featureDataPosition:r.position,geometries:null});return t}function D(e,r){if(!e||!r||!r.materialDefinitions)return e;const i=Object.keys(r.materialDefinitions)[0];return!r.materialDefinitions[i].params.vertexRegions&&e.vertexAttributes.region&&delete(e=t(e)).vertexAttributes.region,e}function x(t,r){const i={bufferDefinition:null,bufferIndex:0};if(null==t||r.resources.geometryDefinition<0)return i;const o=r.resources.geometryDefinition>=0?t[r.resources.geometryDefinition].geometryBuffers:null;if(null==o)return i;for(let n=0;n<o.length;n++){const t=o[n];if(null==t.compressedAttributes)i.bufferIndex=n,i.bufferDefinition=o[n];else if("draco"===t.compressedAttributes.encoding&&!e("disable-feature:i3s-draco"))return i.bufferIndex=n,i.bufferDefinition=t,i}return i}export default h;
