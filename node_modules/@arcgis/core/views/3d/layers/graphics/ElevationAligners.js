/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{isNone as t}from"../../../../core/maybe.js";import{c as e}from"../../../../chunks/vec3f64.js";import{s as a}from"../../../../chunks/vec3.js";import{c as o}from"../../../../chunks/mat4.js";import{projectBuffer as s,computeLinearTransformation as n}from"../../../../geometry/projection.js";import{a as r}from"../../../../chunks/mat4f64.js";import{SamplePosition as i}from"../../support/ElevationProvider.js";import l from"../../support/debugFlags.js";import{updateVertexAttributeAuxpos1w as c}from"./graphicUtils.js";import{evaluateElevationAlignmentAtPoint as m}from"./elevationAlignmentUtils.js";function f(t,e,a,o){const n=t.stageObject,r=a.spatialReference,c=n.geometryRecords,f=c.length,E="absolute-height"!==e.mode;let u=0;for(let p=0;p<f;p++){const t=c[p].geometry,f=c[p].getShaderTransformation();A[0]=f[12],A[1]=f[13],A[2]=f[14],t.invalidateBoundingInfo();const I=t.getMutableAttribute("position"),b=I.data,g=t.vertexAttributes.get("mapPos").data,R=I.size,_=b.length/R,D=new i(g,r);let v=0,L=!1,j=0;for(let n=0;n<_;n++){h[0]=b[v],h[1]=b[v+1],h[2]=b[v+2];const t=m(D,a,e,o,E?S:null);if(E&&(j+=S.sampledElevation),l.DISABLE_ELEVATION_ALIGNERS_ITERATIVE_UPDATES?(b[v]=D.array[D.offset],b[v+1]=D.array[D.offset+1],b[v+2]=t,s(b,r,v,b,o.spatialReference,v,1),b[v]-=A[0],b[v+1]-=A[1],b[v+2]-=A[2]):(d[0]=b[v]+A[0],d[1]=b[v+1]+A[1],d[2]=b[v+2]+A[2],o.setAltitude(t,d),b[v]=d[0]-A[0],b[v+1]=d[1]-A[1],b[v+2]=d[2]-A[2]),l.TESTS_DISABLE_UPDATE_THRESHOLDS)L=!0;else{const t=T/o.unitInMeters;(Math.abs(h[0]-b[v])>=t||Math.abs(h[1]-b[v+1])>=t||Math.abs(h[2]-b[v+2])>=t)&&(L=!0)}v+=R,D.offset+=3}u+=j/_,L&&n.geometryVertexAttrsUpdated(p)}return u/f}function E(t,e,s,r){const i=t.stageObject,f=e.centerPointInElevationSR;let E=0,p=0;if(i.metadata.usesVerticalDistanceToGround)E=m(f,s,e,r,S),c(i,S.verticalDistanceToGround),p=S.sampledElevation;else{const t="absolute-height"!==e.mode;E=m(f,s,e,r,t?S:null),t&&(p=S.sampledElevation)}const A=o(u,i.transformation),h=a(b,A[12],A[13],A[14]);l.DISABLE_ELEVATION_ALIGNERS_ITERATIVE_UPDATES?(d[0]=f.x,d[1]=f.y,d[2]=E,n(f.spatialReference,d,A,r.spatialReference)&&(i.transformation=A)):r.setAltitudeOfTransformation(E,A);const I=T/r.unitInMeters;return(Math.abs(A[12]-h[0])>=I||Math.abs(A[13]-h[1])>=I||Math.abs(A[14]-h[2])>=I)&&(i.transformation=A),p}const u=r();function p(e,o,s,r){const i=e.graphics3DSymbolLayer.lodRenderer;if(t(i))return 0;const c=o.centerPointInElevationSR;let f=0,E=0;const u="absolute-height"!==o.mode;f=m(c,s,o,r,u?S:null),u&&(E=S.sampledElevation);const p=i.instanceData,A=e.instanceIndex,h=I;p.getGlobalTransform(A,h);const g=a(b,h[12],h[13],h[14]);l.DISABLE_ELEVATION_ALIGNERS_ITERATIVE_UPDATES?(d[0]=c.x,d[1]=c.y,d[2]=f,n(c.spatialReference,d,h,r.spatialReference)&&p.setGlobalTransform(A,h)):r.setAltitudeOfTransformation(f,h);const R=T/r.unitInMeters;return(l.TESTS_DISABLE_UPDATE_THRESHOLDS||Math.abs(h[12]-g[0])>=R||Math.abs(h[13]-g[1])>=R||Math.abs(h[14]-g[2])>=R)&&p.setGlobalTransform(A,h),E}const T=.01,d=e(),A=e(),h=e(),I=r(),b=e(),S={verticalDistanceToGround:0,sampledElevation:0};export{p as perLodInstanceElevationAligner,E as perObjectElevationAligner,f as perVertexElevationAligner};
