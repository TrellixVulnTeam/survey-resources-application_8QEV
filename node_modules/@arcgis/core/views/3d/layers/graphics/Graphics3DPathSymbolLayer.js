/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{isSome as e,get as t}from"../../../../core/maybe.js";import i from"../../../../core/Error.js";import{sign as r,acosClamped as s,reciprocalClamped as a}from"../../../../core/mathUtils.js";import{d as o,c as n}from"../../../../chunks/vec3f64.js";import{s as l,b as h,d as c,c as p,a as m,n as d,p as f,f as u}from"../../../../chunks/vec3.js";import{projectBuffer as y}from"../../../../geometry/projection.js";import{f as g}from"../../../../chunks/vec2f64.js";import{s as _,a as b}from"../../../../chunks/vec2.js";import{create as v,empty as x,expandWithBuffer as w,intersectsClippingArea as S}from"../../../../geometry/support/aaBoundingBox.js";import{makeDehydratedPoint as D}from"../../../../layers/graphics/dehydratedFeatures.js";import{c as P}from"../../../../chunks/vec3f32.js";import{Object3D as R}from"../../webgl-engine/lib/Object3D.js";import{isValidSize as V}from"./graphicUtils.js";import{needsElevationUpdates3D as j,evaluateElevationAlignmentAtPoint as C}from"./elevationAlignmentUtils.js";import{ElevationContext as L}from"./ElevationContext.js";import A from"./Graphics3DObject3DGraphicLayer.js";import{Graphics3DSymbolLayer as z,getAttributeValue as E}from"./Graphics3DSymbolLayer.js";import{DefaultMaterial as U}from"../../webgl-engine/materials/DefaultMaterial.js";import{initFastSymbolUpdatesState as k,updateFastSymbolUpdatesState as F}from"../support/FastSymbolUpdates.js";import{s as G}from"../../../../chunks/mat2.js";import{PathGeometry as I,isPathGeometry as M}from"../../webgl-engine/lib/PathGeometry.js";import{Profile as O,SimpleExtruder as B,MiterExtruder as q,RoundCapBuilder as H,TriangulationCapBuilder as T,NoCapBuilder as N,Path as W,Builder as Z,FastUpdatePathGeometry as J,StaticPathGeometry as K,computeMinimumRotationTangentFrame as Q,vertexSpaceToProfileSpace as X,PathVertex as Y}from"../../webgl-engine/lib/pathGeometryUtils.js";import{PathMaterial as $}from"../../webgl-engine/materials/PathMaterial.js";const ee=["polyline"];class te extends z{constructor(e,t,i,r){super(e,t,i,r),this._intrinsicSize=g(1,1),this.upVectorAlignment="path",this.stencilWidth=.1,this.ensureDrapedStatus(!1)}async doLoad(){const r=e(this.symbolLayer.width)?this.symbolLayer.width:e(this.symbolLayer.height)?this.symbolLayer.height:this.symbolLayer.size,s=e(this.symbolLayer.height)?this.symbolLayer.height:r;this._vvConvertOptions={modelSize:[1,1,1],symbolSize:[r,1,s],unitInMeters:this._context.renderCoordsHelper.unitInMeters,transformation:{anchor:[0,0,0],scale:[1,1,1],rotation:[0,0,0]},supportedTypes:{size:!0,color:!0,opacity:!0,rotation:!1}},this._context.renderer&&this._context.renderer.visualVariables&&this._context.renderer.visualVariables.length>0?this._fastUpdates=k(this._context.renderer,this._vvConvertOptions):this._fastUpdates={enabled:!1};const a=this.symbolLayer.anchor||"center";this.upVectorAlignment="path","heading"===this.symbolLayer.profileRotation&&(this.upVectorAlignment="world");const n=this.symbolLayer.profile||"circle";switch(n){case"circle":default:this._profile=O.circle(me);break;case"quad":this._profile=O.rect()}let l=[0,0];"center"!==a&&(l={left:[.5,0],right:[-.5,0],top:[0,-.5],bottom:[0,.5]}[a],this._profile.translate(l[0],l[1]));switch(this.symbolLayer.join||"simple"){case"round":this._extruder=new q(0,ce);break;case"bevel":this._extruder=new q(0,1);break;case"miter":this._extruder=new q(.8*Math.PI,1);break;case"simple":default:this._extruder=new B}const h=this.symbolLayer.cap||"butt";switch(h){case"none":this._startCap=new N,this._endCap=new N;break;case"butt":default:this._startCap=new T(this._profile,0),this._endCap=new T(this._profile,0,!0);break;case"square":this._startCap=new T(this._profile,-.5),this._endCap=new T(this._profile,.5,!0);break;case"round":{const e="quad"===n;this._startCap=new H({profile:this._profile,flip:!1,breakNormals:e,subdivisions:pe}),this._endCap=new H({profile:this._profile,flip:!0,breakNormals:e,subdivisions:pe});break}}const c=t(this.symbolLayer,"material","color"),p=this._getCombinedOpacityAndColor(c),m=o(p),d=p[3],f={diffuse:m,ambient:m,opacity:d,transparent:d<1||this.needsDrivenTransparentPass,vertexColors:!1,slicePlaneEnabled:this._context.slicePlaneEnabled,castShadows:this.symbolLayer.castShadows,cullFace:"none"===h?0:void 0,offsetTransparentBackfaces:!0};if(!this._drivenProperties.size&&(_(this._intrinsicSize,r,s),!V(this._intrinsicSize[0])||!V(this._intrinsicSize[1])))throw new i("graphics3dpathsymbollayer:invalid-size","Symbol sizes may not be negative values");this._fastUpdates.enabled&&this._fastUpdates.visualVariables.size||b(this._intrinsicSize,this._intrinsicSize,1/this._context.renderCoordsHelper.unitInMeters),this._fastUpdates.enabled?(Object.assign(f,this._fastUpdates.materialParameters,{size:[this._intrinsicSize[0],this._intrinsicSize[1],0]}),this._material=new $(f)):(f.vertexColors=this._drivenProperties.color||this._drivenProperties.opacity,this._material=new U(f)),this._material.setParameterValues({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),this._context.stage.add(this._material)}destroy(){super.destroy(),this._context.stage.remove(this._material),this._material=null}createGraphics3DGraphic(e){const t=e.graphic;if(!this._validateGeometry(t.geometry,ee,this.symbolLayer.type))return null;const i=this.setGraphicElevationContext(t,new L),r=e.renderingInfo;return this._createAs3DShape(t,r,i,t.uid)}layerOpacityChanged(){const e=t(this.symbolLayer,"material","color"),i=this._getCombinedOpacity(e),r=i<1||this.needsDrivenTransparentPass;return this._material.setParameterValues({opacity:i,transparent:r}),!0}layerElevationInfoChanged(e,t){return this.updateGraphics3DGraphicElevationInfo(e,t,j)}slicePlaneEnabledChanged(){return this._material.setParameterValues({slicePlaneEnabled:this._context.slicePlaneEnabled}),!0}physicalBasedRenderingChanged(){return this._material.setParameterValues({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),!0}pixelRatioChanged(){return!0}applyRendererDiff(e,t){for(const i in e.diff)switch(i){case"visualVariables":if(!F(this._fastUpdates,t,this._vvConvertOptions))return!1;this._material.setParameterValues(this._fastUpdates.materialParameters);break;default:return!1}return!0}getVertexData(e){let t=0;const i=e.paths,r=[],s=e.spatialReference,a=this._context.elevationProvider.spatialReference,o=this._context.renderCoordsHelper.spatialReference;for(const m of i)t+=m.length;const n=new Float64Array(3*t),l=new Float64Array(3*t),h=new Float64Array(3*t);let c=0;for(const m of i){r.push({index:c,numVertices:m.length});for(const t of m)n[c++]=t[0],n[c++]=t[1],n[c++]=e.hasZ?t[2]:0}let p=!0;return s.equals(a)?this._copyVertices(n,0,l,0,t):p=y(n,s,0,l,a,0,t),a.equals(o)?this._copyVertices(l,0,h,0,t):y(l,a,0,h,o,0,t),{pathVertexDataInfos:r,vertexDataGS:n,vertexDataES:l,vertexDataRS:h,projectionSuccess:p,terrainElevation:0}}_copyVertices(e,t,i,r,s){t*=3,r*=3;for(let a=0;a<s;++a)i[r++]=e[t++],i[r++]=e[t++],i[r++]=e[t++]}_createAs3DShape(t,i,r,s){const a=t.geometry,o=new Array,n=new Array,h=new Array,c=a.spatialReference,p=v(),m=this._context.renderCoordsHelper,d=this.getVertexData(a);if(!d.projectionSuccess)return this.logger.warn("PathSymbol3DLayer geometry failed to be created (failed to project geometry to view spatial reference)"),null;if(d.pathVertexDataInfos.length>0){for(let s=0;s<d.pathVertexDataInfos.length;++s){const a=d.pathVertexDataInfos[s],f=a.index,u=a.numVertices;if(u<2){this.logger.warn("PathSymbol3DLayer geometry failed to be created (paths should contain at least 2 vertices)");continue}if(e(this._context.clippingExtent)&&(x(p),w(p,d.vertexDataES,3*f,u),!S(p,this._context.clippingExtent)))continue;const y=[];for(let e=f;e<f+3*u;){const t=e++,i=e++,s=e++,a=new Y;l(a.posGS,d.vertexDataGS[t],d.vertexDataGS[i],d.vertexDataGS[s]),l(a.posES,d.vertexDataES[t],d.vertexDataES[i],d.vertexDataES[s]);const o=C(a.posES,this._context.elevationProvider,r,m,null);l(ne,d.vertexDataRS[t],d.vertexDataRS[i],d.vertexDataRS[s]),m.setAltitude(o,ne),l(a.pos,ne[0],ne[1],ne[2]),y.push(a)}const g=new W(y);ie(g,this.upVectorAlignment,this._context.renderCoordsHelper);const _=new Z(g,this._profile,this._extruder,this._startCap,this._endCap);let b=null;if(this._fastUpdates.enabled){const e=this._fastUpdates.visualVariables,i=e.size?E(e.size.field,t):0,r=e.color?E(e.color.field,t):0,s=e.opacity?E(e.opacity.field,t):0;b=new J(_,i,r,s)}else{const e=[this._intrinsicSize[0],this._intrinsicSize[1]];this._drivenProperties.size&&(e[0]*=re(i.size[0],"symbol-value"===i.size[2]?this.symbolLayer.height||0:i.size[2],this.symbolLayer.width||0),e[1]*=re(i.size[2],"symbol-value"===i.size[0]?this.symbolLayer.width||0:i.size[0],this.symbolLayer.height||0));let t=null;this._drivenProperties.color&&(t=i.color),this._drivenProperties.opacity&&null!=i.opacity&&(t=t?[t[0],t[1],t[2],i.opacity]:[1,1,1,i.opacity]);const r=new K(_);r.bake(e),t&&r.bakeVertexColors(t),b=r}const{vertexAttributes:v,indices:D}=b.createGeometryData(),P=new I(v,D,b,c,this.upVectorAlignment,this.stencilWidth);o.push(P),n.push(this._material),h.push(b.xform)}if(o.length>0){const e={layerUid:this._context.layer.uid,graphicUid:s},t=new R({geometries:o,materials:n,transformations:h,metadata:e}),i=new A(this,t,o,null,null,ae,r);return i.alignedSampledElevation=d.terrainElevation,i.needsElevationUpdates=j(r.mode),i}}else this.logger.warn("PathSymbol3DLayer geometry failed to be created (no paths were defined)");return null}}function ie(e,t,i){switch(t){case"world":for(const t of e.vertices)h(le,t.pos,e.offset),i.worldUpAtPosition(le,ne),t.setFrameFromUpVector(ne),t.computeRotationAxisAndAngleFromUpVector();break;case"path":h(le,e.vertices[0].pos,e.offset),i.worldUpAtPosition(le,ne),Q(e,ne);for(const t of e.vertices){const e=r(c(t.frame.right,t.vRight));p(t.rotationFrame.up,t.vRight,t.vLeft),m(t.rotationFrame.up,t.rotationFrame.up,e),d(t.rotationFrame.up,t.rotationFrame.up);const i=c(t.rotationFrame.up,t.frame.up),o=c(t.rotationFrame.up,t.frame.right);if(m(le,t.frame.up,-o),m(he,t.frame.right,i),h(le,le,he),d(t.rotationFrame.right,le),X(t.rotationRight,t.frame,t.rotationFrame.right),f(le,t.vLeft),t.rotationAngle=-e*(Math.PI-s(c(le,t.vRight))),Math.abs(t.rotationAngle)>0){const e=a(Math.cos(.5*t.rotationAngle));G(t.miterStretch,1+(e-1)*t.rotationRight[0]*t.rotationRight[0],(e-1)*t.rotationRight[0]*t.rotationRight[1],(e-1)*t.rotationRight[0]*t.rotationRight[1],1+(e-1)*t.rotationRight[1]*t.rotationRight[1])}const n=Math.PI-t.rotationAngle;t.maxStretchDistance=Math.abs(Math.min(t.vLeftLength,t.vRightLength)*a(Math.cos(.5*n)))}}}function re(e,t,i){switch(e){case"symbol-value":return i;case"proportional":return t;default:return e}}function se(e,t,i,r){let s=0;for(const a of e.vertices){const o=C(a.posES,i,t,r,de);s+=de.sampledElevation,h(ne,a.pos,e.offset),r.setAltitude(o,ne),u(a.pos,ne,e.offset)}return e.updatePathVertexInformation(),s/e.vertices.length}function ae(e,t,i,r){const s=e.stageObject,a=s.geometryRecords,o=a.length;let n=0;oe.spatialReference=r.spatialReference;for(let l=0;l<o;l++){const e=a[l].geometry;if(!M(e))continue;const o=e.path,h=o.builder.path;e.geometrySR;n+=se(h,t,i,r),"world"!==e.upVectorAlignment&&ie(h,e.upVectorAlignment,r),o.onPathChanged(),e.invalidateBoundingInfo(),s.geometryVertexAttrsUpdated(l)}return n/o}const oe=D(0,0,0,null),ne=n(),le=P(),he=P(),ce=3,pe=3,me=10,de={verticalDistanceToGround:0,sampledElevation:0};export default te;export{te as Graphics3DPathSymbolLayer,me as NUM_CIRCLE_PROFILE_SUBDIVISIONS,pe as NUM_ROUND_CAP_EXTRUSION_SUBDIVISIONS,ce as NUM_ROUND_JOIN_SUBDIVISIONS};
