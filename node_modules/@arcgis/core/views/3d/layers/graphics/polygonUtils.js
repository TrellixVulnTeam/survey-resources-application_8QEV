/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{isSome as t}from"../../../../core/maybe.js";import i from"../../../../geometry/Extent.js";import o from"../../../../geometry/Polygon.js";import"../../../../geometry.js";import{projectBuffer as n}from"../../../../geometry/projection.js";import{pathsToTriangulationInfo as e}from"../../../../geometry/support/triangulationUtils.js";import{Geometry as s}from"../../webgl-engine/lib/Geometry.js";import{applyPerVertexElevationAlignment as a}from"./elevationAlignmentUtils.js";import{DRAPED_Z as r}from"../../terrain/OverlayRenderer.js";function p(i){const o=[["position",i.indices]],n=[["position",{size:3,data:i.attributeData.position,exclusive:!0}]];return t(i.attributeData.color)&&(n.push(["color",{size:4,data:i.attributeData.color,exclusive:!0}]),o.push(["color",new Uint32Array(i.indices.length)])),t(i.attributeData.uvMapSpace)&&(n.push(["uvMapSpace",{size:4,data:i.attributeData.uvMapSpace,exclusive:!0}]),o.push(["uvMapSpace",i.indices])),t(i.attributeData.boundingRect)&&(n.push(["boundingRect",{size:9,data:i.attributeData.boundingRect,exclusive:!0}]),o.push(["boundingRect",i.indices])),t(i.attributeData.mapPosition)&&(n.push(["mapPos",{size:3,data:i.attributeData.mapPosition,exclusive:!0}]),o.push(["mapPos",i.indices])),new s(n,o)}function u(i){const o=[["position",i.indices],["uv0",i.indices]],n=[["position",{size:3,data:i.attributeData.position,exclusive:!0}],["uv0",{size:2,data:i.attributeData.uv0,exclusive:!0}]];return t(i.attributeData.mapPosition)&&(n.push(["mapPos",{size:3,data:i.attributeData.mapPosition,exclusive:!0}]),o.push(["mapPos",i.indices])),new s(n,o)}function c(t){switch(t.type){case"extent":if(t instanceof i)return o.fromExtent(t);break;case"polygon":return t}return null}function l(t,i,o,n){const s=e(t.rings,t.hasZ,1),r=new Float64Array(s.position.length),p=a(s.position,t.spatialReference,0,r,0,s.position,0,s.position.length/3,i,o,n),u=null!=p;return{position:s.position,mapPosition:r,polygons:g(s.polygons,s.position,r),outlines:d(s.outlines,s.position,r),projectionSuccess:u,sampledElevation:p}}function m(t,i){const o=e(t.rings,!1,1),s=n(o.position,t.spatialReference,0,o.position,i,0,o.position.length/3);for(let n=2;n<o.position.length;n+=3)o.position[n]=r;return{position:o.position,polygons:g(o.polygons,o.position),outlines:d(o.outlines,o.position),projectionSuccess:s}}function d(t,i,o){const n=new Array;for(const{index:e,count:s}of t){if(s<=1)continue;const t=3*e,a=t+3*s;n.push({index:e,count:s,position:i.subarray(t,a),mapPosition:o?o.subarray(t,a):void 0})}return n}function g(t,i,o){const n=new Array;for(const{index:e,count:s,holeIndices:a,pathLengths:r}of t){if(s<=1)continue;const t=3*e,p=t+3*s,u=a.map((t=>t-e));n.push({index:e,count:s,holeIndices:u,pathLengths:r,position:i.subarray(t,p),mapPosition:o?o.subarray(t,p):void 0})}return n}export{p as createColorGeometry,u as createWaterGeometry,c as geometryAsPolygon,l as geometryToRenderInfo,m as geometryToRenderInfoDraped};
