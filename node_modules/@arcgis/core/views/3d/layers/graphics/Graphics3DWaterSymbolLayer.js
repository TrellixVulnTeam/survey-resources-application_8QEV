/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{isSome as e,isNone as t,unwrap as r}from"../../../../core/maybe.js";import o from"../../../../Color.js";import{t as i}from"../../../../chunks/common.js";import{getMetersPerUnitForSR as a}from"../../../../core/unitUtils.js";import{empty as n,expandPointInPlace as s,create as l}from"../../../../geometry/support/aaBoundingRect.js";import{I as u}from"../../../../chunks/mat4f64.js";import{f as c,a as m}from"../../../../chunks/vec2f64.js";import{earcut as h}from"../../../../core/libs/earcut/earcut.js";import{s as d}from"../../../../chunks/vec2.js";import{b as p,s as g}from"../../../../chunks/vec4.js";import{empty as y,expandWithBuffer as f,intersectsClippingArea as _,expandWithAABB as v,create as x}from"../../../../geometry/support/aaBoundingBox.js";import{Object3D as D}from"../../webgl-engine/lib/Object3D.js";import{elevationModeChangeUpdateType as b,SymbolUpdateType as C,needsElevationUpdates2D as E}from"./elevationAlignmentUtils.js";import{perVertexElevationAligner as w}from"./ElevationAligners.js";import{ElevationContext as G}from"./ElevationContext.js";import S from"./Graphics3DObject3DGraphicLayer.js";import{Graphics3DSymbolLayer as j}from"./Graphics3DSymbolLayer.js";import{geometryAsPolygon as T,geometryToRenderInfo as A,createWaterGeometry as P,geometryToRenderInfoDraped as U}from"./polygonUtils.js";import M from"./Graphics3DDrapedGraphicLayer.js";import{RenderGeometry as B}from"../../webgl-engine/lib/RenderGeometry.js";import{defaultWaterMaterialParameters as O,wavePresets as R}from"../../webgl-engine/materials/internal/waterMaterialUtils.js";import{WaterMaterial as L}from"../../webgl-engine/materials/WaterMaterial.js";const N=["polyline","polygon","extent"];class V extends j{constructor(e,t,r,o){super(e,t,r,o)}async doLoad(){}destroy(){super.destroy(),this._context.stage.remove(this._material),this._material=null}createGraphics3DGraphic(e){const t=e.graphic;if(!this._validateGeometry(t.geometry,N,this.symbolLayer.type))return null;const r=this.setGraphicElevationContext(t,new G);return this.ensureDrapedStatus("on-the-ground"===r.mode),this.ensureMaterial(),this.draped?this._createAsOverlay(t):this._createAs3DShape(t,r,t.uid)}ensureMaterial(){if(e(this._material))return;const t={...O},r=this.symbolLayer.color;e(r)&&(t.color=o.toUnitRGBA(r));const i=this._getCombinedOpacity(r,{hasIntrinsicColor:!0});t.color=[t.color[0],t.color[1],t.color[2],i],t.transparent=i<1||this.needsDrivenTransparentPass,t.waveDirection=e(this.symbolLayer.waveDirection)?V.headingVectorFromAngle(this.symbolLayer.waveDirection):c(0,0);const a=this.symbolLayer.waveStrength+"-"+this.symbolLayer.waterbodySize,n=R[a];t.waveStrength=n.waveStrength,t.waveTextureRepeat=n.textureRepeat,t.waveVelocity=n.waveVelocity,t.flowStrength=n.perturbationStrength,t.slicePlaneEnabled=this._context.slicePlaneEnabled,t.isDraped=this.draped,this._material=new L(t),this._context.stage.add(this._material)}layerOpacityChanged(){if(t(this._material))return!0;const e=this._material.params.color,r=this._getCombinedOpacity(this.symbolLayer.color,{hasIntrinsicColor:!0}),o=r<1||this.needsDrivenTransparentPass;return this._material.setParameterValues({color:[e[0],e[1],e[2],r],transparent:o}),!0}layerElevationInfoChanged(e,t,r){const o=this._elevationContext.mode,i=b(V.elevationModeChangeTypes,r,o);if(i!==C.UPDATE)return i;const a=E(o);return this.updateGraphics3DGraphicElevationInfo(e,t,(()=>a))}slicePlaneEnabledChanged(){return e(this._material)&&this._material.setParameterValues({slicePlaneEnabled:this._context.slicePlaneEnabled}),!0}physicalBasedRenderingChanged(){return!0}pixelRatioChanged(){return!0}_createAs3DShape(e,r,o){const i=T(e.geometry);if(t(i))return null;k.renderData=A(i,this._context.elevationProvider,this._context.renderCoordsHelper,r);const a=k.renderData.position.length/3;if(k.uvCoords=new Float64Array(2*a),k.outNum=0,k.outGeometries=[],k.outTransforms=[],k.outMaterials=[],this._create3DShapeGeometries(k),this._logGeometryCreationWarnings(k.renderData,i.rings,"rings","WaterSymbol3DLayer"),0===k.outNum)return null;this._createUVCoordsFromVertices(k.uvCoords,k.renderData.mapPosition,a,this._context.elevationProvider.spatialReference);const n=new D({geometries:k.outGeometries,materials:k.outMaterials,transformations:k.outTransforms,castShadow:!1,metadata:{layerUid:this._context.layer.uid,graphicUid:o}}),s=w,l=new S(this,n,k.outGeometries,null,null,s,r);return l.alignedSampledElevation=k.renderData.sampledElevation,l.needsElevationUpdates=E(r.mode),l}_createUVCoordsFromVertices(e,t,r,o){const i=a(o);n(I);for(let a=0;a<r;a++)d(W,t[3*a+0],t[3*a+1]),s(I,W);p(I,I,i);const l=I[0]%V.unitSizeOfTexture,u=I[1]%V.unitSizeOfTexture;F[0]=I[0]-l,F[1]=I[1]-u;for(let a=0;a<r;a++)e[2*a+0]=(t[3*a+0]*i-F[0])/V.unitSizeOfTexture,e[2*a+1]=(t[3*a+1]*i-F[1])/V.unitSizeOfTexture}_create3DShapeGeometries(t){const o=t.renderData.polygons,i=t.uvCoords;for(const{count:a,index:n,position:s,mapPosition:l,holeIndices:c}of o){if(e(this._context.clippingExtent)&&(y(z),f(z,l),!_(z,this._context.clippingExtent)))continue;const o=h(l,c,3);if(0===o.length)continue;const m=new Uint32Array(o),d=new Float64Array(i.buffer,2*n*i.BYTES_PER_ELEMENT,2*a),p=P({indices:m,attributeData:{position:s,uv0:d,mapPosition:l}});t.outGeometries.push(p),t.outMaterials.push(r(this._material)),t.outTransforms.push(u),t.outNum++}}_createAsOverlay(e){const o=T(e.geometry);if(t(o))return null;r(this._material).renderPriority=this._renderPriority,Y.renderData=U(o,this._context.overlaySR);const i=Y.renderData.position.length/3;return Y.uvCoords=new Float64Array(2*i),Y.outNum=0,Y.outGeometries=[],Y.outBoundingBox=y(),Y.layerUid=this._context.layer.uid,Y.graphicsUid=e.uid,this._createAsOverlayWater(Y),this._logGeometryCreationWarnings(Y.renderData,o.rings,"rings","WaterSymbol3DLayer"),0===Y.outNum?null:(this._createUVCoordsFromVertices(Y.uvCoords,Y.renderData.position,i,this._context.overlaySR),Y.outNum>0?new M(this,Y.outGeometries,Y.outBoundingBox):null)}_createAsOverlayWater(e){const t=e.uvCoords,o=e.renderData.polygons;for(const{position:i,holeIndices:a,index:n,count:s}of o){if(y(z),f(z,i),!_(z,this._context.clippingExtent))continue;v(e.outBoundingBox,z);const o=h(i,a,3);if(0===o.length)continue;const l=new Uint32Array(o),u=new Float64Array(t.buffer,2*n*t.BYTES_PER_ELEMENT,2*s),c=P({indices:l,attributeData:{position:i,uv0:u}}),m=new B(c,r(this._material),e.layerUid,e.graphicsUid),d=z;g(m.boundingSphere,.5*(d[0]+d[3]),.5*(d[1]+d[4]),0,.5*Math.sqrt((d[3]-d[0])*(d[3]-d[0])+(d[4]-d[1])*(d[4]-d[1]))),e.outGeometries.push(m),e.outNum++}}static headingVectorFromAngle(e){const t=m(),r=i(e);return t[0]=Math.sin(r),t[1]=Math.cos(r),t}get test(){return{create3DShape:e=>this._createAs3DShape(e.graphic,e.elevationContext,e.graphicUid),ensureMaterial:()=>this.ensureMaterial()}}}V.unitSizeOfTexture=100,V.elevationModeChangeTypes={definedChanged:C.RECREATE,staysOnTheGround:C.NONE,onTheGroundChanged:C.RECREATE};const F=m(),I=l(),W=m(),z=x(),k={renderData:null,uvCoords:null,outNum:0,outBoundingBox:null,outGeometries:null,outMaterials:null,outTransforms:null},Y={renderData:null,uvCoords:null,outNum:0,outBoundingBox:null,outGeometries:null,outMaterials:null,outTransforms:null};export default V;export{V as Graphics3DWaterSymbolLayer};
