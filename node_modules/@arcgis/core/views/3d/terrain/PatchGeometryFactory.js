/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{isSome as t}from"../../../core/maybe.js";import{lerp as e}from"../../../core/mathUtils.js";import{c as n}from"../../../chunks/vec3f64.js";import{s as r}from"../../../chunks/vec3.js";import{a as o}from"../../../chunks/vec4f64.js";import{s}from"../../../chunks/vec4.js";import{empty as i}from"../../../geometry/support/aaBoundingBox.js";import{MAX_PATCH_TESSELATION as u,GEOMETRY_VERTEX_STRIDE as c}from"./TerrainConst.js";import{newLayout as f}from"../support/buffer/InterleavedLayout.js";import{computeNormal as a}from"../webgl-engine/materials/internal/MaterialUtil.js";import{ElevationData as m}from"./ElevationData.js";import{BufferPool as l}from"../support/buffer/BufferPool.js";const p=f().vec3f("position").vec2f("uv0"),g=new l((t=>p.createBuffer(t)),(t=>t.count));class h{constructor(){this.indices=null,this.vertexAttributes=null,this.boundingBox=i(),this.numSurfaceIndices=0,this.numSkirtIndices=0,this.numWithoutSkirtIndices=0,this.numVertsPerRow=0,this.skirtLength=0,this.uvOffsetAndScale=o()}}class d{constructor(t,e,n){this.values=t,this.numSurfaceIndices=e,this.numSkirtIndices=n}}function y(){g.clear(),V.clear()}function w(t){g.release(t.vertexAttributes),t.vertexAttributes=null,t.indices=null}const I=65536;function v(t,n,r,o,u,f,a,l){const p=u[0],h=u[1],d=u[2],y=u[3],w=.1*a.radius*(y-h),I=t.numVertsPerRow-1,v=t.numVertsPerRow-1,P=t.numVertsPerRow*t.numVertsPerRow,V=2*I+2*v,A=g.acquire(P+V),M=A.position.typedBuffer,j=A.uv0.typedBuffer,O=o.geometryInfo.boundingBox;i(O);const T=n[2]-n[0],U=n[3]-n[1],q=d-p,E=r[0],N=r[1],W=r[2];for(let e=0;e<=I;e++){const t=e/I,r=p+t*q;k[e]=Math.sin(r),B[e]=Math.cos(r),D[e]=t,L[e]=n[0]+t*T}const C=f&&!!(1&l),z=f&&!!(2&l);let F=0;for(let s=0;s<=v;s++){let r=s/v;const o=e(h,y,r),i=Math.cos(o),u=Math.sin(o);let l;f?(l=a.halfSemiMajorAxis*Math.log((1+u)/(1-u)),r=(l-n[1])/U):l=180*o/Math.PI;for(let e=0;e<=I;e++){const n=D[e],o=k[e],f=B[e];let p=a.radius;t.samplerData&&(p+=m.sample(L[e],l,t.samplerData)||0);const g=f*i*p-E,h=o*i*p-N,d=u*p-W;S(g,h,d,O);const y=c*F;M[y+0]=g,M[y+1]=h,M[y+2]=d,j[y+0]=n,j[y+1]=r;const V=b(e,s,I,v);if(V>-1){const t=c*(P+V),e=C&&0===s?-1:z&&s===v?1:0,o=0===e?g:-E,i=0===e?h:-N,u=0===e?d:a.radius*e-W;M[t+0]=o,M[t+1]=i,M[t+2]=u,j[t+0]=0===e?R(n,r):n,j[t+1]=0===e?w:r,0!==e&&S(o,i,u,O)}++F}}o.geometryInfo.numVertsPerRow=t.numVertsPerRow,o.geometryInfo.vertexAttributes=A,o.geometryInfo.skirtLength=w,s(o.geometryInfo.uvOffsetAndScale,0,0,1,1),x(o.geometryInfo,t.numVertsPerRow,f?l:0,t.wireframe)}function P(e,n,r,o){const u=n[0],f=n[1],a=n[2]-u,l=n[3]-f,p=e.clippingArea,h=t(p)?Math.max(0,(p[0]-n[0])/a):0,d=t(p)?Math.max(0,(p[1]-n[1])/l):0,y=t(p)?Math.min(1,(p[2]-n[0])/a):1,w=t(p)?Math.min(1,(p[3]-n[1])/l):1,I=y>h?1/(y-h):1,v=w>d?1/(w-d):1,P=-h*I,V=-d*v,A=.1*a,M=e.numVertsPerRow-1,j=e.numVertsPerRow-1,k=e.numVertsPerRow*e.numVertsPerRow,B=2*M+2*j,D=g.acquire(k+B),L=D.position.typedBuffer,O=D.uv0.typedBuffer,T=o.geometryInfo.boundingBox;i(T);let U=0;for(let s=0;s<=j;s++){const n=s/j;let o=V+n*v,i=f+n*l;t(p)&&(i<p[1]?(i=p[1],o=0):i>p[3]&&(i=p[3],o=1));for(let f=0;f<=M;f++){const n=f/M;let l=P+n*I,g=u+n*a;t(p)&&(g<p[0]?(g=p[0],l=0):g>p[2]&&(g=p[2],l=1));const h=e.samplerData&&m.sample(g,i,e.samplerData)||0,d=g-r[0],y=i-r[1],w=h-r[2];S(d,y,w,T);const v=c*U;L[v+0]=d,L[v+1]=y,L[v+2]=w,O[v+0]=l,O[v+1]=o;const V=b(f,s,M,M);if(V>-1){const t=c*(k+V);L[t+0]=d,L[t+1]=y,L[t+2]=w,O[t+0]=R(l,o),O[t+1]=A}++U}}o.geometryInfo.numVertsPerRow=e.numVertsPerRow,o.geometryInfo.vertexAttributes=D,o.geometryInfo.skirtLength=A,s(o.geometryInfo.uvOffsetAndScale,h,d,y-h,w-d),x(o.geometryInfo,e.numVertsPerRow,0,e.wireframe)}const V=new Map;function x(t,e,n,r){const o=(2&n)>0,s=e+(r?1024:0)+(o?2048:0);let i=V.get(s);i||(i=A(e,o,r),V.set(s,i)),t.indices=i.values,t.numSurfaceIndices=i.numSurfaceIndices,t.numSkirtIndices=i.numSkirtIndices,t.numWithoutSkirtIndices=t.numSurfaceIndices+(n?6*(e-1)*(r?2:1):0)}function A(t,e,n){const r=t-1,o=t-1,s=t*t,i=2*r+2*o;let u=r*o*2*3,c=6*i,f=6*(2*r+o-1);n&&(u*=2,c*=2,f*=2);const a=s+i>I?new Uint32Array(u+c):new Uint16Array(u+c);let m,l,p,g,h=0,y=0,w=u,v=0;for(let d=0;d<=o;d++){e&&(v=0===d?f:d===o?-f:0),w+=v;for(let t=0;t<=r;t++){const e=b(t,d,r,o);if(e>-1){const i=M(t,d,r,o);0!==i&&(m=h,l=s+e,p=s+(0===t&&1===d?0:e+1),g=h+i,n?(a[w+0]=m,a[w+1]=l,a[w+2]=l,a[w+3]=p,a[w+4]=p,a[w+5]=m,a[w+6]=p,a[w+7]=g,a[w+8]=g,a[w+9]=m,a[w+10]=m,a[w+11]=p,w+=12):(a[w+0]=m,a[w+1]=l,a[w+2]=p,a[w+3]=p,a[w+4]=g,a[w+5]=m,w+=6))}++h,t<r&&d<o&&(m=d*(r+1)+t,l=m+1,p=l+(r+1),g=p-1,n?(a[y+0]=m,a[y+1]=l,a[y+2]=l,a[y+3]=p,a[y+4]=p,a[y+5]=m,a[y+6]=p,a[y+7]=g,a[y+8]=g,a[y+9]=m,a[y+10]=m,a[y+11]=p,y+=12):(a[y+0]=m,a[y+1]=l,a[y+2]=p,a[y+3]=p,a[y+4]=g,a[y+5]=m,y+=6))}w-=v}return new d(a,u,c)}function S(t,e,n,r){t<r[0]&&(r[0]=t),t>r[3]&&(r[3]=t),e<r[1]&&(r[1]=e),e>r[4]&&(r[4]=e),n<r[2]&&(r[2]=n),n>r[5]&&(r[5]=n)}function R(t,e){const n=e>t?1:0;return 2+4*n+(1-2*n)*(t+e)}function b(t,e,n,r){return 0===e?t:t===n?n+e:e===r?n+r+(n-t):0===t&&e>0?2*n+r+(r-e):-1}function M(t,e,n,r){return 0===e&&t!==n?1:t===n&&e!==r?n+1:e===r&&0!==t?-1:0===t&&0!==e?-(n+1):0}function j(e,n,o,s,i,u,c,f,m){const l=u.position,p=u.uv0,g=e[0],h=e[1],d=e[2],y=n[0]-g,w=n[1]-h,I=n[2]-d;s*=3;for(let v=o*=3;v<s;v+=3){const e=i[v],n=i[v+1],o=i[v+2];let s=l.get(e,0),u=l.get(e,1),P=l.get(e,2),V=l.get(n,0),x=l.get(n,1),A=l.get(n,2),S=l.get(o,0),R=l.get(o,1),b=l.get(o,2);p.get(e,0)>=2&&(r(O,s,u,P),c(O),s+=O[0],u+=O[1],P+=O[2]);p.get(n,0)>=2&&(r(O,V,x,A),c(O),V+=O[0],x+=O[1],A+=O[2]);p.get(o,0)>=2&&(r(O,S,R,b),c(O),S+=O[0],R+=O[1],b+=O[2]),t(f)&&([s,u,P]=f.applyToVertex(s,u,P),[V,x,A]=f.applyToVertex(V,x,A),[S,R,b]=f.applyToVertex(S,R,b));const M=V-s,j=x-u,k=A-P,B=S-s,D=R-u,L=b-P,U=w*L-D*I,q=I*B-L*y,E=y*D-B*w,N=M*U+j*q+k*E;if(Math.abs(N)<=Number.EPSILON)continue;const W=g-s,C=h-u,z=d-P,F=W*U+C*q+z*E;if(N>0){if(F<0||F>N)continue}else if(F>0||F<N)continue;const G=C*k-j*z,H=z*M-k*W,J=W*j-M*C,K=y*G+w*H+I*J;if(N>0){if(K<0||F+K>N)continue}else if(K>0||F+K<N)continue;const Q=(B*G+D*H+L*J)/N;if(Q>=0){m(Q,a(M,j,k,B,D,L,T))}}}const k=new Array(u+1),B=new Array(u+1),D=new Array(u+1),L=new Array(u+1),O=n(),T=n();export{h as PatchGeometry,y as clearCaches,P as createPlanarGlobePatch,v as createSphericalGlobePatch,j as intersectSkirts,w as releaseGeometry};
