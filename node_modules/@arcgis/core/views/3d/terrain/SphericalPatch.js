/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{lerp as i}from"../../../core/mathUtils.js";import{c as t,d as s}from"../../../chunks/vec3f64.js";import{n as e,s as r,h as o}from"../../../chunks/vec3.js";import{getReferenceEllipsoid as h}from"../../../geometry/projectionEllipsoid.js";import{lonLatToSphericalPCPF as a}from"../../../geometry/projection.js";import{a as n,r as l,c as d}from"../../../chunks/plane.js";import{i as c}from"../../../chunks/frustum.js";import{createSphericalGlobePatch as u}from"./PatchGeometryFactory.js";import p from"./Tile.js";class m extends p{constructor(i,s,e){super(f),this.obb=new Array(8),this.isWebMercator=!1;for(let r=0;r<8;r++)this.obb[r]=t();void 0!==i&&this.init(i,s,e)}init(t,r,o){super.init(t,r,o),this.isWebMercator=o.tilingScheme.spatialReference.isWebMercator;const h=this.ellipsoid.radius,n=this.extentInRadians[0],l=this.extentInRadians[1],d=this.extentInRadians[2],c=this.extentInRadians[3],u=t[0],p=i(l,c,.5),m=i(n,d,.5),f=0===u?0:Math.min(Math.abs(l),Math.abs(c));this._edgeLen=(d-n)*Math.cos(f)*h,this._edgeLen2=this._edgeLen*this._edgeLen,this._curvatureHeight=h-Math.sqrt(h*h-this._edgeLen2/4),a(this.centerAtSeaLevel,m,p,this.ellipsoid.radius,0);const _=s(this.centerAtSeaLevel);e(_,_),this.up=_,this._updateOBB(),this.updateRadiusAndCenter()}updateRadiusAndCenter(){if(0===this.lij[0])r(this._center[1],0,0,0),r(this._center[0],0,0,0),r(this._center[2],0,0,0),this.ellipsoid||(this.ellipsoid=h(this.surface.tilingScheme.spatialReference)),this._center[1][3]=this.ellipsoid.radius+this.elevationBounds[1];else{this._updateCenter();const i=Math.max(o(this._center[1],this.obb[0]),o(this._center[1],this.obb[1]));this._center[1][3]=Math.sqrt(i)}}_isVisible(i){if(!this.intersectsClippingArea)return!1;if(this.lij[0]<10)return c(i,this._center[1]);const t=this.obb;for(let s=0;s<6;s++){let e,r=i[s];for(4===s&&(r=n(r,_),_[3]-=this.surface.view.state.camera.near),e=0;e<8&&!l(r,t[e]);e++);if(8===e)return!1}return!0}computeElevationBounds(){super.computeElevationBounds(),this._updateOBB()}createGeometry(i,t){const s=this._isPole(this.lij[1],this.lij[0]);u(i,this.extent,t,this.renderData,this.extentInRadians,this.isWebMercator,this.ellipsoid,s),this.setMemoryDirty()}_updateOBB(){const i=this.extentInRadians,t=this.obb;for(let s=0;s<2;s++){const e=this.elevationBounds[s];let r=4*s;a(t[r++],i[0],i[1],this.ellipsoid.radius,e),a(t[r++],i[0],i[3],this.ellipsoid.radius,e),a(t[r++],i[2],i[3],this.ellipsoid.radius,e),a(t[r++],i[2],i[1],this.ellipsoid.radius,e)}if(this.isWebMercator){const i=this._isPole(this.lij[1],this.lij[0]);2===i?(r(t[1],0,0,this.ellipsoid.radius),r(t[2],0,0,this.ellipsoid.radius),r(t[5],0,0,this.ellipsoid.radius),r(t[6],0,0,this.ellipsoid.radius)):1===i&&(r(t[0],0,0,-this.ellipsoid.radius),r(t[3],0,0,-this.ellipsoid.radius),r(t[4],0,0,-this.ellipsoid.radius),r(t[7],0,0,-this.ellipsoid.radius))}}_isPole(i,t){let s=0;return i===(1<<t)-1&&(s+=1),0===i&&(s+=2),s}}const f=[128,64,32,16,16,8,8,4],_=d();export{m as SphericalPatch};
