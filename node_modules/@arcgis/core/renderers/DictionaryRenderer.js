/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{_ as e}from"../chunks/tslib.es6.js";import"../core/has.js";import{clone as s}from"../core/lang.js";import{isSome as t}from"../core/maybe.js";import{numericHash as r}from"../core/string.js";import i from"../core/Logger.js";import"../core/accessorSupport/ensureType.js";import{property as o}from"../core/accessorSupport/decorators/property.js";import{subclass as n}from"../core/accessorSupport/decorators/subclass.js";import{writer as a}from"../core/accessorSupport/decorators/writer.js";import l from"../core/Error.js";import"../core/urlUtils.js";import"../core/uuid.js";import"../portal/support/resourceExtension.js";import{isAbortError as c}from"../core/promiseUtils.js";import{loadArcade as p,createDictionaryExpression as m}from"../support/arcadeOnDemand.js";import{collectArcadeFieldNames as u}from"../layers/support/fieldUtils.js";import f from"../Color.js";import h from"../symbols/CIMSymbol.js";import y from"../request.js";import d from"./Renderer.js";import{VisualVariablesMixin as g}from"./mixins/VisualVariablesMixin.js";import b from"../core/LRUCache.js";var j;const _=i.getLogger("esri.renderers.DictionaryRenderer"),w={type:"CIMSimpleLineCallout",lineSymbol:{type:"CIMLineSymbol",symbolLayers:[{type:"CIMSolidStroke",width:.5,color:[0,0,0,255]}]}};let S=j=class extends(g(d)){constructor(e){super(e),this._ongoingRequests=new Map,this._symbolCache=new b(100),this.config=null,this.fieldMap=null,this.scaleExpression=null,this.scaleExpressionTitle=null,this.url=null,this.type="dictionary"}writeData(e,s){e&&(s.scalingExpressionInfo={expression:e,returnType:"number"})}writeVisualVariables(e,s,t,r){null!=r&&r.origin||super.writeVisualVariables(e,s,t,r)}clone(){return new j({config:s(this.config),scaleExpression:this.scaleExpression,scaleExpressionTitle:this.scaleExpressionTitle,fieldMap:s(this.fieldMap),url:s(this.url),visualVariables:s(this.visualVariables)})}async getSymbolAsync(e,s){let i;this._dictionaryPromise||(this._dictionaryPromise=this.fetchResources(s));try{i=await this._dictionaryPromise}catch(d){if(c(d))return this._dictionaryPromise=null,null}const o={};if(this.fieldMap)for(const t of this._symbolFields){const s=this.fieldMap[t];if(s&&null!==e.attributes[s]&&void 0!==e.attributes[s]){const r=""+e.attributes[s];o[t]=r}else o[t]=""}const n=i(o,s);if(!n||"string"!=typeof n)return null;const a=r(n).toString(),l=this._symbolCache.get(a);if(l)return l.catch((()=>{this._symbolCache.pop(a)})),l;const p=n.split(";"),m=[],u=[];for(const t of p)if(t&&0!==t.length)if(-1===t.indexOf("po:"))if(-1!==t.indexOf("|"))for(const e of t.split("|"))this._itemNames.has(e)&&m.push(e);else this._itemNames.has(t)&&m.push(t);else{const e=t.substr(3).split("|");if(3===e.length){const s=e[0],t=e[1];let r=e[2];if("DashTemplate"===t)r=r.split(" ").map((e=>Number(e)));else if("Color"===t){const e=new f(r).toRgba();r=[e[0],e[1],e[2],255*e[3]]}else r=Number(r);u.push({primitiveName:s,propertyName:t,value:r})}}const h=!t(e.geometry)||!e.geometry.hasZ&&"point"===e.geometry.type,y=this._cimPartsToCIMSymbol(m,u,h,s);return this._symbolCache.put(a,y,1),y}async collectRequiredFields(e,s){await this.collectVVRequiredFields(e,s),this.scaleExpression&&await u(e,s,this.scaleExpression);const t=s.map((e=>e.name));for(const r in this.fieldMap)t.indexOf(this.fieldMap[r])<0||e.add(this.fieldMap[r])}get arcadeRequired(){return!0}async fetchResources(e){if(this._dictionaryPromise)return this._dictionaryPromise;if(!this.url)return void _.error("no valid URL!");const s=t(e)?e.abortOptions:null,r=y(this.url+"/resources/styles/dictionary-info.json",{responseType:"json",query:{f:"json"},...s}),[{data:i}]=await Promise.all([r,p()]);if(!i)throw this._dictionaryPromise=null,new l("esri.renderers.DictionaryRenderer","Bad dictionary data!");const o=i.expression,n=i.authoringInfo;this._refSymbolUrlTemplate=this.url+"/"+i.cimRefTemplateUrl,this._itemNames=new Set(i.itemsNames),this._symbolFields=n.symbol;const a={};if(this.config){const e=this.config;for(const s in e)a[s]=e[s]}if(n.configuration)for(const t of n.configuration)a.hasOwnProperty(t.name)||(a[t.name]=t.value);const c=[];if(t(e)&&e.fields&&this.fieldMap)for(const t of this._symbolFields){const s=this.fieldMap[t],r=e.fields.filter((e=>e.name===s));r.length>0&&c.push({...r[0],name:t})}return this._dictionaryPromise=m(o,t(e)?e.spatialReference:null,c,a).then((e=>{const s={scale:0};return(r,i)=>{const o=e.repurposeFeature({geometry:null,attributes:r});return s.scale=t(i)?i.scale:void 0,e.evaluate({$feature:o,$view:s})}})).catch((e=>(_.error("Creating dictinoary expression failed:",e),null))),this._dictionaryPromise}getSymbol(){return null}getSymbols(){return[]}getAttributeHash(){return this.visualVariables&&this.visualVariables.reduce(((e,s)=>e+s.getAttributeHash()),"")}getMeshHash(){return`${this.url}-${JSON.stringify(this.fieldMap)}`}getSymbolFields(){return this._symbolFields}async _getSymbolPart(e,s){if(this._ongoingRequests.has(e))return this._ongoingRequests.get(e).then((e=>e.data));const t=this._refSymbolUrlTemplate.replace(/\{itemName\}/gi,e),r=y(t,{responseType:"json",query:{f:"json"},...s});this._ongoingRequests.set(e,r);try{return(await r).data}catch(i){return this._ongoingRequests.delete(e),Promise.reject(i)}}_combineSymbolParts(e,s,t){if(!e||0===e.length)return null;const r={...e[0]};if(e.length>1){r.symbolLayers=[];for(const s of e){const e=s;r.symbolLayers.unshift(...e.symbolLayers)}}return t&&(r.callout=w),{type:"CIMSymbolReference",symbol:r,primitiveOverrides:s}}async _cimPartsToCIMSymbol(e,s,t,r){const i=new Array(e.length);for(let n=0;n<e.length;n++)i[n]=this._getSymbolPart(e[n],r);const o=await Promise.all(i);return new h({data:this._combineSymbolParts(o,s,t)})}};e([o({type:Object,json:{read:{source:"configuration"},write:{target:"configuration"}}})],S.prototype,"config",void 0),e([o({type:Object,json:{write:!0}})],S.prototype,"fieldMap",void 0),e([o({type:String,json:{read:{source:"scalingExpressionInfo.expression"},write:!0}})],S.prototype,"scaleExpression",void 0),e([a("scaleExpression")],S.prototype,"writeData",null),e([o({type:String,json:{read:{source:"scalingExpressionInfo.title"},write:{target:"scalingExpressionInfo.title",overridePolicy(e){return{enabled:!!e&&!!this.scaleExpression}}}}})],S.prototype,"scaleExpressionTitle",void 0),e([o({type:String,json:{write:!0}})],S.prototype,"url",void 0),e([a("visualVariables")],S.prototype,"writeVisualVariables",null),S=j=e([n("esri.renderers.DictionaryRenderer")],S);var x=S;export default x;
