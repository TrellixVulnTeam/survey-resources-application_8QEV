/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{_ as e}from"../../chunks/tslib.es6.js";import"../../core/has.js";import{getDeepValue as r}from"../../core/object.js";import{isSome as t}from"../../core/maybe.js";import"../../core/Logger.js";import"../../core/accessorSupport/ensureType.js";import"../../core/accessorSupport/decorators/property.js";import{subclass as s}from"../../core/accessorSupport/decorators/subclass.js";import o from"../../core/Error.js";import{urlToObject as i}from"../../core/urlUtils.js";import"../../core/uuid.js";import"../../portal/support/resourceExtension.js";import a from"../../request.js";import n from"../Task.js";async function l(e,r){try{const{data:{supportedTravelModes:t,defaultTravelMode:s}}=await a(e+("/"===e[e.length-1]?"":"/")+"retrieveTravelModes",{query:{f:"json",token:r}});return{supportedTravelModes:t,defaultTravelMode:s}}catch(t){throw new o("network-service:retrieveTravelModes","Could not get to the NAServer's retrieveTravelModes.",{error:t})}}async function c(e,t){const{data:s}=await a(e.substring(0,e.indexOf("/rest/")+6)+"info",{query:{f:"json",token:t}});if(!s||!s.owningSystemUrl)return{supportedTravelModes:[],defaultTravelMode:null};e=s.owningSystemUrl;const{data:o}=await a(e+("/"===e[e.length-1]?"":"/")+"sharing/rest/portals/self",{query:{f:"json",token:t}}),n=r("helperServices.routingUtilities.url",o);if(!n)return{supportedTravelModes:[],defaultTravelMode:null};const l=i(e),c=/\/solveClosestFacility$/.test(l.path)?"Route":/\/solveClosestFacility$/.test(l.path)?"ClosestFacility":"ServiceAreas",u=await a(n+("/"===n[n.length-1]?"":"/")+"GetTravelModes/execute",{query:{f:"json",serviceName:c,token:t}}),p=[];let d=null;if(u&&u.data&&u.data.results&&u.data.results.length){const e=u.data.results;for(const r of e)if("supportedTravelModes"===r.paramName){if(r.value&&r.value.features)for(const{attributes:e}of r.value.features)if(e){const r=JSON.parse(e.TravelMode);p.push(r)}}else"defaultTravelMode"===r.paramName&&(d=r.value)}return{supportedTravelModes:p,defaultTravelMode:d}}const u=r=>{let i=class extends r{async getServiceDescription(e){return this._serviceDescriptionPromise||(this._serviceDescriptionPromise=this._fetchServiceDescription(e)),this._serviceDescriptionPromise}async _fetchServiceDescription(e){if(!this.url||!this.parsedUrl)throw new o("network-service:missing-url","Url to Network service is missing");const r=this.url,{data:t}=await a(r,{query:{f:"json",token:e}});t.supportedTravelModes||(t.supportedTravelModes=[]);for(let o=0;o<t.supportedTravelModes.length;o++)t.supportedTravelModes[o].id||(t.supportedTravelModes[o].id=t.supportedTravelModes[o].itemId);const s=t.currentVersion>=10.4?l(r,e):c(r,e),{defaultTravelMode:i,supportedTravelModes:n}=await s;return t.defaultTravelMode=i,t.supportedTravelModes=n,t}_isInputGeometryZAware(e,r){for(let s=0;s<r.length;s++){const o=e[r[s]];if(o&&o.length)for(const e of o)if(t(e)&&e.hasZ)return!0}return!1}_dropZValuesOffInputGeometry(e,r){for(let t=0;t<r.length;t++){const s=e[r[t]];if(s&&s.length)for(const e of s)e.z=void 0}console.log("The remote Network Analysis service is powered by a network dataset which is not Z-aware.\nZ-coordinates of the input geometry are ignored.")}};return i=e([s("esri.tasks.mixins.NAServiceDescription")],i),i};let p=class extends(u(n)){};p=e([s("esri.tasks.mixins.NAServiceDescription")],p);export{p as NAServiceDescription,u as NAServiceDescriptionMixin};
