/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{isSome as e}from"../../core/maybe.js";import o from"../../core/Error.js";import{substitute as i}from"../../intl/substitute.js";import{fetchMessageBundle as r}from"../../intl/messages.js";import"../../renderers/PointCloudRenderer.js";import"../../renderers/PointCloudClassBreaksRenderer.js";import a from"../../renderers/PointCloudRGBRenderer.js";import l from"../../renderers/PointCloudStretchRenderer.js";import"../../renderers/PointCloudUniqueValueRenderer.js";import n from"../../renderers/support/AuthoringInfoVisualVariable.js";import s from"../../renderers/support/AuthoringInfo.js";import"../../renderers/Renderer.js";import t from"../../renderers/visualVariables/ColorVariable.js";import m from"../../renderers/ClassBreaksRenderer.js";import"../../renderers/UniqueValueRenderer.js";import"../../renderers/DictionaryRenderer.js";import"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/SimpleRenderer.js";import"../../renderers/support/jsonUtils.js";import{getFieldsList as d,getNormalizationType as u}from"../support/utils.js";import{createColorStops as p,setLabelsForClassBreaks as c}from"../../renderers/support/utils.js";import{createLayerAdapter as y,getLayerTypeLabels as f}from"../support/adapters/support/layerUtils.js";import{getAgeExpressions as b,verifyDates as h,supportedAgeUnits as v}from"../statistics/support/ageUtils.js";import w from"../heuristics/ageUnit.js";import g from"../heuristics/outline.js";import T from"../heuristics/sizeRange.js";import{getSummaryStatistics as x,getClassBreaks as E,getPointSizeAlgorithm as V,formatDate as z,updateAgeRendererAuthoringInfoVV as S,createError as M,verifyBasicFieldValidity as j,isValidPointSize as I,createColors as O,getDefaultDataRange as q,createDefaultStopValues as C,createStopValues as k,getDataRange as F,createDataValues as P,createSymbol as U,getSymbolSizeFromScheme as R,getSymbolOutlineFromScheme as B,getBasemapInfo as D}from"./support/utils.js";import{c as A,g as L,a as G}from"../../chunks/color.js";const W="date",$="high-to-low",H=2**53-1,_=5;async function J(i){if(!(i&&i.layer&&(i.field||i.valueExpression||i.sqlExpression)))throw new o("color-visual-variable:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(i.valueExpression&&!i.sqlExpression&&!i.view)throw new o("color-visual-variable:missing-parameters","View is required when 'valueExpression' is specified");const r={...i};if("90-10"===r.theme)throw new o("color-visual-variable:not-supported","Only 'high-to-low', 'above-and-below', 'centered-on', 'extremes', 'above', 'below' themes are supported.");const a=[0,2,1,3],l=y(r.layer,a);if(r.layer=l,!l)throw new o("color-visual-variable:invalid-parameters","'layer' must be one of these types: "+f(a).join(", "));const n=e(r.signal)?{signal:r.signal}:null;await l.load(n);if("mesh"!==l.geometryType&&r.worldScale&&(!r.view||"3d"!==r.view.type))return Promise.reject(M("color-visual-variable:invalid-parameters","'view' parameter should be an instance of SceneView when 'worldScale' parameter is true"));const s=await d({field:r.field,normalizationField:r.normalizationField,valueExpression:r.valueExpression}),t=j(l,s,"color-visual-variable:invalid-parameters");if(t)throw t;return r}async function K(i){if(!(i&&i.layer&&(i.field||i.valueExpression||i.sqlExpression)))throw new o("color-continuous-renderer:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(i.valueExpression&&!i.sqlExpression&&!i.view)throw new o("color-continuous-renderer:missing-parameters","View is required when 'valueExpression' is specified");const r={...i};r.symbolType=r.symbolType||"2d",r.defaultSymbolEnabled=null==r.defaultSymbolEnabled||r.defaultSymbolEnabled;const a=[0,2,1,3],l=y(r.layer,a);if(r.layer=l,!l)throw new o("color-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+f(a).join(", "));const n=e(r.signal)?{signal:r.signal}:null;await l.load(n);const s=l.geometryType;if(r.outlineOptimizationEnabled="polygon"===s&&r.outlineOptimizationEnabled,r.sizeOptimizationEnabled=("point"===s||"multipoint"===s||"polyline"===s)&&r.sizeOptimizationEnabled,"mesh"===s)r.symbolType="3d-volumetric",r.colorMixMode=r.colorMixMode||"replace",r.edgesType=r.edgesType||"none";else{if("3d-volumetric-uniform"===r.symbolType&&"point"!==s)throw new o("color-continuous-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(r.symbolType.indexOf("3d-volumetric")>-1&&(!r.view||"3d"!==r.view.type))throw new o("color-continuous-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const t=await d({field:r.field,normalizationField:r.normalizationField,valueExpression:r.valueExpression}),m=j(l,t,"color-continuous-renderer:invalid-parameters");if(m)throw m;return r}async function N(i){if(!i||!i.layer||!i.field&&!i.valueExpression)throw new o("color-class-breaks-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(i.valueExpression&&!i.view)throw new o("color-class-breaks-renderer:missing-parameters","View is required when 'valueExpression' is specified");const r={...i};r.symbolType=r.symbolType||"2d",r.defaultSymbolEnabled=null==r.defaultSymbolEnabled||r.defaultSymbolEnabled,r.classificationMethod=r.classificationMethod||"equal-interval",r.normalizationType=u(r);const a=[0,2,1,3],l=y(r.layer,a);if(r.layer=l,!l)throw new o("color-class-breaks-renderer:invalid-parameters","'layer' must be one of these types: "+f(a).join(", "));if(!(null!=r.minValue&&null!=r.maxValue)&&(null!=r.minValue||null!=r.maxValue))throw new o("color-class-breaks-renderer:missing-parameters","Both 'minValue' and 'maxValue' are required when specifying custom data range");const n=e(r.signal)?{signal:r.signal}:null;await l.load(n);const s=l.geometryType;if(r.outlineOptimizationEnabled="polygon"===s&&r.outlineOptimizationEnabled,"mesh"===s)r.symbolType="3d-volumetric",r.colorMixMode=r.colorMixMode||"replace",r.edgesType=r.edgesType||"none";else{if("3d-volumetric-uniform"===r.symbolType&&"point"!==s)throw new o("color-continuous-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(r.symbolType.indexOf("3d-volumetric")>-1&&(!r.view||"3d"!==r.view.type))throw new o("color-class-breaks-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const t=await d({field:r.field,normalizationField:r.normalizationField}),m=j(l,t,"color-class-breaks-renderer:invalid-parameters");if(m)throw m;return r}function Q(e){const o={...e};delete o.basemap,delete o.colorScheme,delete o.legendOptions,delete o.symbolType,delete o.defaultSymbolEnabled,delete o.colorMixMode,delete o.edgesType;const i=o;return i.analyzeData=!(null!=o.minValue&&null!=o.maxValue),i}function X(o){if(!o||!o.layer)return Promise.reject(M("color-point-cloud-true-color-renderer:missing-parameters","'layer' parameter is required"));const i={...o},r=[4],a=y(i.layer,r);if(i.layer=a,i.density=i.density||25,i.size=i.size||"100%",!I(i.size))return Promise.reject(M("color-point-cloud-true-color-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'"));if(!a)return Promise.reject(M("color-point-cloud-true-color-renderer:invalid-parameters","'layer' must be one of these types: "+f(r).join(", ")));const l=e(i.signal)?{signal:i.signal}:null;return a.load(l).then((()=>i))}function Y(o){if(!(o&&o.layer&&o.field))return Promise.reject(M("color-point-cloud-continuous-renderer:missing-parameters","'layer' and 'field' parameters are required"));const i=o.field.toLowerCase();if("intensity"!==i&&"elevation"!==i)return Promise.reject(M("color-point-cloud-continuous-renderer:invalid-parameters","'field' should be either 'intensity' or 'elevation'"));const r={...o},a=[4],l=y(r.layer,a);if(r.layer=l,r.density=r.density||25,r.size=r.size||"100%",!I(r.size))return Promise.reject(M("color-point-cloud-continuous-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'"));if(!l)return Promise.reject(M("color-point-cloud-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+f(a).join(", ")));const n=e(r.signal)?{signal:r.signal}:null;return l.load(n).then((()=>r))}function Z(e){const o={...e},i=o.symbolType.indexOf("3d-volumetric")>-1;delete o.symbolType,delete o.defaultSymbolEnabled,delete o.colorMixMode,delete o.edgesType;const r=o;return r.worldScale=i,r}async function ee(i){if(!(i&&i.layer&&i.view&&i.startTime&&i.endTime))throw new o("color-age-renderer:missing-parameters","'layer', 'view', startTime', 'endTime' parameters are required");const r={...i};r.symbolType=r.symbolType||"2d",r.defaultSymbolEnabled=null==r.defaultSymbolEnabled||r.defaultSymbolEnabled;const a=[0,2,1,3],l=y(r.layer,a);if(r.layer=l,!l)throw new o("color-age-renderer:invalid-parameters","'layer' must be one of these types: "+f(a).join(", "));const n=e(r.signal)?{signal:r.signal}:null;await l.load(n);const s=l.geometryType;if(r.outlineOptimizationEnabled="polygon"===s&&r.outlineOptimizationEnabled,r.sizeOptimizationEnabled=("point"===s||"multipoint"===s||"polyline"===s)&&r.sizeOptimizationEnabled,"mesh"===s)r.symbolType="3d-volumetric",r.colorMixMode=r.colorMixMode||"replace",r.edgesType=r.edgesType||"none";else if("3d-volumetric-uniform"===r.symbolType&&"point"!==s)throw new o("color-continuous-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(r.symbolType.indexOf("3d-volumetric")>-1&&(!r.view||"3d"!==r.view.type))throw new o("color-age-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'");const t=h(l,r.startTime,r.endTime,"color-age-renderer:invalid-parameters");if(t)throw t;if(r.unit&&-1===v.indexOf(r.unit))throw new o("color-age-renderer:invalid-unit",`Supported units are: ${v.join(", ")}`);return r}async function oe(o,i){let r=o.colorScheme,a=null,l=null;const n=await D(o.basemap,o.view);if(a=e(n.basemapId)?n.basemapId:null,l=e(n.basemapTheme)?n.basemapTheme:null,r)return{scheme:A(r),basemapId:a,basemapTheme:l};const s=i||o.theme||$,t=L({theme:s,basemap:a,basemapTheme:l,geometryType:o.geometryType,worldScale:o.worldScale,view:o.view});if(t)if(a=t.basemapId,l=t.basemapTheme,o.schemeId){const e=s+"/"+a+"/"+o.schemeId;r=G({id:e,geometryType:o.geometryType})}else r=t.primaryScheme;return{scheme:r,basemapId:a,basemapTheme:l}}async function ie(e,o){const i=o.layer,r=await oe({basemap:o.basemap,colorScheme:o.colorScheme,geometryType:i.geometryType,schemeId:"elevation"===o.field.toLowerCase()?"point-cloud-elevation-scheme":"point-cloud-intensity-scheme"}),a=r.scheme;if(!a)throw M("color-point-cloud-continuous-renderer:insufficient-info","Unable to find color scheme");const l=O(a.colors,_);if(l.length<_)throw M("color-point-cloud-continuous-renderer:insufficient-info","Color scheme does not have enough colors");const n=q(e,!1,!0),s=n?C(n[0],n[1],5):k(e);return{stops:p({values:s,isDate:!1,dateFormatOptions:null,colors:l,labelIndexes:[0,2,4]}),basemapId:r.basemapId,basemapTheme:r.basemapTheme,statistics:e,defaultValuesUsed:!!n,colorScheme:A(a)}}async function re(e,o,i){const r=e.layer,{field:a,theme:l}=e,m=a&&!("function"==typeof a)?r.getField(a):null,d=m&&m.type===W,u=await oe({basemap:e.basemap,theme:e.theme,geometryType:r.geometryType,colorScheme:e.colorScheme,worldScale:e.worldScale,view:e.view}),p=u.scheme;if(!p)throw M("color-visual-variable:insufficient-info","Unable to find color scheme");const c=O(p.colors,_);if(c.length<_)throw M("color-visual-variable:insufficient-info","Color scheme does not have enough colors");const y=p.id.indexOf("seq-")>-1,f=F(o,i,l,d,"90-10"!==l),b=P(f,o,l,y),h=O(c,_),v=new t({field:a,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,normalizationField:e.normalizationField,stops:b.map(((e,o)=>({value:e,color:h[o]}))),legendOptions:e.legendOptions}),w=new n({type:"color",minSliderValue:null!=e.minValue?e.minValue:o.min,maxSliderValue:null!=e.maxValue?e.maxValue:o.max,theme:p.theme}),g=new s({visualVariables:[w]});return{basemapId:u.basemapId,basemapTheme:u.basemapTheme,visualVariable:v,statistics:o,defaultValuesUsed:f.defaultValuesUsed,colorScheme:A(p),authoringInfo:g}}async function ae(e,o,i,a,l,n){const s=await r("esri/smartMapping/t9n/smartMapping"),t=n.layer,d=n.field,u=t.geometryType,p=n.defaultSymbolEnabled,c=A(e.colorScheme),y=o&&o.opacity,f=[e.visualVariable.clone()];o&&o.visualVariables&&o.visualVariables.length&&f.push(...o.visualVariables.map((e=>e.clone()))),i&&i.minSize&&f.push(i.minSize);return{renderer:new m({classBreakInfos:[{minValue:-H,maxValue:H,symbol:U(u,{type:n.symbolType,color:c.noDataColor,size:R(c,u),outline:B(c,u,y),meshInfo:{colorMixMode:n.colorMixMode,edgesType:n.edgesType}})}],defaultLabel:p?s.other:null,defaultSymbol:p?U(u,{type:n.symbolType,color:c.noDataColor,size:R(c,u),outline:B(c,u,y),meshInfo:{colorMixMode:n.colorMixMode,edgesType:n.edgesType}}):null,field:d,normalizationType:a,normalizationField:l,valueExpression:n.valueExpression,valueExpressionTitle:n.valueExpressionTitle,visualVariables:f,authoringInfo:e.authoringInfo&&e.authoringInfo.clone()}),visualVariable:e.visualVariable.clone(),statistics:e.statistics,defaultValuesUsed:e.defaultValuesUsed,colorScheme:A(e.colorScheme),basemapId:e.basemapId,basemapTheme:e.basemapTheme}}async function le(e){const o=await J(e),{view:i,field:r,valueExpression:a,minValue:l,maxValue:n,layer:s,normalizationField:t,signal:m,statistics:d}=o,u=t?"field":void 0,[p,c]=await Promise.all([d||x({layer:s,field:r,valueExpression:a,sqlExpression:o.sqlExpression,sqlWhere:o.sqlWhere,normalizationType:u,normalizationField:t,minValue:l,maxValue:n,view:i,signal:m}),"90-10"===o.theme?E({layer:s,field:r,normalizationField:t,valueExpression:a,classificationMethod:"quantile",minValue:l,maxValue:n,view:i,numClasses:10,signal:m}):null]);return re(o,p,null==c?void 0:c.result)}function ne(e,o){const i=e.colorsForClassBreaks;let r;if(i&&i.length>0&&(i.some((e=>(e.numClasses===o&&(r=e.colors),!!r))),!r)){const e=i[i.length-1],a=o-e.numClasses;if(a>0){const o=e.colors[e.numClasses-1];r=e.colors.splice(0);for(let e=1;e<=a;e++)r.push(o)}}return r&&(r=O(r,r.length)),r}async function se(e,i){const a=await r("esri/smartMapping/t9n/smartMapping"),l=e.layer,n=e.defaultSymbolEnabled,t=l.geometryType,d=await oe({basemap:e.basemap,geometryType:t,colorScheme:e.colorScheme,worldScale:e.symbolType.indexOf("3d-volumetric")>-1,view:e.view}),u=d.scheme,{result:p,outlineResult:y}=i,f=p.classBreakInfos,b=e.classificationMethod,h="standard-deviation"===b,v=e.normalizationType;if(!u)throw new o("color-class-breaks-renderer:insufficient-info","Unable to find color scheme");const w=ne(u,f.length);if(!w||w.length!==f.length)throw new o("color-class-breaks-renderer:insufficient-info","Color scheme does not have enough colors");const g=y&&y.opacity,T=new m({classBreakInfos:f.map(((o,i)=>({minValue:o.minValue,maxValue:o.maxValue,symbol:U(t,{type:e.symbolType,color:w[i],size:R(u,t),outline:B(u,t,g),meshInfo:{colorMixMode:e.colorMixMode,edgesType:e.edgesType}}),label:o.label}))),defaultLabel:n?a.other:null,defaultSymbol:n?U(t,{type:e.symbolType,color:u.noDataColor,size:R(u,t),outline:B(u,t,g),meshInfo:{colorMixMode:e.colorMixMode,edgesType:e.edgesType}}):null,field:e.field,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,normalizationType:v,normalizationField:e.normalizationField,normalizationTotal:"percent-of-total"===v?p.normalizationTotal:void 0,legendOptions:e.legendOptions,authoringInfo:new s({type:"class-breaks-color",classificationMethod:b,standardDeviationInterval:e.standardDeviationInterval})});return h||c({classBreakInfos:T.classBreakInfos,classificationMethod:b,normalizationType:v,round:!0}),y&&y.visualVariables&&y.visualVariables.length&&(T.visualVariables=y.visualVariables.map((e=>e.clone()))),{renderer:T,colorScheme:A(u),classBreaksResult:p,defaultValuesUsed:i.defaultValuesUsed,basemapId:d.basemapId,basemapTheme:d.basemapTheme}}async function te(e){const o=await K(e),{layer:i,view:r,signal:a}=o,[l,n,s]=await Promise.all([le(Z(o)),o.outlineOptimizationEnabled?g({layer:i,view:r,signal:a}):null,o.sizeOptimizationEnabled?T({layer:i,view:r,signal:a}):null]),t=o.normalizationField;return ae(l,n,s,t?"field":void 0,t,o)}async function me(e){const o=await N(e);return se(o,await E(Q(o),o.outlineOptimizationEnabled))}function de(e){return X(e).then((e=>({renderer:new a({field:"RGB",pointsPerInch:e.density,pointSizeAlgorithm:V(e.size)})})))}async function ue(e){const o=await Y(e),i=o.statistics?o.statistics:await x({layer:o.layer,field:o.field,signal:o.signal}),r=await ie(i,o);return{renderer:new l({field:o.field,pointsPerInch:o.density,pointSizeAlgorithm:V(o.size),stops:r.stops}),basemapId:r.basemapId,basemapTheme:r.basemapTheme,statistics:r.statistics,defaultValuesUsed:r.defaultValuesUsed,colorScheme:r.colorScheme}}async function pe(e){const o=await r("esri/smartMapping/t9n/smartMapping"),a=await ee(e),{defaultSymbolEnabled:l,view:n,startTime:s,endTime:t,symbolType:m,colorMixMode:d,edgesType:u,minValue:p,maxValue:c,signal:y}=a,f=a.layer,[h,v,x]=await Promise.all([a.unit?{unit:a.unit,statistics:null}:w({view:n,layer:f,startTime:s,endTime:t,minValue:p,maxValue:c,signal:y}),a.outlineOptimizationEnabled?g({layer:f,view:n,signal:y}):null,a.sizeOptimizationEnabled?T({layer:f,view:n,signal:y}):null]),{unit:E,statistics:V}=h,M=b({layer:f,startTime:s,endTime:t,unit:E}).valueExpression,j=i(o[`ageInfo_${E}`],{unit:E,startTime:z(s,E,f),endTime:z(t,E,f)}),I=await le(Z({layer:f,basemap:a.basemap,valueExpression:M,symbolType:m,statistics:V,legendOptions:{title:j},colorScheme:a.colorScheme,theme:a.theme,view:n,minValue:a.minValue,maxValue:a.maxValue,signal:y})),O={layer:f,valueExpression:M,defaultSymbolEnabled:l,symbolType:m,colorMixMode:d,edgesType:u},q=await ae(I,v,x,null,null,O);return q.renderer.authoringInfo.visualVariables.forEach((e=>S(e,s,t,E))),{...q,unit:E}}export{pe as createAgeRenderer,me as createClassBreaksRenderer,te as createContinuousRenderer,ue as createPCContinuousRenderer,de as createPCTrueColorRenderer,le as createVisualVariable};
