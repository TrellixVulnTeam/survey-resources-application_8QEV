/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{clone as e}from"../../core/lang.js";import{isSome as a}from"../../core/maybe.js";import n from"../../core/Error.js";import{fetchMessageBundle as i}from"../../intl/messages.js";import l from"../../renderers/support/AuthoringInfoClassBreakInfo.js";import r from"../../renderers/support/AuthoringInfoFieldInfo.js";import s from"../../renderers/support/AuthoringInfo.js";import{applyColorToSymbol as o}from"../../symbols/support/utils.js";import{createLayerAdapter as t,getLayerTypeLabels as d}from"../support/adapters/support/layerUtils.js";import{createColors as m,getClassBreaks as u,verifyBasicFieldValidity as f,getBasemapInfo as p}from"./support/utils.js";import{createRenderer as c}from"./type.js";import{g as h,f as y,c as b,a as w}from"../../chunks/relationship.js";const v=["equal-interval","natural-breaks","quantile"],g=["HH","HL","LH","LL"],I={2:[["HL","HH"],["LL","LH"]],3:[["HL","HM","HH"],["ML","MM","MH"],["LL","LM","LH"]],4:[["HL","HM1","HM2","HH"],["M2L","M2M1","M2M2","M2H"],["M1L","M1M1","M1M2","M1H"],["LL","LM1","LM2","LH"]]},M={2:["L","H"],3:["L","M","H"],4:["L","M1","M2","H"]},z=e=>({minValue:e.minValue,maxValue:e.maxValue});async function F(e){if(!(e&&e.layer&&e.view&&e.field1&&e.field2))throw new n("relationship-renderer:missing-parameters","'layer', 'view', 'field1' and 'field2' parameters are required");const i={...e};if(i.symbolType=i.symbolType||"2d",i.defaultSymbolEnabled=null==i.defaultSymbolEnabled||i.defaultSymbolEnabled,i.classificationMethod=i.classificationMethod||"quantile",i.numClasses=i.numClasses||3,i.focus=i.focus||null,-1===v.indexOf(i.classificationMethod))throw new n("relationship-renderer:invalid-parameters",`classification method ${i.classificationMethod} is not supported`);if(i.numClasses<2||i.numClasses>4)throw new n("relationship-renderer:invalid-parameters","'numClasses' must be 2, 3 or 4");if(e.focus&&-1===g.indexOf(e.focus))throw new n("relationship-renderer:invalid-parameters","'focus' must be 'HH', 'HL', 'LH', 'LL' or null");const l=[0,2,1,3],r=t(i.layer,l);if(i.layer=r,!r)throw new n("relationship-renderer:invalid-parameters","'layer' must be one of these types: "+d(l).join(", "));const s=a(i.signal)?{signal:i.signal}:null;await r.load(s);const o=r.geometryType,m=i.symbolType.indexOf("3d")>-1;if(i.outlineOptimizationEnabled="polygon"===o&&i.outlineOptimizationEnabled,i.sizeOptimizationEnabled=("point"===o||"multipoint"===o||"polyline"===o)&&i.sizeOptimizationEnabled,"mesh"===o)i.symbolType="3d-volumetric",i.colorMixMode=i.colorMixMode||"replace",i.edgesType=i.edgesType||"none";else{if("3d-volumetric-uniform"===i.symbolType&&"point"!==o)throw new n("relationship-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(m&&"polygon"===o)throw new n("relationship-renderer:not-supported","3d symbols are not supported for polygon layers");if(i.symbolType.indexOf("3d-volumetric")>-1&&(!i.view||"3d"!==i.view.type))throw new n("relationship-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const{field1:u,field2:p}=i,c=[u.field,p.field];u.normalizationField&&c.push(u.normalizationField),p.normalizationField&&c.push(p.normalizationField);const h=f(r,c,"relationship-renderer:invalid-parameters");if(h)throw h;return i}async function T(e){if(!(e&&e.renderer&&e.numClasses))throw new n("update-relationship-renderer:missing-parameters","'renderer' and 'numClasses' parameters are required");const{field1:a,field2:i,renderer:l,numClasses:r,colors:s}=e,o=r**2;if((a||i)&&!(a&&i&&a.field&&i.field))throw new n("update-relationship-renderer:missing-parameters","'field1' and 'field2' parameters are required");if(a&&!a.classBreakInfos||i&&!i.classBreakInfos)throw new n("update-relationship-renderer:missing-parameters","'field1.classBreakInfos' and 'field2.classBreakInfos' are required");if(!l.authoringInfo)throw new n("update-relationship-renderer:missing-parameters","'renderer.authoringInfo' is required");if(l.uniqueValueInfos.length!==o)throw new n("update-relationship-renderer:invalid-parameters",`Renderer must have ${o} unique value infos to support ${r} classes`);if(s&&s.length!==o)throw new n("update-relationship-renderer:invalid-parameters",`The scheme must have ${o} colors`);return e}async function V(e){let n=e.relationshipScheme,i=null,l=null;const r=await p(e.basemap,e.view);if(i=a(r.basemapId)?r.basemapId:null,l=a(r.basemapTheme)?r.basemapTheme:null,n)return{scheme:b(n),basemapId:i,basemapTheme:l};const s=w({basemap:i,basemapTheme:l,geometryType:e.geometryType,theme:e.theme,worldScale:e.worldScale,view:e.view});return s&&(n=s.primaryScheme,i=s.basemapId,l=s.basemapTheme),{scheme:n,basemapId:i,basemapTheme:l}}function H(a,n){const i=e(I[a]);return y(i,n)}function L(e,a){return H(e,a).map((e=>({value:e,count:0})))}function k(e,a,n,i){const{field:l,normalizationField:r}=e,{field:s,normalizationField:o}=a,t=n.map((e=>[e.minValue,e.maxValue])),d=i.map((e=>[e.minValue,e.maxValue])),m=t.length,u=M[m];return`\n  var field1 = $feature['${l}'];\n  var field2 = $feature['${s}'];\n  var hasNormField1 = ${r?"true":"false"};\n  var hasNormField2 = ${o?"true":"false"};\n  var normField1 = ${r?`$feature['${r}']`:"null"};\n  var normField2 = ${o?`$feature['${o}']`:"null"};\n\n  if (\n    IsEmpty(field1) ||\n    IsEmpty(field2) ||\n    (hasNormField1 && (IsEmpty(normField1) || normField1 == 0)) ||\n    (hasNormField2 && (IsEmpty(normField2) || normField2 == 0))\n  ) {\n    return null;\n  }\n\n  var value1 = IIf(hasNormField1, (field1 / normField1), field1);\n  var value2 = IIf(hasNormField2, (field2 / normField2), field2);\n\n  var breaks1 = ${JSON.stringify(t)};\n  var breaks2 = ${JSON.stringify(d)};\n  var classCodes = ${JSON.stringify(u)};\n\n  function getClassCode(value, breaks) {\n    var code = null;\n\n    for (var i in breaks) {\n      var info = breaks[i];\n      if (value >= info[0] && value <= info[1]) {\n        code = classCodes[i];\n        break;\n      }\n    }\n\n    return code;\n  }\n\n  var code1 = getClassCode(value1, breaks1);\n  var code2 = getClassCode(value2, breaks2);\n\n  var classValue = IIf(IsEmpty(code1) || IsEmpty(code2), null, code1 + code2);\n  return classValue;\n  `}async function x(e,a,l){const r=await i("esri/smartMapping/t9n/smartMapping"),{basemap:o,classificationMethod:t,field1:d,field2:m,focus:u,numClasses:f,signal:p}=e,y=e.layer,b=a.classBreakInfos,w=l.classBreakInfos;if(f!==b.length||b.length!==w.length)throw new n("relationship-renderer:error","incompatible class breaks");const v=L(f,u),g=k(e.field1,e.field2,b,w),I=(await V({basemap:o,geometryType:y.geometryType,theme:"default",relationshipScheme:e.relationshipScheme,worldScale:e.symbolType.indexOf("3d-volumetric")>-1,view:e.view})).scheme,M=await c({layer:y,basemap:o,valueExpression:g,valueExpressionTitle:r.relationship.legendTitle,numTypes:-1,sortEnabled:!1,defaultSymbolEnabled:e.defaultSymbolEnabled,typeScheme:{colors:h(I,f,u),...I},statistics:{uniqueValueInfos:v},legendOptions:e.legendOptions,outlineOptimizationEnabled:e.outlineOptimizationEnabled,sizeOptimizationEnabled:e.sizeOptimizationEnabled,symbolType:e.symbolType,colorMixMode:e.colorMixMode,edgesType:e.edgesType,view:e.view,signal:p}),F=M.renderer,T=F.uniqueValueInfos,H=r.relationship;for(const n of T)n.label=H[n.value];const x=new s({type:"relationship",classificationMethod:t,numClasses:f,focus:u,field1:{field:d.field,normalizationField:d.normalizationField,label:d.label,classBreakInfos:b.map(z)},field2:{field:m.field,normalizationField:m.normalizationField,label:m.label,classBreakInfos:w.map(z)}});return F.authoringInfo=x,{renderer:F,classBreaks:{field1:a,field2:l},uniqueValueInfos:M.uniqueValueInfos,relationshipScheme:I,basemapId:M.basemapId,basemapTheme:M.basemapTheme}}function C(e,a,n){const i=H(a,n);e.sort(((e,a)=>{const n=i.indexOf(e.value),l=i.indexOf(a.value);let r=0;return n<l?r=-1:n>l&&(r=1),r}))}function E(e,a){const{authoringInfo:n}=e;n.numClasses=a.numClasses,n.focus=a.focus||null,n.focus||delete n.focus;const{field1:i,field2:s}=a;n.field1=new r({field:i.field,normalizationField:i.normalizationField,label:i.label,classBreakInfos:i.classBreakInfos.map((e=>new l(z(e))))}),n.field2=new r({field:s.field,normalizationField:s.normalizationField,label:s.label,classBreakInfos:s.classBreakInfos.map((e=>new l(z(e))))}),e.authoringInfo=n}async function O(e){const a=await T(e),{field1:n,field2:i,renderer:l,numClasses:r,focus:s,colors:t}=a,d=l.clone();if(d.valueExpression=k(n,i,n.classBreakInfos,i.classBreakInfos),C(d.uniqueValueInfos,r,s),t){const e=m(t,t.length);d.uniqueValueInfos.forEach(((a,n)=>o(a.symbol,e[n])))}return E(d,a),d}async function $(e){const a=await F(e),{layer:i,classificationMethod:l,field1:r,field2:s,numClasses:o,view:t,signal:d}=a,m={layer:i,classificationMethod:l,field:r.field,normalizationField:r.normalizationField,normalizationType:r.normalizationField?"field":null,minValue:r.minValue,maxValue:r.maxValue,analyzeData:!(null!=r.minValue&&null!=r.maxValue),numClasses:o,view:t,signal:d},f={layer:i,classificationMethod:l,field:s.field,normalizationField:s.normalizationField,normalizationType:s.normalizationField?"field":null,minValue:s.minValue,maxValue:s.maxValue,analyzeData:!(null!=s.minValue&&null!=s.maxValue),numClasses:o,view:t,signal:d},[p,c]=await Promise.all([u(m),u(f)]);if(!p||!c)throw new n("relationship-renderer:error","error when calculating class breaks");return x(a,p.result,c.result)}export{$ as createRenderer,O as updateRenderer};
