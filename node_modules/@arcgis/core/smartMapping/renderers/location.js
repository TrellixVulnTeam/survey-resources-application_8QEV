/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{isSome as e}from"../../core/maybe.js";import r from"../../core/Error.js";import"../../renderers/Renderer.js";import"../../renderers/ClassBreaksRenderer.js";import"../../renderers/UniqueValueRenderer.js";import"../../renderers/DictionaryRenderer.js";import"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import i from"../../renderers/SimpleRenderer.js";import"../../renderers/support/jsonUtils.js";import{c as o,g as a}from"../../chunks/location.js";import{createLayerAdapter as s,getLayerTypeLabels as n}from"../support/adapters/support/layerUtils.js";import t from"../heuristics/outline.js";import l from"../heuristics/sizeRange.js";import{createSymbol as m,getSymbolSizeFromScheme as p,getSymbolOutlineFromScheme as d,getBasemapInfo as c}from"./support/utils.js";async function u(i){if(!i||!i.layer)throw new r("location-renderer:missing-parameters","'layer' parameter is required");const o={...i};o.symbolType=o.symbolType||"2d";const a=[0,2,1,3],t=s(o.layer,a);if(o.layer=t,!t)throw new r("location-renderer:invalid-parameters","'layer' must be one of these types: "+n(a).join(", "));const l=e(o.signal)?{signal:o.signal}:null;await t.load(l);const m=t.geometryType;if(o.outlineOptimizationEnabled="polygon"===m&&o.outlineOptimizationEnabled,o.sizeOptimizationEnabled=("point"===m||"multipoint"===m||"polyline"===m)&&o.sizeOptimizationEnabled,"mesh"===m)o.symbolType="3d-volumetric",o.colorMixMode=o.colorMixMode||"replace",o.edgesType=o.edgesType||"none";else{if("3d-volumetric-uniform"===o.symbolType&&"point"!==m)throw new r("location-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(o.symbolType.indexOf("3d-volumetric")>-1&&(!o.view||"3d"!==o.view.type))throw new r("location-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}return o}async function y(r,i){let s=r.locationScheme,n=null,t=null;const l=await c(r.basemap,r.view);if(n=e(l.basemapId)?l.basemapId:null,t=e(l.basemapTheme)?l.basemapTheme:null,s)return{scheme:o(s),basemapId:n,basemapTheme:t};const m=a({basemap:n,basemapTheme:t,geometryType:i,worldScale:r.symbolType.indexOf("3d-volumetric")>-1,view:r.view});return m&&(s=m.primaryScheme,n=m.basemapId,t=m.basemapTheme),{scheme:s,basemapId:n,basemapTheme:t}}async function b(e){const a=await u(e),s=a.layer.geometryType,n=await y(a,s),c=n.scheme;if(!c)throw new r("location-renderer:insufficient-info","Unable to find location scheme");const{view:b,layer:f,signal:h}=a,[w,v]=await Promise.all([a.outlineOptimizationEnabled?t({view:b,layer:f,signal:h}):null,a.sizeOptimizationEnabled?l({view:b,layer:f,signal:h}):null]),T=w&&w.opacity,g=new i({symbol:m(s,{type:a.symbolType,color:c.color,size:p(c,s),outline:d(c,s,T),meshInfo:{colorMixMode:a.colorMixMode,edgesType:a.edgesType}})});return w&&w.visualVariables&&w.visualVariables.length&&(g.visualVariables=w.visualVariables.map((e=>e.clone()))),v&&v.minSize&&(g.visualVariables?g.visualVariables.push(v.minSize):g.visualVariables=[v.minSize]),{renderer:g,locationScheme:o(c),basemapId:n.basemapId,basemapTheme:n.basemapTheme}}export{b as createRenderer};
