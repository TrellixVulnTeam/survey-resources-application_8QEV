/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import"../../../core/has.js";import{isSome as e}from"../../../core/maybe.js";import t from"../../../core/Error.js";import{formatDate as n,convertDateFormatToIntlOptions as o}from"../../../intl/date.js";import i from"../../../Color.js";import l from"../../../symbols/ExtrudeSymbol3DLayer.js";import s from"../../../symbols/SimpleLineSymbol.js";import r from"../../../symbols/FillSymbol3DLayer.js";import a from"../../../symbols/IconSymbol3DLayer.js";import m from"../../../symbols/LineSymbol3DLayer.js";import u from"../../../symbols/ObjectSymbol3DLayer.js";import c from"../../../symbols/PathSymbol3DLayer.js";import f from"../../../symbols/LineSymbol3D.js";import d from"../../../symbols/MeshSymbol3D.js";import p from"../../../symbols/PointSymbol3D.js";import y from"../../../symbols/PolygonSymbol3D.js";import h from"../../../symbols/SimpleFillSymbol.js";import b from"../../../symbols/SimpleMarkerSymbol.js";import"../../../symbols.js";import w from"../../../renderers/support/pointCloud/PointSizeSplatAlgorithm.js";import{getBasemapId as g,getBasemapGroup as D,defaultBasemapGroups as j}from"../../support/utils.js";import{round as v}from"../../../renderers/support/numberUtils.js";import x from"../../statistics/summaryStatistics.js";import S from"../../heuristics/outline.js";import z from"../../statistics/classBreaks.js";import{getBackgroundColorTheme as V}from"../../../views/support/colorUtils.js";const L=/^(\d+(\.\d+)?)\s*(%)$/i,U=[0,0,0,.4],k=["hours","minutes","seconds"],I=[].concat(j.light).concat(j.dark);function T(e,t,i){if("string"==typeof e){const t=i.getField(e);if(t&&"date"===t.type)return t.alias||t.name}else if("number"==typeof e||e instanceof Date){const i=k.indexOf(t)>-1?"short-date-short-time":"short-date";return n(e,o(i))}return e}function B(e,n){return new t(e,n)}function F(e,t,n){return e+t>0&&0>e-t&&n<0?0:e}function M(e,t,n,o,i=!0){const l="90-10"===n&&t?{min:t.classBreakInfos[0].maxValue,max:t.classBreakInfos[t.classBreakInfos.length-1].minValue,avg:null,stddev:null}:e,{avg:s,stddev:r,min:a,max:m}=l,u=C(l,o,i);let c=u?u[0]:a,f=u?u[1]:m;return u?{minDataValue:c,maxDataValue:f,defaultValuesUsed:!0}:("above"===n?c=F(s,r,a):"below"===n&&(f=F(s,r,a)),{minDataValue:c,maxDataValue:f,defaultValuesUsed:!1})}function C(e,t,n){let o,i;const l=P({statistics:e,isDate:t});return l.defaultValuesUsed?(o=l.min,i=l.max):!n||null!=e.avg&&e.stddev||(o=e.min,i=e.max),null!=o?[o,i]:null}function P(e){let t,n,o=e&&e.statistics;if(o||(o={}),null==o.min)if(e.isDate){const e=A();t=e[0],n=e[1]}else t=0,n=100;else if(o.min===o.max)if(e.isDate){const e=A(o.min);t=e[0],n=e[1]}else o.min<0?(t=2*o.min,n=0):o.min>0?(t=0,n=2*o.min):(t=0,n=100);return{min:null!=t?t:o.min,max:null!=n?n:o.max,defaultValuesUsed:null!=t||null!=n}}function A(e){const t=("number"==typeof e?new Date(e):new Date).getUTCFullYear();let n=Date.UTC(t,0,1,12,0,0,0),o=Date.UTC(t,11,31,12,0,0,0);return"number"==typeof e&&(e<n&&(n=e),e>o&&(o=e)),[n,o]}function O(e,t){const n=[],o=e.length;for(let l=0;l<t;l++)n.push(new i(e[l%o]));return n}function R(e,t,n,o=!0){const{minDataValue:i,maxDataValue:l,defaultValuesUsed:s}=e;return s||"above"===n||"below"===n||"90-10"===n?W(i,l,5):q(t,o)}function Y(e){const{avg:t,stddev:n,min:o,max:i}=e;if(null==t||null==n)return W(o,i,5);const l=F(t,n,o),s=i-l,r=l-o,a=Math.max(s,r);return v([l-a,l-a/2,l,a/2+l,l+a],{strictBounds:!0})}function E(e,t){const{min:n,max:o}=t,[i,l,s,r,a]=e,m=null!=n&&i<n,u=null!=o&&a>o;if(null==n||null==o||!m&&!u)return e;const c=m?n:i,f=u?o:a;return v([c,m?c+(s-c)/2:l,s,u?s+(f-s)/2:r,f],{strictBounds:!0})}function W(e,t,n){const o=(t-e)/(n-1),i=[e];for(let l=1;l<=n-2;l++)i.push(e+l*o);return i.push(t),v(i,{strictBounds:!0})}function q(e,t=!0){let n=e.avg,o=n-e.stddev,i=n+e.stddev;o<e.min&&(o=e.min),i>e.max&&(i=e.max),t&&(n=o+(i-o)/2);let l=v([o,i],{strictBounds:!0});return o=l[0],i=l[1],l=[o,o+(n-o)/2,n,n+(i-n)/2,i],v(l,{strictBounds:!0})}function N(e,t,n){switch(t){case"point":case"multipoint":return n?"noDataSize"in e?e.noDataSize:null:"size"in e?e.size:null;case"polyline":return n?"noDataWidth"in e?e.noDataWidth:null:"width"in e?e.width:null;case"polygon":return"size"in e?e.size:null;case"mesh":default:return}}function $(e,t,n){switch(t){case"point":case"multipoint":case"polygon":{if(!("outline"in e))return null;const t={color:e.outline.color,width:e.outline.width};if(null!=n&&t.color){const e=t.color.clone();e.a=n,t.color=e}return t}case"polyline":case"mesh":default:return}}function G(e,t){const{type:n,size:o,color:i,outline:w}=t;let g;switch(e){case"point":case"multipoint":if("2d"===n)g=new b({color:i,size:o,outline:{color:w.color,width:w.width}});else if("3d-flat"===n)g=new p({symbolLayers:[new a({size:o,resource:{primitive:"circle"},material:{color:i},outline:{color:w.color,size:w.width}})]});else if(n.indexOf("3d-volumetric")>-1){const e="3d-volumetric-uniform"===n,l=new u({height:o,resource:{primitive:e?"sphere":"cylinder"},material:{color:i}});e||(l.width=t.widthAndDepth,l.depth=t.widthAndDepth),g=new p({symbolLayers:[l]})}break;case"polyline":"2d"===n?g=new s({color:i,width:o}):"3d-flat"===n?g=new f({symbolLayers:[new m({size:o,material:{color:i}})]}):"3d-volumetric"===n&&(g=new f({symbolLayers:[new c({size:o,material:{color:i}})]}));break;case"polygon":"2d"===n?g=new h({color:i,outline:{color:w.color,width:w.width}}):"3d-flat"===n?g=new y({symbolLayers:[new r({material:{color:i},outline:{color:w.color,size:w.width}})]}):"3d-volumetric"===n&&(g=new y({symbolLayers:[new l({size:o,material:{color:i}})]}));break;case"mesh":{const e=t.meshInfo&&t.meshInfo.colorMixMode,n=t.meshInfo&&t.meshInfo.edgesType;g=new d({symbolLayers:[new r({material:{color:i,colorMixMode:e},edges:null==n||"none"===n?null:{type:n,color:U}})]});break}}return g}function H(e,t,n){const o=J({layer:e,fields:t});if(o.length)return B(n,"Unknown fields: "+o.join(", ")+". You can only use fields defined in the layer schema");const i=K({layer:e,fields:t});return i.length?B(n,"Unsupported fields: "+i.join(", ")+". You can only use fields that are accessible to the renderer i.e. FieldUsageInfo.supportsRenderer must be true"):void 0}function J(e){const t=e.layer;return e.fields.filter((e=>!t.getField(e)))}function K(e){const t=e.layer;return e.fields.filter((e=>{const n=t.getFieldUsageInfo(e);return!n||!n.supportsRenderer}))}async function Q(e,t){const n={layer:e.layer,view:e.view,signal:e.signal},[o,i]=await Promise.all([z(e),t?S(n):null]),l=C({min:o.minValue,max:o.maxValue,avg:null,stddev:null},!1,!1);return{result:l?await z({...e,classificationMethod:"equal-interval",numClasses:1,analyzeData:!1,minValue:l[0],maxValue:l[1],normalizationTotal:l[0]+l[1]}):o,defaultValuesUsed:!!l,outlineResult:i}}function X(e){return x(e)}function Z(e,t){let{minSize:n,maxSize:o}=e;if("height"===t){n=((o-n)/2+n)/(2*2.3),o*=2}return{minSize:n,maxSize:o}}function _(e){return L.test(e)}function ee(e){const t=e.match(L),n=Number(t[1]);if("%"===t[3])return new w({scaleFactor:n/100})}function te(e,t,n,o){e.startTime=t instanceof Date?t.getTime():t,e.endTime=n instanceof Date?n.getTime():n,e.units=o,e.field="string"==typeof t?t:"string"==typeof n?n:null}async function ne(t,n){let o=null,i=null;if(!t&&!n)return{basemapId:o,basemapTheme:i};var l;!t&&n&&(t=n&&(null==(l=n.map)?void 0:l.basemap));if(t&&(o=g(t,I,!1),o)){const t=D(o);e(t)&&(i=t)}return o||"2d"!==(null==n?void 0:n.type)||(i=await V(n),e(i)&&(o="dark"===i?"dark-gray":"gray")),{basemapId:o,basemapTheme:i}}export{E as clampAboveAndBelowStopValues,O as createColors,R as createDataValues,W as createDefaultStopValues,B as createError,q as createStopValues,Y as createStopValuesForAboveBelow,G as createSymbol,T as formatDate,F as getBaseValueForAboveBelow,ne as getBasemapInfo,Q as getClassBreaks,M as getDataRange,C as getDefaultDataRange,ee as getPointSizeAlgorithm,Z as getSizeRangeForAxis,X as getSummaryStatistics,$ as getSymbolOutlineFromScheme,N as getSymbolSizeFromScheme,_ as isValidPointSize,te as updateAgeRendererAuthoringInfoVV,H as verifyBasicFieldValidity};
