/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{clone as e}from"../../core/lang.js";import{isSome as r}from"../../core/maybe.js";import s from"../../core/Error.js";import{fetchMessageBundle as l}from"../../intl/messages.js";import"../../renderers/PointCloudRenderer.js";import{LegendOptions as o}from"../../renderers/support/LegendOptions.js";import"../../renderers/PointCloudClassBreaksRenderer.js";import"../../renderers/PointCloudRGBRenderer.js";import"../../renderers/PointCloudStretchRenderer.js";import i from"../../renderers/PointCloudUniqueValueRenderer.js";import"../../renderers/Renderer.js";import"../../renderers/ClassBreaksRenderer.js";import t from"../../renderers/UniqueValueRenderer.js";import"../../renderers/DictionaryRenderer.js";import"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/SimpleRenderer.js";import"../../renderers/support/jsonUtils.js";import{getFieldsList as n}from"../support/utils.js";import{createUniqueValueLabel as a,calculateDateFormatInterval as p}from"../../renderers/support/utils.js";import{createLayerAdapter as u,getLayerTypeLabels as m}from"../support/adapters/support/layerUtils.js";import d from"../heuristics/outline.js";import c from"../heuristics/sizeRange.js";import{getPointSizeAlgorithm as y,verifyBasicFieldValidity as f,isValidPointSize as b,createColors as h,getSymbolSizeFromScheme as v,getSymbolOutlineFromScheme as g,createSymbol as w,getBasemapInfo as T}from"./support/utils.js";import E from"../statistics/uniqueValues.js";import{c as j,g as x}from"../../chunks/type.js";const I="date";async function V(l){if(!l||!l.layer||!l.field&&!l.valueExpression)throw new s("type-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(l.valueExpression&&!l.view)throw new s("type-renderer:missing-parameters","View is required when 'valueExpression' is specified");const o={...l};o.symbolType=o.symbolType||"2d",o.numTypes=null==o.numTypes?10:o.numTypes,o.defaultSymbolEnabled=null==o.defaultSymbolEnabled||o.defaultSymbolEnabled,o.sortBy=null==o.sortBy?"count":o.sortBy,o.sortEnabled=null==o.sortEnabled||o.sortEnabled,o.statistics=e(o.statistics);const i=[0,2,1,3],t=u(o.layer,i);if(o.layer=t,!t)throw new s("type-renderer:invalid-parameters","'layer' must be one of these types: "+m(i).join(", "));const a=r(o.signal)?{signal:o.signal}:null;await t.load(a);const p=t.geometryType;if(o.outlineOptimizationEnabled="polygon"===p&&o.outlineOptimizationEnabled,o.sizeOptimizationEnabled=("point"===p||"multipoint"===p||"polyline"===p)&&o.sizeOptimizationEnabled,"mesh"===p)o.symbolType="3d-volumetric",o.colorMixMode=o.colorMixMode||"replace",o.edgesType=o.edgesType||"none";else{if("3d-volumetric-uniform"===o.symbolType&&"point"!==p)throw new s("type-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(o.symbolType.indexOf("3d-volumetric")>-1&&(!o.view||"3d"!==o.view.type))throw new s("type-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const d=await n({field:o.field,valueExpression:o.valueExpression}),c=f(t,d,"type-renderer:invalid-parameters");if(c)throw c;return o}async function z(l){if(!(l&&l.layer&&l.field))throw new s("type-point-cloud-class-renderer:missing-parameters","'layer' and 'field' parameters are required");const o={...l};o.statistics=e(o.statistics);const i=[4],t=u(o.layer,i);if(o.layer=t,o.density=o.density||25,o.size=o.size||"100%",!b(o.size))throw new s("type-point-cloud-class-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'");if(!t)throw new s("type-point-cloud-class-renderer:invalid-parameters","'layer' must be one of these types: "+m(i).join(", "));const a=r(o.signal)?{signal:o.signal}:null;await t.load(a);const p=await n({field:o.field}),d=f(t,p,"type-point-cloud-class-renderer:invalid-parameters");if(d)throw d;return o}async function M(e){let s=e.typeScheme,l=null,o=null;const i=await T(e.basemap,e.view);if(l=r(i.basemapId)?i.basemapId:null,o=r(i.basemapTheme)?i.basemapTheme:null,s)return{scheme:j(s),basemapId:l,basemapTheme:o};const t=x({basemap:l,basemapTheme:o,geometryType:e.geometryType,theme:e.theme,worldScale:e.worldScale,view:e.view});return t&&(s=t.primaryScheme,l=t.basemapId,o=t.basemapTheme),{scheme:s,basemapId:l,basemapTheme:o}}function S(e,r){let s;return s=e.label<r.label?-1:e.label>r.label?1:0,s}function q(e,r){let s;return s=e.value<r.value?-1:e.value>r.value?1:0,s}function R(e,r){let s=r.count-e.count;return 0===s&&(s=S(e,r)),s}function O(e,r){let s=r.count-e.count;return 0===s&&(s=q(e,r)),s}function C(e,r,s){let l;"count"===r?(l=O,s&&s.codedValues&&(l=R)):"value"===r&&(l=q,s&&s.codedValues&&(l=S)),l&&e.sort(l)}async function B(e,r,s,i){const n=await l("esri/smartMapping/t9n/smartMapping"),u=e.uniqueValueInfos,m=r.layer,d=r.field,c=d?m.getField(d):null,y=c?m.getFieldDomain(c.name):null,f=-1===r.numTypes?u.length:r.numTypes,b=m.geometryType,T=await M({basemap:r.basemap,geometryType:b,typeScheme:r.typeScheme,worldScale:r.symbolType.indexOf("3d-volumetric")>-1,view:r.view}),E=T.scheme,x=new t({field:d});let V,z=-1;const S={value:null,domain:y,fieldInfo:c};if(u.forEach(((e,r)=>{S.value=e.value,e.label=a(S),null===e.value&&(z=r)})),z>-1&&(V=u.splice(z,1)[0]),!1!==r.sortEnabled&&C(u,r.sortBy,y),c&&c.type===I){const e=u.filter(((e,r)=>r<f)).map((e=>e.value));S.dateFormatInterval=p(e)}const q=s&&s.opacity;let R=h(E.colors,u.length);const O=v(E,b),B=g(E,b,q);u.forEach(((e,s)=>{S.value=e.value,e.label=a(S),e.symbol=w(b,{type:r.symbolType,color:R[s],size:O,outline:B,meshInfo:{colorMixMode:r.colorMixMode,edgesType:r.edgesType}})})),r.valueExpression&&(x.valueExpression=r.valueExpression,x.valueExpressionTitle=r.valueExpressionTitle),r.legendOptions&&(x.legendOptions=new o(r.legendOptions)),R=h(E.colors,f);for(let l=0;l<f;l++){const e=u[l];e&&x.addUniqueValueInfo({value:e.value,label:e.label,symbol:w(b,{type:r.symbolType,color:R[l],size:O,outline:B,meshInfo:{colorMixMode:r.colorMixMode,edgesType:r.edgesType}})})}r.defaultSymbolEnabled&&(x.defaultSymbol=w(b,{type:r.symbolType,color:E.noDataColor,size:O,outline:B,meshInfo:{colorMixMode:r.colorMixMode,edgesType:r.edgesType}}),x.defaultLabel=n.other),V&&(V.symbol=w(b,{type:r.symbolType,color:E.noDataColor,size:O,outline:B,meshInfo:{colorMixMode:r.colorMixMode,edgesType:r.edgesType}}),u.push(V));const P=[],U=x.uniqueValueInfos.length===u.length?-1:x.uniqueValueInfos.length;if(U>-1)for(let l=U;l<u.length;l++)P.push({...u[l]});return s&&s.visualVariables&&s.visualVariables.length&&(x.visualVariables=s.visualVariables.map((e=>e.clone()))),i&&i.minSize&&(x.visualVariables?x.visualVariables.push(i.minSize):x.visualVariables=[i.minSize]),{renderer:x,uniqueValueInfos:u,excludedUniqueValueInfos:P,typeScheme:j(E),basemapId:T.basemapId,basemapTheme:T.basemapTheme}}async function P(e,r){const s=e.uniqueValueInfos,l=await M({basemap:"gray",theme:"point-cloud-class",geometryType:"point",typeScheme:r}),o=l&&l.scheme,i="point-cloud-class"===o.theme,t=i?o.colors:h(o.colors,s.length);return C(s,"value"),s.map(((e,r)=>{const s=e.value;let l=null;return i?(l=t[s],l||(l=t[t.length-1])):l=t[r],{values:[s],color:l,label:e.label}}))}async function U(e){const r=await V(e),{layer:s,view:l,signal:o}=r,i={layer:s,field:r.field,valueExpression:r.valueExpression,returnAllCodedValues:r.returnAllCodedValues,view:l,signal:o},[t,n,a]=await Promise.all([null!=r.statistics?r.statistics:E(i),r.outlineOptimizationEnabled?d({layer:s,view:l,signal:o}):null,r.sizeOptimizationEnabled?c({layer:s,view:l,signal:o}):null]);return B(t,r,n,a)}async function D(e){const r=await z(e),s=null!=r.statistics?r.statistics:await E({layer:r.layer,field:r.field,signal:r.signal});return{renderer:new i({field:r.field,pointsPerInch:r.density,pointSizeAlgorithm:y(r.size),colorUniqueValueInfos:await P(s,r.typeScheme)})}}export{D as createPCClassRenderer,U as createRenderer};
