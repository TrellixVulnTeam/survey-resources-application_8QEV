/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{isSome as a}from"../../core/maybe.js";import e from"../../core/Error.js";import{getNormalizationType as s,getFieldsList as i}from"../support/utils.js";import{verifyBasicFieldValidity as r,verifyNumericField as l}from"./support/utils.js";import{createLayerAdapter as n,getLayerTypeLabels as t}from"../support/adapters/support/layerUtils.js";const o=5;async function m(m){if(!m||!m.layer||!m.field&&!m.valueExpression)throw new e("class-breaks:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(m.valueExpression&&!m.view)throw new e("class-breaks:missing-parameters","View is required when 'valueExpression' is specified");const p=[0,2,1,3],{layer:u,...f}=m,d=n(u,p),w={layerAdapter:d,...f};if(w.normalizationType=s(w),w.numClasses=w.numClasses||o,!d)throw new e("class-breaks:invalid-parameters","'layer' must be one of these types: "+t(p).join(", "));const c=a(w.signal)?{signal:w.signal}:null;await d.load(c);const h=w.field,y=w.minValue,v=w.maxValue,z=null!=y||null!=v,b=w.classificationMethod,x="percent-of-total"===w.normalizationType,k=!1!==w.analyzeData,V=h?d.getField(h):null,g=await i({field:w.field,normalizationField:w.normalizationField,valueExpression:w.valueExpression}),E=r(d,g,"class-breaks:invalid-parameters");if(E)throw E;if(V){const a=l(d,V,"class-breaks:invalid-parameters");if(a)throw a}if(w.valueExpression&&w.normalizationType)throw new e("class-breaks:invalid-parameters","Normalization is not allowed when 'valueExpression' is specified");if(z)if(k){if(x&&null==w.normalizationTotal)throw new e("class-breaks:missing-parameters","'normalizationTotal' is required when 'normalizationType' is 'precent-of-total' and 'minValue', 'maxValue' are specified")}else{if(null==y||null==v)throw new e("class-breaks:missing-parameters","Both 'minValue' and 'maxValue' are required when 'analyzeData' is false");if(y>=v)throw new e("class-breaks:invalid-parameters","'minValue' should be less than 'maxValue'");if(b&&"equal-interval"!==b)throw new e("class-breaks:invalid-parameters","'classificationMethod' other than 'equal-interval' is not allowed when 'analyzeData' is false");if(x&&null==w.normalizationTotal)throw new e("class-breaks:missing-parameters","'normalizationTotal' is required when 'normalizationType' is 'precent-of-total' and 'analyzeData' is false")}else if(!k)throw new e("class-breaks:missing-parameters","Both 'minValue' and 'maxValue' are required when 'analyzeData' is false");return w}async function p(a){const{layerAdapter:e,...s}=await m(a);return e.classBreaks(s)}export default p;
