/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{throwIfAborted as n}from"../../../../core/promiseUtils.js";import{loadArcade as t}from"../../../../support/arcadeOnDemand.js";import a from"../../../../tasks/support/ClassBreaksDefinition.js";import{createGenerateRendererClassBreaks as e}from"../../../../tasks/support/generateRendererUtils.js";import{isIntegerField as o,castIntegerFieldToFloat as i,getDateDiffSQL as l}from"../../utils.js";import{createKernel as r,createValueFunction as u}from"../../../../renderers/support/heatmapUtils.js";const s=/_value$/i,c=/\s*(\+|-)?((\d+(\.\d+)?)|(\.\d+))\s*/gi,m=5,f=10,d=Math.LOG10E,p="equal-interval",v=1,h=["min","max","avg","stddev","count","sum","variance"];let x=null;async function V(n,t,a){const e=[];if(t)for(const o of t){const t=n.getField(o);"availableFields"in a&&-1===a.availableFields.indexOf(t.name)&&e.push(t.name)}return e}function y(n,t){const a=n&&n.features,e=a&&a[0]&&a[0].attributes,o={};for(const i in e)o[i.replace(s,"").toLowerCase()]=e[i];return o.min===o.max&&null!=o.min&&null==o.stddev&&(o.stddev=o.variance=0),t&&(["min","max","avg","stddev","sum","variance"].forEach((n=>{null!=o[n]&&(o[n]=Math.ceil(o[n]))})),o.min===o.max&&null!=o.min&&(o.avg=o.min,o.stddev=o.variance=0)),o}async function g(n,t,a){let e=await z(n,t);e=T(e,n.minValue,n.maxValue);const o=b(e,!n.normalizationType);return a&&["avg","stddev","variance"].forEach((n=>{null!=o[n]&&(o[n]=Math.ceil(o[n]))})),o}function T(n,t,a){return t=null==t?-1/0:t,a=null==a?1/0:a,n.filter((n=>null!=n&&U(n)&&n>=t&&n<=a))}async function z(n,a){const e=n.field,o="function"==typeof e,i=n.valueExpression,l=n.normalizationType,r=n.normalizationField,u=n.normalizationTotal,s=[],c=n.view;let m=null,f=null;if(i){if(!x){const{arcadeUtils:n}=await t();x=n}m=x.createFunction(i),f=c&&x.getViewInfo({viewingMode:"2d"===c.type?"map":c.viewingMode,scale:c.scale,spatialReference:c.spatialReference})}return a?(a.forEach((n=>{const t=n.attributes;let a;if(i){const t=x.createExecContext(n,f);a=x.executeFunction(m,t)}else o?a=e.call(null,n):t&&(a=t[e]);if(l&&null!=a&&U(a)){const n=t&&parseFloat(t[r]),e=a;a=null,"log"===l&&0!==e?a=Math.log(e)*Math.LOG10E:"percent-of-total"===l&&U(u)&&0!==u?a=e/u*100:"field"===l&&U(n)&&0!==n?a=e/n:"natural-log"===l&&e>0?a=Math.log(e):"square-root"===l&&e>0&&(a=e**.5)}s.push(a)})),s):s}function b(n,t){let a=Number.POSITIVE_INFINITY,e=Number.NEGATIVE_INFINITY,o=null,i=null,l=null,r=null;for(const s of n)o+=s,a=Math.min(a,s),e=Math.max(e,s);const u=n.length;if(u){i=o/u;let a=0;for(const t of n)a+=(t-i)**2;r=t?u>1?a/(u-1):0:u>0?a/u:0,l=Math.sqrt(r)}else a=null,e=null;return{avg:i,count:u,max:e,min:a,stddev:l,sum:o,variance:r}}function I(n){let t;for(t in n)h.indexOf(t)>-1&&(U(n[t])||(n[t]=null));return n}function F(n){const t=n.field,e=n.classificationMethod||p,o=n.normalizationType,i=n.normalizationField,l=new a;return l.classificationField=t,l.breakCount=n.breakCount,l.classificationMethod=e,l.standardDeviationInterval="standard-deviation"===e?n.standardDeviationInterval||v:void 0,l.normalizationType=o,l.normalizationField="field"===o?i:void 0,l}function E(n,t=10,a,e,o,i){const l=new Float64Array(o*i),s=r(t),c=Math.round(3*t);let m=Number.POSITIVE_INFINITY,f=Number.NEGATIVE_INFINITY,d=0,p=0,v=0,h=0;const x=u(e,a);for(const{geometry:r,attributes:u}of n){const n=r.x-c,t=r.y-c,a=Math.max(0,n),e=Math.max(0,t),V=Math.min(i,r.y+c),y=Math.min(o,r.x+c),g=+x(u);for(let i=e;i<V;i++){const e=s[i-t];for(let t=a;t<y;t++){const a=s[t-n],r=i*o+t,u=l[r];d=l[r]+=e*a*g;const c=d-u;p+=c,v+=c*c,d<m&&(m=d),d>f&&(f=d),h++}}}if(!h)return{mean:0,stddev:0,min:0,max:0,mid:0,count:0};const V=(f-m)/2;return{mean:p/h,stdDev:Math.sqrt((v-p*p/h)/h),min:m,max:f,mid:V,count:h}}async function M(n,t){const a=n.normalizationTotal,o=F({field:n.field,normalizationType:n.normalizationType,normalizationField:n.normalizationField,classificationMethod:n.classificationMethod,standardDeviationInterval:n.standardDeviationInterval,breakCount:n.numClasses||m});let i=await z(n,t);i=T(i,n.minValue,n.maxValue);return w(n,e({definition:o,values:i,normalizationTotal:a}))}function w(n,t){let a=t.classBreaks;const e=a.length,o=a[0].minValue,i=a[e-1].maxValue,l="standard-deviation"===n.classificationMethod,r=c;return a=a.map((n=>{const t=n.label,a={minValue:n.minValue,maxValue:n.maxValue,label:t};if(l&&t){const n=t.match(r).map((n=>+n.trim()));2===n.length?(a.minStdDev=n[0],a.maxStdDev=n[1],n[0]<0&&n[1]>0&&(a.hasAvg=!0)):1===n.length&&(t.indexOf("<")>-1?(a.minStdDev=null,a.maxStdDev=n[0]):t.indexOf(">")>-1&&(a.minStdDev=n[0],a.maxStdDev=null))}return a})),{minValue:o,maxValue:i,classBreakInfos:a,normalizationTotal:t.normalizationTotal}}function N(n,t,a){const e=(t-n)/a,o=[];let i,l=n;for(let r=1;r<=a;r++)i=l+e,i=Number(i.toFixed(16)),o.push([l,r===a?t:i]),l=i;return o}function D(n){const t=[],a=n.classBreaks,e=a[0].minValue,o=a[a.length-1].maxValue;a.forEach((n=>{t.push([n.minValue,n.maxValue])}));const i={field:n.field,normalizationType:n.normalizationType,normalizationField:n.normalizationField,normalizationTotal:n.normalizationTotal,layer:n.layer};return{min:e,max:o,intervals:t,sqlExpr:C(i),excludeZerosExpr:n.where,normTotal:n.normalizationTotal}}function C(n){const{field:t,normalizationType:a,normalizationField:e,normalizationTotal:l,layer:r}=n,u=o(r,t);let s=t;return"percent-of-total"===a?s=`((${u?i(t):t} / ${l}) * 100)`:"log"===a?s=`(log(${t}) * ${d})`:"field"===a?s=`(${u?i(t):t} / ${e})`:"natural-log"===a?s=`(log(${u?i(t):t}))`:"square-root"===a&&(s=`(power(${u?i(t):t}, 0.5))`),s}async function O(n,t,a){const{min:e,max:o,normTotal:i}=t,l=n.numBins||f,r=t.intervals||N(e,o,l),u=r.map(((n,t)=>({minValue:r[t][0],maxValue:r[t][1],count:0}))),s=await z(n,a);for(const c of s)if(null!=c&&c>=e&&c<=o){const n=k(r,c);n>-1&&u[n].count++}return{bins:u,minValue:e,maxValue:o,normalizationTotal:i}}function k(n,t){let a=-1;for(let e=n.length-1;e>=0;e--){if(t>=n[e][0]){a=e;break}}return a}function q(n,t){let a;if(t=t.toLowerCase(),n)for(const e in n)if(e.toLowerCase()!==t){a=n[e];break}return a}function L(n,t){let a;if(t=t.toLowerCase(),n)for(const e in n)if(e.toLowerCase()===t){a=n[e];break}return a}function S(n,t,a,e,o){const i={},l="countOFExpr";n&&n.features&&n.features.forEach((n=>{const t=n.attributes,a=q(t,l),e=L(t,l);0!==a&&(i[a]=e)}));const r=[];return N(t,a,e).forEach(((n,t)=>{const a=(t+1).toString();r.push({minValue:n[0],maxValue:n[1],count:i.hasOwnProperty(a)?i[a]:0})})),{bins:r,minValue:t,maxValue:a,normalizationTotal:o}}function $(t,a,e,o,i){const l=t&&t.features,r="countOF"+(e||"Expr"),u={};let s=!1;if(l.forEach((n=>{const t=n.attributes,a=L(t,r);let o=e?L(t,e):q(t,r);null===o&&0===a&&(s=!0),(null==o||"string"==typeof o&&""===o.trim())&&(o=null),null==u[o]?u[o]={count:a,data:o}:u[o].count=u[o].count+a})),e&&s){const t=e+" is NULL";return a.queryFeatureCount(t,i).then((n=>(n=n||0,u.null.count=u.null.count+n,j(u,o)))).catch((()=>(n(i),j(u,o))))}return Promise.resolve(j(u,o))}function j(n,t){if(t)for(const a in n)n[a].label=t[a];return{count:n}}function A(n,t,a){const e=n.count,o=[];if(a&&t&&"coded-value"===t.type){t.codedValues.forEach((n=>{const t=n.code;e.hasOwnProperty(t)||(e[t]={data:t,count:0})}))}for(const i in e){const n=e[i];o.push({value:n.data,count:n.count,label:n.label})}return{uniqueValueInfos:o}}async function B(n,t,a){const e=await z(n,t),o={};for(let i of e)(null==i||"string"==typeof i&&""===i.trim())&&(i=null),null==o[i]?o[i]={count:1,data:i}:o[i].count++;return A({count:o},a,n.returnAllCodedValues)}function P(n,t){return l(n,new Date(0),t,"milliseconds").sqlExpression}function U(n){return"number"==typeof n&&!isNaN(n)&&n!==1/0&&n!==-1/0}export{M as calculateClassBreaksFromMemory,E as calculateHeatmapStats,O as calculateHistogramFromMemory,g as calculateStatsFromMemory,B as calculateUniqueValuesFromMemory,F as createCBDefn,A as createUVResult,D as generateBinParams,z as getDataValues,N as getEqualIntervalBins,C as getFieldExpr,S as getHistogramFromFeatureSet,V as getMissingFields,y as getSummaryStatisticsFromFeatureSet,$ as getUniqueValuesFromFeatureSet,U as isValidNumber,P as msSinceUnixEpochSQL,I as processSummaryStatisticsResult,w as resolveCBResult,h as statisticTypes};
