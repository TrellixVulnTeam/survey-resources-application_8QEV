/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import t from"../../../core/Logger.js";import o from"../MeshComponent.js";const e=t.getLogger("esri.geometry.support.triangleMeshMerge");function n(t,o){if(0===t.length)return e.error("merge()","Must specify one more more geometries to merge"),null;const n=t[0].spatialReference;if(t.some((t=>!t.spatialReference.equals(n))))return e.error("merge()","Geometries must all be in the same spatial reference"),null;const r=u(t),i=[],a={position:0,uv:0,normal:0,tangent:0,color:0},c=new Map,f=new Map;for(const e of t){const t=e.vertexAttributes;if(o&&o.reuseMaterials&&e.components)for(const o of e.components)o.material&&c.set(o.material,o.material);s(e,a,c,f,i),l("position",t,r,a,0),l("normal",t,r,a,0),l("tangent",t,r,a,0),l("uv",t,r,a,0),l("color",t,r,a,255)}return{vertexAttributes:r,components:i,spatialReference:n}}function r(t,o){return o.normal>0&&!t.vertexAttributes.normal}function i(t,o,e){r(t,o)&&"source"===e.shading&&(e.shading="flat")}function s(t,e,n,r,s){if(t.components)for(const o of t.components){const l=o.cloneWithDeduplication(n,r);for(let t=0;t<l.faces.length;t++)l.faces[t]+=e.position/3;i(t,e,l),s.push(l)}else if(t.vertexAttributes&&t.vertexAttributes.position){const n=t.vertexAttributes.position.length/3,r=new Uint32Array(n);for(let t=0;t<n;t++)r[t]=t+e.position;const l=new o({faces:r});i(t,e,l),s.push(l)}}function l(t,o,e,n,r){if(!o)return;const i=o.position;if(!i)return;const s=o[t];if(s)a(s,0,e[t],n[t],s.length),n[t]+=s.length;else{const o=e[t];let s=n[t];const l=f[t];if(o){for(let t=0;t<i.length;t+=3)for(let e=0;e<l;e++)o[s++]=r;n[t]=s}}}function a(t,o,e,n,r){for(let i=0;i<r;i++)e[n++]=t[o++];return e}function c(t){let o=!1,e=!1,n=!1,r=!1;for(const i of t){const t=i.vertexAttributes;if(t&&t.position&&(t.uv&&(o=!0),t.normal&&(e=!0),t.tangent&&(r=!0),t.color&&(n=!0),e&&o&&n&&r))break}return{normal:e,uv:o,color:n,tangent:r}}function u(t){let o=0,e=0,n=0,r=0,i=0;const s=c(t);for(const l of t){const t=l.vertexAttributes;t&&t.position&&(o+=t.position.length,s.uv&&(e+=t.position.length/f.position*f.uv),s.normal&&(n+=t.position.length/f.position*f.normal),s.color&&(r+=t.position.length/f.position*f.color),s.tangent&&(i+=t.position.length/f.position*f.tangent))}return{position:new Float64Array(o),uv:e?new Float32Array(e):null,normal:n?new Float32Array(n):null,tangent:i?new Float32Array(i):null,color:r?new Uint8Array(r):null}}const f={position:3,normal:3,tangent:4,uv:2,color:4};export{n as merge};
