/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{_ as t}from"../chunks/tslib.es6.js";import"../core/has.js";import{clone as e}from"../core/lang.js";import o from"../core/Logger.js";import"../core/accessorSupport/ensureType.js";import{property as r}from"../core/accessorSupport/decorators/property.js";import{subclass as n}from"../core/accessorSupport/decorators/subclass.js";import s from"../core/Error.js";import"../core/urlUtils.js";import"../core/uuid.js";import"../portal/support/resourceExtension.js";import{throwIfAborted as i}from"../core/promiseUtils.js";import a from"./Geometry.js";import c from"./Point.js";import m from"./Extent.js";import p from"./Polygon.js";import{f as l,c as h}from"../chunks/vec3f64.js";import{a as u}from"../chunks/vec4f64.js";import{MeshVertexAttributes as f}from"./support/MeshVertexAttributes.js";import x from"./support/MeshComponent.js";import{triangulate as y}from"./support/triangulationUtils.js";import{centerAt as d}from"./support/meshUtils/centerAt.js";import{merge as g}from"./support/meshUtils/merge.js";import{offset as j}from"./support/meshUtils/offset.js";import{convertUnitGeometry as w,createUnitSizeBox as v,createUnitSizeSphere as b,createUnitSizeCylinder as P,createUnitSizePlane as M,boxFaceOrder as A}from"./support/meshUtils/primitives.js";import{axisAngleFrom as F,axisAngleMultiply as U,rotate as z}from"./support/meshUtils/rotate.js";import{scale as C}from"./support/meshUtils/scale.js";var E;const T=o.getLogger("esri.geometry.Mesh");let L=E=class extends a{constructor(t){super(t),this.components=null,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new f,this.type="mesh"}get cache(){return this.commitProperty("components"),this.commitProperty("vertexAttributes"),this.commitProperty("hasM"),this.commitProperty("hasZ"),{}}get extent(){const t=this.spatialReference,e=this.vertexAttributes&&this.vertexAttributes.position;if(!e||0===e.length||this.components&&0===this.components.length)return new m({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:t});const o={xmin:1/0,xmax:-1/0,ymin:1/0,ymax:-1/0,zmin:1/0,zmax:-1/0,spatialReference:t};if(!this.components)return new m(this.extendExtent(o,e,null));for(const r of this.components){if(!r.faces){this.extendExtent(o,e,null);break}this.extendExtent(o,e,r.faces)}return new m(o)}addComponent(t){this.components||(this.components=[]),this.components.push(x.from(t)),this.notifyChange("components")}removeComponent(t){if(this.components){const e=this.components.indexOf(t);if(-1!==e)return this.components.splice(e,1),void this.notifyChange("components")}T.error("removeComponent()","Provided component is not part of the list of components")}rotate(t,e,o,r){return F(O.x,G(t),k),F(O.y,G(e),B),F(O.z,G(o),N),U(k,B,k),U(k,N,k),z(this,k,r),this}offset(t,e,o,r){return R[0]=t,R[1]=e,R[2]=o,j(this,R,r),this}scale(t,e){return C(this,t,e),this}centerAt(t,e){return d(this,t,e),this}clone(){const t=this.components?new Map:null,o=this.components?new Map:null,r=this.components?this.components.map((e=>e.cloneWithDeduplication(t,o))):null;return new E({components:r,spatialReference:this.spatialReference,vertexAttributes:e(this.vertexAttributes)})}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}toJSON(t){return this.write(null,t)}forEachVertex(t,e,o){if(e)for(let r=0;r<e.length;r++){const n=3*e[r];o(t[n+0],t[n+1],t[n+2])}else for(let r=0;r<t.length;r+=3)o(t[r+0],t[r+1],t[r+2])}extendExtent(t,e,o){return this.forEachVertex(e,o,((e,o,r)=>{t.xmin=Math.min(t.xmin,e),t.xmax=Math.max(t.xmax,e),t.ymin=Math.min(t.ymin,o),t.ymax=Math.max(t.ymax,o),t.zmin=Math.min(t.zmin,r),t.zmax=Math.max(t.zmax,r)})),t}async toBinaryGLTF(t){const{toBinaryGLTF:e}=await import("./support/meshUtils/exporters/gltf/gltfexport.js");return e(this,t)}static createBox(t,e){if(!(t instanceof c))return T.error(".createBox()","expected location to be a Point instance"),null;const o=new E(w(v(),t,e));return e&&e.imageFace&&"all"!==e.imageFace?S(o,e.imageFace):o}static createSphere(t,e){return t instanceof c?new E(w(b(e&&e.densificationFactor||0),t,e)):(T.error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(t,e){return t instanceof c?new E(w(P(e&&e.densificationFactor||0),t,e)):(T.error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(t,e){return t instanceof c?new E(w(M(e&&e.facing||"up"),t,e)):(T.error(".createPlane()","expected location to be a Point instance"),null)}static createFromPolygon(t,e){if(!(t instanceof p))return T.error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const o=y(t);return new E({vertexAttributes:{position:o.position},components:[{faces:o.faces,shading:"flat",material:e&&e.material||null}],spatialReference:t.spatialReference})}static async createFromGLTF(t,e,o){if(!(t instanceof c))throw T.error(".createfromGLTF()","expected location to be a Point instance"),new s("invalid-input","Expected location to be a Point instance");return new Promise(((r,n)=>{import("./support/loadGLTFMesh.js").then((async a=>{try{i(o);const n=await a.loadGLTFMesh(t,e,o);r(new E(g(n.map((t=>new E(t))),{reuseMaterials:!0})))}catch(c){n(new s("gltf-loader-error","Failed to load glTF.",`[${c.name}] ${c.message}`))}}))}))}};function S(t,e){const o=t.components[0],r=o.faces,n=A[e],s=6*n,i=new Uint32Array(6),a=new Uint32Array(r.length-6);let c=0,m=0;for(let u=0;u<r.length;u++)u>=s&&u<s+6?i[c++]=r[u]:a[m++]=r[u];const p=new Float32Array(t.vertexAttributes.uv),l=4*n*2,h=[0,1,1,1,1,0,0,0];for(let u=0;u<h.length;u++)p[l+u]=h[u];return t.vertexAttributes.uv=p,t.components=[new x({faces:i,material:o.material}),new x({faces:a})],t}function G(t){return t/180*Math.PI}t([r({json:{read:!1}})],L.prototype,"cache",null),t([r({type:[x]})],L.prototype,"components",void 0),t([r({readOnly:!0,json:{read:!1}})],L.prototype,"extent",null),t([r({readOnly:!0,json:{read:!1,write:!1}})],L.prototype,"hasZ",void 0),t([r({readOnly:!0,json:{read:!1,write:!1}})],L.prototype,"hasM",void 0),t([r({type:f,nonNullable:!0,json:{write:!0}})],L.prototype,"vertexAttributes",void 0),L=E=t([n("esri.geometry.Mesh")],L),L.prototype.toJSON.isDefaultToJSON=!0;const O={x:l(1,0,0),y:l(0,1,0),z:l(0,0,1)},R=h(),k=u(),B=u(),N=u();var J=L;export default J;
