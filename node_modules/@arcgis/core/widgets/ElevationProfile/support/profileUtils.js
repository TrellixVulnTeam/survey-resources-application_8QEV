/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{isNone as e,none as t,forEachSome as r}from"../../../core/maybe.js";import{splitIntoChunks as n}from"../../../core/arrayUtils.js";import{throwIfAborted as o,after as s,isAbortError as i,throwIfNotAbortError as l}from"../../../core/promiseUtils.js";import a from"../../../geometry/Multipoint.js";import{lerp as c}from"../../../core/mathUtils.js";import{Task as u}from"../../../views/support/Scheduler.js";import{QueueProcessor as p}from"../../../views/support/QueueProcessor.js";import{DELAY_AFTER_PREVIEW_MILLIS as m,DEFAULT_ELEVATION_PROFILE_QUERY_OPTIONS as f,ERROR_RESULT as d}from"./constants.js";import{ProfileGenerationError as h}from"./ProfileGenerationError.js";import{isValidInputPath as y,countPoints as w,densifyPath as g}from"./geometryUtils.js";import{getStatistics as v}from"./statisticsUtils.js";import{getIndices as P}from"./traversal.js";async function*Z(n,i){var l;const{view:a,geometry:c,elevationInfo:u,providers:p,options:f}=n;if(e(c)||!y(c))throw new h("invalid-geometry");const d=a.spatialReference,v=p.length;if(0===v)return t;const P=Math.round(f.maxTotalSamples/v);if(w(c)>P)throw new h("too-complex");const Z=await g(c,u,a,d,f,P,i);let R=0;const x=new Array(v),O=new Array(v);for(let e=0;e<v;e++){const t=A(Z);x[e]=t,R+=t.samples.length;const r={...n,provider:p[e],result:t,densificationResult:Z};O[e]=j(r,i)[Symbol.iterator]()}if(R>f.maxTotalSamples)throw new h("too-complex");const S=await Promise.all(O.map((e=>{const t=e.next();return!0===t.done?Promise.resolve(null):t.value})));o(i);for(let e=0;e<v;e++)x[e]=S[e];yield x,await s(null!=(l=n.delayAfterPreview)?l:m,null,i.signal);const q=[];try{let e;do{e=!1;for(let t=0;t<v;t++){const r=O[t].next();!1===r.done&&(q.push({resultPromise:r.value,index:t}),e=!0)}}while(e)}finally{O.forEach((e=>null==e.return?void 0:e.return()))}for(const{resultPromise:e,index:t}of q)x[t]=await e,o(i),yield x;r(x,(e=>{e.progress=1})),yield x}function*j(e,t){const{densificationResult:r}=e,o={...e,abortOptions:t,densificationResult:r},s=P(0,o.result.samples.length),i=s.slice(0,o.provider.numSamplesForPreview);yield R(o,i,!0);const l=n(s,o.provider.numSamplesPerChunk);for(const n of l)yield R(o,n,!1)}async function R({densificationResult:e,result:t,provider:r,queue:n,abortOptions:o,cache:s},l,c){const{densifiedPath:u,pathLength:p}=e,m=t.spatialReference,{samples:h}=t,y=new Array(l.length);for(let i=0;i<l.length;i++){const e=h[l[i]];y[i]=e.coordinate}try{return await n.push({geometry:new a({spatialReference:m,points:y,hasZ:u.hasZ}),provider:r,indices:l,preview:c,result:t,queryOptions:{...f,minDemResolution:c?Math.round(p/r.numSamplesForPreview):Math.round(p/h.length),cache:s}},o),{...t}}catch(w){return i(w)?null:d}}function x(e){return new p({task:u.ELEVATION_PROFILE,concurrency:1,scheduler:e,process:async e=>{o(e.queryOptions);try{await O(e)}catch(t){l(t)}}})}async function O({geometry:e,provider:t,indices:r,preview:n,result:o,queryOptions:s}){if(0===r.length)return;const i=(await b(t,e,s)).geometry,{hasZ:l,points:a}=i,c=s.noDataValue,{samples:u}=o;for(let p=0;p<r.length;p++){const e=u[r[p]];if(e.isHole)continue;const t=l?a[p][2]:null;null===t||t===c?e.sampledZ=null:(o.hasZ=!0,e.sampledZ=t),e.sampled=!0}S(u),o.progress=n?0:o.progress+r.length/u.length,o.statistics=v(o.samples,o.spatialReference)}function S(e){const t=e.length-1;let r=0;for(let n=1;n<=t;n++){(e[n].sampled||n===t)&&(q(e,r,n),r=n)}}function q(t,r,n){if(n-r==1)return;const o=t[r],s=o.sampledZ,i=t[n],l=i.sampledZ;if(e(s)||e(l)){for(let e=r+1;e<n;e++)t[e].sampledZ=null;return}const a=o.distance,u=i.distance-a;for(let e=r+1;e<n;e++){const r=t[e],n=(r.distance-a)/u;r.sampledZ=c(s,l,n)}}function A({densifiedPath:e,distances:t}){const r=e.spatialReference,n=e.paths,o=n.length,s=2*(o-1),i=n.reduce(((e,t)=>e+t.length),0)+s,l=new Array(i);let a=0,c=null,u=0;const p=(e,t,r,n)=>{l[a++]=U(e,r),l[a++]=U(t,n)};for(let m=0;m<o;m++){const e=n[m],r=t[m];for(let t=0;t<e.length;t++){const n=e[t],o=r[t];c&&0===t&&p(c,n,u,o),l[a++]=E(n,o),c=n,u=o}}return{progress:0,samples:l,hasZ:!1,statistics:null,spatialReference:r}}function E(e,t){return{coordinate:e,distance:t,sampledZ:null,sampled:!1,isHole:!1}}function U(e,t){return{coordinate:e,distance:t,sampledZ:null,sampled:!0,isHole:!0}}async function b(e,t,r){try{return await e.queryElevation(t,r)}catch(n){throw new h("elevation-query-error")}}export{x as createProfileQueue,j as generateProfile,Z as generateProfiles,S as interpolateElevations};
