/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import"../../../core/has.js";import{clone as t}from"../../../core/lang.js";import{isSome as i,destroyMaybe as r,removeMaybe as s,isNone as a}from"../../../core/maybe.js";import o from"../../../core/Logger.js";import"../../../core/accessorSupport/ensureType.js";import{property as n}from"../../../core/accessorSupport/decorators/property.js";import{subclass as l}from"../../../core/accessorSupport/decorators/subclass.js";import c from"../../../core/Error.js";import"../../../core/urlUtils.js";import"../../../core/uuid.js";import"../../../portal/support/resourceExtension.js";import{createAbortController as h,isAbortError as u,eachAlways as d}from"../../../core/promiseUtils.js";import m from"../../../core/Accessor.js";import p from"../../../core/Collection.js";import{EsriPromiseMixin as f}from"../../../core/Promise.js";import{result as y}from"../../../core/asyncUtils.js";import g from"../../../core/Handles.js";import{whenOnce as x,init as F}from"../../../core/watchUtils.js";import{isHostedAgolService as v}from"../../support/arcgisLayerUrl.js";import T from"../../../tasks/support/StatisticDefinition.js";import{WatchUpdatingTracking as E}from"../../../views/support/WatchUpdatingTracking.js";import w from"../../../views/3d/support/debugFlags.js";import{projectGeometry as C}from"../../../portal/support/geometryServiceUtils.js";import{FeatureTileFetcher3D as b}from"../../../views/3d/layers/support/FeatureTileFetcher3D.js";import{FeatureTileFetcher3DDebugger as D}from"../../../views/3d/layers/support/FeatureTileFetcher3DDebugger.js";var S;const _=o.getLogger("esri.layers.graphics.controllers.FeatureTileController3D");let O=S=class extends(f(m)){constructor(e){super(e),this.type="feature-tile-3d",this.watchUpdatingTracking=new E,this.serviceDataExtent=null,this.serviceDataCount=S.constants.NO_SERVICE_DATA_COUNT,this.vertexLimitExceeded=!1,this.displayFeatureLimit=null,this.suspended=!1,this.tileFetcher=null,this.handles=new g,this.fetchDataInfoPromise=null,this.fetchDataInfoAbortController=null,this.lifeCycleAbortController=h()}set extent(e){if(e&&!e.spatialReference.equals(this.layerView.view.spatialReference))return void _.error("#extent=","extent needs to be in the same spatial reference as the view");const t=this._get("extent");if(t===e)return;if(t&&e&&t.equals(e))return;const i=e?e.clone():null;this._set("extent",i)}get updating(){return!!(i(this.tileFetcher)&&this.tileFetcher.updating||null!=this.fetchDataInfoPromise||"tiles"===this.mode&&this.layerView.view.featureTiles&&this.layerView.view.featureTiles.updating||this.watchUpdatingTracking&&this.watchUpdatingTracking.updating)}get updatingTotal(){return this.updating&&i(this.tileFetcher)?this.tileFetcher.updatingTotal:0}get updatingRemaining(){return this.updating&&i(this.tileFetcher)?this.tileFetcher.updatingRemaining:0}get expectedFeatureDiff(){return this.updating&&i(this.tileFetcher)?this.tileFetcher.expectedFeatureDiff:0}get memoryForUnusedFeatures(){return i(this.tileFetcher)?this.tileFetcher.memoryForUnusedFeatures:0}get maximumNumberOfFeaturesExceeded(){return!(!i(this.tileFetcher)||!this.tileFetcher.maximumNumberOfFeaturesExceeded)}get maximumNumberOfFeatures(){return i(this.displayFeatureLimit)?this.displayFeatureLimit.maximumNumberOfFeatures:0}set maximumNumberOfFeatures(e){e!==this.maximumNumberOfFeatures&&(null==e?this._clearOverride("maximumNumberOfFeatures"):this._override("maximumNumberOfFeatures",e))}get hasMaximumNumberOfFeaturesOverride(){return this._isOverridden("maximumNumberOfFeatures")}get mode(){if(this.serviceDataCount===S.constants.NO_SERVICE_DATA_COUNT||this.vertexLimitExceeded)return"tiles";const{layer:e,view:t}=this.layerView,i=t&&t.featureTiles,r=i&&i.tilingScheme;if(e&&e.minScale&&this.serviceDataExtent&&r){const t=this.approximateExtentSizeAtScale(e.minScale,r);if((this.serviceDataExtent.width/t+this.serviceDataExtent.height/t)/2>S.constants.MAX_SNAPSHOT_MIN_SCALE_FACTOR)return"tiles"}return!this.maximumNumberOfFeatures||this.serviceDataCount<=this.maximumNumberOfFeatures?"snapshot":"tiles"}get maxTotalSnapshotVertices(){const e=this._get("maxTotalSnapshotVertices")||0,t="snapshot"===this.mode&&i(this.tileFetcher)&&this.tileFetcher.totalVertices||0;return Math.max(e,t)}approximateExtentSizeAtScale(e,t){const i=this.layerView.view,r=Math.ceil((i.width/t.pixelSize+i.height/t.pixelSize)/2),s=t.levels[0];return r*((s.tileSize[0]/(s.scale/e)+s.tileSize[1]/(s.scale/e))/2)}get tileDescriptors(){return"snapshot"===this.mode?new p([{id:"dummy-tile-full-extent",lij:[0,0,0]}]):this.layerView.view.featureTiles?this.layerView.view.featureTiles.tiles:new p}get test(){return{fetchDataInfoPromise:this.fetchDataInfoPromise,tileFetcher:this.tileFetcher}}initialize(){this.watchUpdatingTracking.add(this,"vertexLimitInfo",(()=>this.watchUpdatingTracking.addPromise(this.updateVertexLimitExceeded(null,this.lifeCycleAbortController.signal)))),this.watchUpdatingTracking.add(this,"mode",(()=>this.modeChanged()),2),this.addResolvingPromise(Promise.resolve().then((()=>this.verifyCapabilities())).then((()=>this.watchUpdatingTracking.addPromise(this.fetchServiceDataInfo()))).then((()=>this.initializeTileFetcher())))}verifyCapabilities(){const e=this.layerView.layer;if(!e.get("capabilities.operations.supportsQuery"))throw new c("graphicscontroller:query-capability-required","Service requires query capabilities to be used as a feature layer",{layer:e})}destroy(){this.cancelFetchServiceDataInfo(),this.tileFetcher=r(this.tileFetcher),this.handles=r(this.handles),this.tilesHandle=s(this.tilesHandle),this.lifeCycleAbortController&&(this.lifeCycleAbortController.abort(),this.lifeCycleAbortController=null),this.watchUpdatingTracking.destroy(),this._set("watchUpdatingTracking",null)}suspend(){this.suspended||(this.suspended=!0,i(this.tileFetcher)&&this.tileFetcher.suspend())}resume(){this.suspended&&(this.suspended=!1,i(this.tileFetcher)&&this.tileFetcher.resume())}restart(){const e=()=>{i(this.tileFetcher)&&this.tileFetcher.restart()};this.watchUpdatingTracking.addPromise(this.fetchServiceDataInfo().then(e,e))}refetch(){const e=()=>{i(this.tileFetcher)&&this.tileFetcher.refetch()};this.watchUpdatingTracking.addPromise(this.fetchServiceDataInfo().then(e,e))}initializeTileFetcher(){const e=this.layerView.view;if(!e)return;const t=x(e.featureTiles,"tilingScheme",this.lifeCycleAbortController.signal);this.watchUpdatingTracking.addPromise(t),t.then((()=>{const{layerView:t,tileDescriptors:i}=this,r=t.layer,s=new b({context:this.context,filterExtent:this.extent,tileDescriptors:i,features:this.graphics});this.tileFetcher=s,this.suspended?this.tileFetcher.suspend():this.tileFetcher.resume();const a=this.layerView.view.resourceController;a&&(this.handles.add(a.memoryController.events.on("quality-changed",(e=>{s.memoryFactor=e}))),this.tileFetcher.memoryFactor=a.memoryController.memoryFactor);const o="polygon"===this.context.geometryType?"polygonLodFactor":"polyline"===this.context.geometryType?"polylineLodFactor":null;o&&this.handles.add(F(this.layerView.view,"qualitySettings.graphics3D."+o,(e=>{s.lodFactor=e||1})));const n=e=>{s.maximumNumberOfFeatures=e,s.useTileCount=this.serviceDataCount>e},l=e=>s.useTileCount=e>this.maximumNumberOfFeatures;this.watchUpdatingTracking.add(r,"createQueryVersion",(()=>this.dataFilterChanged())),this.watchUpdatingTracking.add(t,"availableFields",((e,t)=>this.availableFieldsChanged(t,e))),this.watchUpdatingTracking.add(t,"requiredFields",((e,t)=>this.requiredFieldsChanged(t,e))),this.handles.add([r.on("apply-edits",(e=>this.applyEdits(e))),this.watch("extent",(e=>s.filterExtent=e),!0),this.watch("tileDescriptors",(e=>s.tileDescriptors=e),!0),F(this,"maximumNumberOfFeatures",n,!0),F(this,"serviceDataCount",l,!0),F(w,"FEATURE_TILE_FETCH_SHOW_TILES",(t=>{t&&s&&!s.debugger?(s.debugger=new D(s,e.featureTiles.tilingScheme.toTileInfo(),e),s.debugger.update()):!t&&this.tileFetcher&&s.debugger&&(s.debugger.destroy(),s.debugger=null)}))]),this.supportsExceedsLimitQuery||this.watchUpdatingTracking.add(this,"maxTotalSnapshotVertices",(()=>this.watchUpdatingTracking.addPromise(this.updateVertexLimitExceeded(null,this.lifeCycleAbortController.signal))))})).catch((()=>{}))}modeChanged(){switch(this.mode){case"tiles":this.tilesHandle||(this.tilesHandle=this.layerView.view.featureTiles.addClient());break;default:_.warn("Unhandled feature layer mode "+this.mode);case"snapshot":i(this.tilesHandle)&&(this.tilesHandle.remove(),this.tilesHandle=null)}}dataFilterChanged(){this._set("maxTotalSnapshotVertices",0),this.notifyChange("maxTotalSnapshotVertices"),this.refetch()}applyEdits(e){a(this.tileFetcher)||this.tileFetcher.applyEdits(e).then((e=>{e&&(e.deletedFeatures.length||e.updatedFeatures.length||e.addedFeatures.length)&&this.watchUpdatingTracking.addPromise(this.updateServiceDataExtent(this.lifeCycleAbortController.signal))})).catch((e=>{if(!u(e))throw e}))}availableFieldsChanged(e,t){i(this.tileFetcher)&&A(this.tileFetcher.availableFields,t)&&this.refetch()}requiredFieldsChanged(e,t){i(this.tileFetcher)&&A(this.tileFetcher.availableFields,t)&&this.restart()}createVertexLimitExceededQuery(e){const t=this.layerView.layer,i=t.createQuery();return i.outStatistics=[new T({statisticType:"exceedslimit",maxVertexCount:e,outStatisticFieldName:"exceedslimit",maxPointCount:1e8,maxRecordCount:1e8})],t.capabilities.query.supportsCacheHint&&(i.cacheHint=!0),i}createDataInfoQuery(){const e=this.layerView.layer,t=e.createQuery();return t.outSpatialReference=this.layerView.view.spatialReference,e.capabilities.query.supportsCacheHint&&(t.cacheHint=!0),t}fullExtentIsAccurate(){const e=this.layerView.layer;if(e.definitionExpression)return!1;switch(e.type){case"feature":return v(e.url);case"csv":case"geojson":case"ogc-feature":return!0;default:return}}async updateServiceDataExtent(e){try{await this.tryUpdateServiceDataExtent(e)}catch(i){u(i)||this._set("serviceDataExtent",t(this.layerView.fullExtentInLocalViewSpatialReference))}}async tryUpdateServiceDataExtent(e){const i=this.layerView,r=i.layer,s=r.capabilities.query.supportsExtent,a=t(i.fullExtentInLocalViewSpatialReference),o=r.fullExtent,n=this.fullExtentIsAccurate(),l=this.serviceDataCount;if(s&&l<=S.constants.MAX_FEATURE_COUNT_FOR_EXTENT&&(!a||!n)&&"queryExtent"in r){const t=this.createDataInfoQuery(),i=await r.queryExtent(t,{timeout:S.constants.QUERY_EXTENT_TIMEOUT,signal:e});this._set("serviceDataExtent",i.extent)}else if(a)this._set("serviceDataExtent",a);else if(o){const t="portalItem"in r?r.portalItem:null,s=await C(o,i.view.spatialReference,t,e);this._set("serviceDataExtent",s)}else this._set("serviceDataExtent",null)}async updateServiceDataCount(e){const t=this.layerView.layer;if(!("queryFeatureCount"in t)){const{NO_SERVICE_DATA_COUNT:e}=S.constants;return void this._set("serviceDataCount",e)}const i=await y(t.queryFeatureCount(this.createDataInfoQuery(),{timeout:S.constants.QUERY_STATISTICS_TIMEOUT,signal:e}));if(!0===i.ok)this._set("serviceDataCount",i.value);else{if(u(i.error))throw i.error;const{NO_SERVICE_DATA_COUNT:e}=S.constants;this._set("serviceDataCount",e)}}get vertexLimitInfo(){if(a(this.displayFeatureLimit)||a(this.displayFeatureLimit.averageSymbolComplexity))return null;const{averageSymbolComplexity:e,maximumTotalNumberOfPrimitives:t}=this.displayFeatureLimit,{primitivesPerCoordinate:i,primitivesPerFeature:r}=e,s=this._get("vertexLimitInfo");return a(s)||s.maximumTotalNumberOfPrimitives!==t||s.primitivesPerCoordinate!==i||s.primitivesPerFeature!==r?{primitivesPerCoordinate:i,primitivesPerFeature:r,maximumTotalNumberOfPrimitives:t}:s}get supportsExceedsLimitQuery(){const e=this.layerView.layer;return e.capabilities&&e.capabilities.operations&&e.capabilities.operations.supportsExceedsLimitStatistics}get minimumNumberOfVerticesForGeometry(){switch(this.layerView.layer.geometryType){case"point":case"multipoint":return 1;case"polygon":return 4;case"polyline":return 2;case"multipatch":case"mesh":return 3;default:return 0}}async updateVertexLimitExceeded(e,t){const r=this.vertexLimitInfo;if(a(r))return void this._set("vertexLimitExceeded",!1);const s=r.primitivesPerFeature<=0,o=this.minimumNumberOfVerticesForGeometry>1;if(!s&&!o)return void this._set("vertexLimitExceeded",!1);const{primitivesPerFeature:n,primitivesPerCoordinate:l,maximumTotalNumberOfPrimitives:c}=r;let h;0!==n&&i(e)&&await e;const d=this.serviceDataCount,m=d!==S.constants.NO_SERVICE_DATA_COUNT;if(h=m?Math.ceil((c-d*n)/(l||1)):Math.ceil(c/(l||1)),o&&(h=Math.min(h,N)),m&&this.minimumNumberOfVerticesForGeometry*d>h)return void this._set("vertexLimitExceeded",!0);if(!this.supportsExceedsLimitQuery)return void this._set("vertexLimitExceeded",this.maxTotalSnapshotVertices>h);const p=await y(this.layerView.layer.queryFeatures(this.createVertexLimitExceededQuery(h),{timeout:S.constants.QUERY_STATISTICS_TIMEOUT,signal:t}));if(!1===p.ok){if(u(p.error))throw p.error;return void this._set("vertexLimitExceeded",!1)}const f=p.value.features[0];f&&f.attributes?this._set("vertexLimitExceeded",!!f.attributes.exceedslimit):this._set("vertexLimitExceeded",!1)}async fetchServiceDataInfo(){this.cancelFetchServiceDataInfo();let e=h();const t=e.signal,i=this.updateServiceDataCount(t),r=d([i,this.updateVertexLimitExceeded(i,t)]),s=r.then((()=>this.updateServiceDataExtent(t))).catch((e=>{u(e)||_.error("#fetchServiceDataInfo()",e)})).then((()=>{s===this.fetchDataInfoPromise&&(this.fetchDataInfoPromise=null,this.fetchDataInfoAbortController=null),e=null}));return e&&(this.fetchDataInfoPromise=s),this.fetchDataInfoAbortController=e,r.then((()=>{}),(()=>{}))}cancelFetchServiceDataInfo(){const e=this.fetchDataInfoAbortController;e&&(this.fetchDataInfoAbortController=null,this.fetchDataInfoPromise=null,e.abort())}get debug(){return{storedFeatures:i(this.tileFetcher)?this.tileFetcher.storedFeatures:0,totalFeatures:i(this.tileFetcher)?this.tileFetcher.totalFeatures:0,totalVertices:i(this.tileFetcher)?this.tileFetcher.totalVertices:0}}};e([n({readOnly:!0})],O.prototype,"type",void 0),e([n({constructOnly:!0})],O.prototype,"graphics",void 0),e([n({constructOnly:!0})],O.prototype,"layerView",void 0),e([n({constructOnly:!0})],O.prototype,"context",void 0),e([n()],O.prototype,"extent",null),e([n()],O.prototype,"updating",null),e([n({readOnly:!0})],O.prototype,"watchUpdatingTracking",void 0),e([n()],O.prototype,"updatingTotal",null),e([n()],O.prototype,"updatingRemaining",null),e([n()],O.prototype,"expectedFeatureDiff",null),e([n()],O.prototype,"memoryForUnusedFeatures",null),e([n()],O.prototype,"maximumNumberOfFeaturesExceeded",null),e([n({readOnly:!0})],O.prototype,"serviceDataExtent",void 0),e([n({readOnly:!0})],O.prototype,"serviceDataCount",void 0),e([n({readOnly:!0})],O.prototype,"vertexLimitExceeded",void 0),e([n()],O.prototype,"displayFeatureLimit",void 0),e([n({type:Number})],O.prototype,"maximumNumberOfFeatures",null),e([n({readOnly:!0})],O.prototype,"mode",null),e([n({readOnly:!0})],O.prototype,"maxTotalSnapshotVertices",null),e([n({readOnly:!0,dependsOn:["mode"]})],O.prototype,"tileDescriptors",null),e([n()],O.prototype,"tileFetcher",void 0),e([n()],O.prototype,"fetchDataInfoPromise",void 0),e([n({readOnly:!0})],O.prototype,"vertexLimitInfo",null),O=S=e([l("esri.layers.graphics.controllers.FeatureTileController3D")],O);const I=1e4,U=12e3,V=1e4,N=5e6;function A(e,t){if(!t)return!1;for(const i of t)if(!e.has(i))return!0;return!1}!function(e){let t;!function(e){function t(){e.MAX_FEATURE_COUNT_FOR_EXTENT=I,e.QUERY_STATISTICS_TIMEOUT=U,e.QUERY_EXTENT_TIMEOUT=V}e.NO_SERVICE_DATA_COUNT=1/0,e.MAX_SNAPSHOT_MIN_SCALE_FACTOR=5,e.reset=t}(t=e.constants||(e.constants={}))}(O||(O={})),O.constants.reset();var L=O;export default L;
