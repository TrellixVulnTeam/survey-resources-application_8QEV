/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{clone as e}from"../../core/lang.js";import t from"../../renderers/visualVariables/SizeVariable.js";import{convertColorRampToColormap as n,getColorRampName as r}from"../../renderers/support/colorRampUtils.js";import{stretchTypeJSONDict as a}from"../../renderers/support/stretchRendererUtils.js";import o from"./RasterFunction.js";const i={u1:[0,1],u2:[0,3],u4:[0,15],u8:[0,255],s8:[-128,127],u16:[0,65535],s16:[-32768,32767]},s={simple_scalar:"Simple Scalar",wind_barb:"Wind Barb",single_arrow:"Single Arrow",beaufort_kn:"Beaufort Wind (Knots)",beaufort_m:"Beaufort Wind (MetersPerSecond)",ocean_current_m:"Ocean Current (MetersPerSecond)",ocean_current_kn:"Ocean Current (Knots)"},u=new Set(["raster-stretch","unique-value","class-breaks","raster-shaded-relief","vector-field","raster-colormap"]);function l(e){return u.has(e.type)}function m(t,n){if(!t||!n)return e(t||n);const r=e(t);if("none"!==n.functionName.toLowerCase()){p(r.functionArguments).Raster=n}return r}function c(e,t){switch(t=t||{},e.type){case"raster-stretch":return h(e,t);case"class-breaks":return b(e,t);case"unique-value":return R(e,t);case"raster-colormap":return v(e,t);case"vector-field":return d(e,t);case"raster-shaded-relief":return g(e,t)}}function p(e){const t=e.Raster;return t&&"esri.layers.support.RasterFunction"===t.declaredClass?p(t.functionArguments):e}const f={none:0,standardDeviation:3,histogramEqualization:4,minMax:5,percentClip:6,sigmoid:9};function d(e,n){const r=new o;r.functionName="VectorFieldRenderer";const{dataType:a,bandProperties:i}=n,u="vector-uv"===a;let l,m;i&&2===i.length&&(l=i.map((e=>e.BandName.toLowerCase())).indexOf("magnitude"),m=i.map((e=>e.BandName.toLowerCase())).indexOf("direction")),-1!==l&&null!==l||(l=0,m=1);const c="arithmetic"===e.rotationType?1:2,p="flow-from"===e.flowRepresentation?0:1,f=e.visualVariables?e.visualVariables.filter((e=>"Magnitude"===e.field))[0]:new t,d={magnitudeBandID:l,directionBandID:m,isUVComponents:u,referenceSystem:c,massFlowAngleRepresentation:p,symbolTileSize:50,symbolTileSizeUnits:100,calculationMethod:"Vector Average",symbologyName:s[e.style.toLowerCase().replace("-","_")],minimumMagnitude:f.minDataValue,maximumMagnitude:f.maxDataValue,minimumSymbolSize:f.minSize,maximumSymbolSize:f.maxSize};return r.functionArguments=d,r}function g(e,t){if("elevation"!==t.dataType)return new o;const r=new o;r.functionName="Hillshade";const a="traditional"===e.hillshadeType?0:1,i="none"===e.scalingType?1:3,s={HillshadeType:a,SlopeType:i,ZFactor:e.zFactor};return 0===a&&(s.Azimuth=e.azimuth,s.Altitude=e.altitude),3===i&&(s.PSPower=e.pixelSizePower,s.PSZFactor=e.pixelSizeFactor),r.functionArguments=s,r.variableName="Raster",e.colorRamp&&(r.functionName="ShadedRelief",s.Colormap=n(e.colorRamp,256)),r}function h(e,t){const i=new o;i.functionName="Stretch";const s=f[a.toJSON(e.stretchType)],u="u8",l={StretchType:s,Statistics:A(e.statistics),DRA:e.dynamicRangeAdjustment,UseGamma:e.useGamma,Gamma:e.gamma,ComputeGamma:e.computeGamma};if(null!=e.outputMin&&(l.Min=e.outputMin),null!=e.outputMax&&(l.Max=e.outputMax),s===f.standardDeviation?(l.NumberOfStandardDeviations=e.numberOfStandardDeviations,i.outputPixelType=u):s===f.percentClip?(l.MinPercent=e.minPercent,l.MaxPercent=e.maxPercent,i.outputPixelType=u):s===f.minMax?i.outputPixelType=u:s===f.sigmoid&&(l.SigmoidStrengthLevel=e.sigmoidStrengthLevel),i.functionArguments=l,i.variableName="Raster",e.colorRamp){const a=e.colorRamp,s=new o,u=r(a);return u?s.functionArguments={colorRamp:u}:!t.convertColorRampToColormap||"algorithmic"!==a.type&&"multipart"!==a.type?s.functionArguments={colorRamp:e.colorRamp.toJSON()}:s.functionArguments={Colormap:n(a,256)},s.variableName="Raster",s.functionName="Colormap",s.functionArguments.Raster=i,s}return i}function b(e,t){const n=[],r=[],a=[],i=[],s=1e-6,{pixelType:u,rasterAttributeTable:l}=t,m=l&&l.features,c=S(l);if(m&&Array.isArray(m)&&e.classBreakInfos){e.classBreakInfos.forEach(((t,n)=>{const r=t.symbol.color;let a;r.a&&m.forEach((o=>{a=o.attributes[e.field],(a>=t.minValue&&a<t.maxValue||n===e.classBreakInfos.length-1&&a>=t.minValue)&&i.push([o.attributes[c],r.r,r.g,r.b])}))}));const t=u?y(i,u):i,n=new o;return n.functionName="Colormap",n.functionArguments={},n.functionArguments.Colormap=t,n.variableName="Raster",n}e.classBreakInfos.forEach(((e,t)=>{const o=e.symbol&&e.symbol.color;o.a?(0===t?n.push(e.minValue,e.maxValue+s):n.push(e.minValue+s,e.maxValue+s),r.push(t),i.push([t,o.r,o.g,o.b])):a.push(e.minValue,e.maxValue)}));const p=u?y(i,u):i,f=new o;f.functionName="Remap",f.functionArguments={InputRanges:n,OutputValues:r,NoDataRanges:a},f.variableName="Raster";const d=new o;return d.functionName="Colormap",d.functionArguments={Colormap:p,Raster:f},d}function y(e,t){const n=i[String(t).toLowerCase()];return n&&e.push([Math.floor(n[0]-1),0,0,0],[Math.ceil(n[1]+1),0,0,0]),e}function S(e){if(!e)return;const{fields:t}=e,n=t&&t.find((e=>e&&e.name&&"value"===e.name.toLowerCase()));return n&&n.name}function R(e,t){const n=[],{pixelType:r,rasterAttributeTable:a}=t,i=a&&a.features,s=S(a);let u=!1;if(e.uniqueValueInfos&&e.uniqueValueInfos.forEach((t=>{const r=t.symbol.color;r.a&&(e.field!==s&&i?i&&i.forEach((a=>{String(a.attributes[e.field])===String(t.value)&&n.push([a.attributes[s],r.r,r.g,r.b])})):isNaN(+t.value)?u=!0:n.push([+t.value,r.r,r.g,r.b]))})),u)return null;const l=r&&n.length>0?y(n,r):n,m=new o;return m.functionName="Colormap",m.functionArguments={},m.functionArguments.Colormap=l,m.variableName="Raster",m}function v(e,t){const n=e.extractColormap();if(!n||0===n.length)return;const{pixelType:r}=t,a=r?y(n,r):n,i=new o;return i.functionName="Colormap",i.functionArguments={},i.functionArguments.Colormap=a,i}function A(e){const t=[];return e.forEach((e=>{const n=e;if(Array.isArray(n))t.push(n);else{if(null==n.min||null==n.max)return;const e=[n.min,n.max,n.avg||0,n.stddev||0];t.push(e)}})),t}export{m as combineRenderingRules,c as convertRendererToRenderingRule,l as isSupportedRendererType,i as pixelTypeRanges};
