/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{_ as t}from"../../../chunks/tslib.es6.js";import"../../../core/has.js";import{unwrap as e,isSome as r}from"../../../core/maybe.js";import"../../../core/Logger.js";import"../../../core/accessorSupport/ensureType.js";import{property as s}from"../../../core/accessorSupport/decorators/property.js";import{subclass as o}from"../../../core/accessorSupport/decorators/subclass.js";import i from"../../../core/Error.js";import"../../../core/urlUtils.js";import"../../../core/uuid.js";import"../../../portal/support/resourceExtension.js";import a from"../../../geometry/SpatialReference.js";import n from"../../../geometry/Point.js";import l from"../../../geometry/Extent.js";import"../../../geometry.js";import p from"../PixelBlock.js";import c from"../RasterInfo.js";import{isPlatformLittleEndian as f}from"../rasterFormats/utils.js";import{estimateStatisticsFromHistograms as m}from"../rasterFunctions/pixelUtils.js";import h from"../RasterStorageInfo.js";import u from"./BaseRaster.js";import{getElement as g,getElementValue as d}from"./xmlUtilities.js";import{parseSpatialReference as y,parsePAMInfo as x}from"./pamParser.js";const w=new Map;w.set("Int8","s8"),w.set("UInt8","u8"),w.set("Int16","s16"),w.set("UInt16","u16"),w.set("Int32","s32"),w.set("UInt32","u32"),w.set("Float32","f32"),w.set("Float64","f32"),w.set("Double64","f32");const I=new Map;I.set("lerc",".lrc"),I.set("none",".til"),I.set("deflate",".pzp"),I.set("jpeg",".jzp");let b=class extends u{constructor(){super(...arguments),this._files=null,this._storageIndex=null,this.datasetFormat="MRF"}async open(t){var s;await this.init(),this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const o=t?e(t.signal):null,i=await this.request(this.url,{responseType:"xml",signal:o}),{rasterInfo:a,files:n}=this._parseHeader(i.data);if(-1===(null==(s=this.ioConfig.skipExtensions)?void 0:s.indexOf("aux.xml"))){const e=await this._fetchAuxiliaryData(t);var l;if(null!=e)a.statistics=null!=(l=e.statistics)?l:a.statistics,a.histograms=e.histograms,e.histograms&&!r(a.statistics)&&(a.statistics=m(e.histograms))}this._set("rasterInfo",a),this._files=n;const p=await this.request(n.index,{responseType:"array-buffer",signal:o});this._storageIndex=this._parseIndex(p.data);let c,f,h=0,u=-1;const{blockWidth:g,blockHeight:d,compression:y}=this.rasterInfo.storageInfo,x=this.rasterInfo.storageInfo.pyramidScalingFactor,{width:w,height:I,bandCount:b}=this.rasterInfo,A=[],j="none"===y?1:b;for(;h<this._storageIndex.length;)u++,c=Math.ceil(w/g/x**u),f=Math.ceil(I/d/x**u),h+=c*f*j*4,A.push({maxRow:f,maxCol:c,minCol:0,minRow:0});this.rasterInfo.storageInfo.blockBoundary=A,u>0&&(this.rasterInfo.storageInfo.firstPyramidLevel=1,this.rasterInfo.storageInfo.maximumPyramidLevel=u),this.updateTileInfo()}async fetchRawTile(t,e,r,s={}){const{blockWidth:o,blockHeight:i,blockBoundary:a,compression:n}=this.rasterInfo.storageInfo,l=a[t];if(!l||l.maxRow<e||l.maxCol<r||l.minRow>e||l.minCol>r)return null;const{bandCount:c,pixelType:f}=this.rasterInfo,{ranges:m,actualTileWidth:h,actualTileHeight:u}=this._getTileLocation(t,e,r);if(!m||0===m.length)return null;if(0===m[0].from&&0===m[0].to){const t=new Uint8Array(o*i);return new p({width:o,height:i,pixels:null,mask:t,validPixelCount:0})}const{bandIds:g}=this.ioConfig,d="none"===n?1:c,y=[];let x=0;for(x=0;x<d;x++)(!g||g.indexOf[x]>-1)&&y.push(this.request(this._files.data,{range:{from:m[x].from,to:m[x].to},responseType:"array-buffer",signal:s.signal}));const w=await Promise.all(y),I=w.map((t=>t.data.byteLength)).reduce(((t,e)=>t+e)),b=new Uint8Array(I);let A=0;for(x=0;x<d;x++)b.set(new Uint8Array(w[x].data),A),A+=w[x].data.byteLength;const j="lerc"===this.rasterInfo.storageInfo.compression?"lerc":"bip",R=await this.decodePixelBlock(b.buffer,{width:o,height:i,format:j,pixelType:f});let _=0,F=0;if(h!==o||u!==i){let t=R.mask;if(t)for(x=0;x<i;x++)if(F=x*o,x<u)for(_=h;_<o;_++)t[F+_]=0;else for(_=0;_<o;_++)t[F+_]=0;else for(t=new Uint8Array(o*i),R.mask=t,x=0;x<u;x++)for(F=x*o,_=0;_<h;_++)t[F+_]=1}return R}_parseIndex(t){if(t.byteLength%16>0)throw"invalid array buffer must be multiples of 16";let e,r,s,o,i,a;if(f){for(r=new Uint8Array(t),o=new ArrayBuffer(t.byteLength),s=new Uint8Array(o),i=0;i<t.byteLength/4;i++)for(a=0;a<4;a++)s[4*i+a]=r[4*i+3-a];e=new Uint32Array(o)}else e=new Uint32Array(t);return e}_getTileLocation(t,e,r){const{blockWidth:s,blockHeight:o,pyramidScalingFactor:i,compression:a}=this.rasterInfo.storageInfo,{width:n,height:l,bandCount:p}=this.rasterInfo,c="none"===a?1:p;let f,m,h,u=0,g=0;for(h=0;h<t;h++)g=i**h,f=Math.ceil(n/s/g),m=Math.ceil(l/o/g),u+=f*m;g=i**t,f=Math.ceil(n/s/g),m=Math.ceil(l/o/g),u+=e*f+r,u*=4*c;const d=this._storageIndex.subarray(u,u+4*c);let y=0,x=0;const w=[];for(let I=0;I<c;I++)y=d[4*I+0]*2**32+d[4*I+1],x=y+d[4*I+2]*2**32+d[4*I+3],w.push({from:y,to:x});return{ranges:w,actualTileWidth:r<f-1?s:Math.ceil(n/g)-s*(f-1),actualTileHeight:e<m-1?o:Math.ceil(l/g)-o*(m-1)}}_parseHeader(t){const e=g(t,"MRF_META/Raster");if(!e)throw new i("mrf:open","not a valid MRF format");const r=g(e,"Size"),s=parseInt(r.getAttribute("x"),10),o=parseInt(r.getAttribute("y"),10),p=parseInt(r.getAttribute("c"),10),f=(d(e,"Compression")||"none").toLowerCase();if(!f||-1===["none","lerc"].indexOf(f))throw new i("mrf:open","currently does not support compression "+f);const m=d(e,"DataType")||"UInt8",u=w.get(m);if(null==u)throw new i("mrf:open","currently does not support pixel type "+m);const x=g(e,"PageSize"),b=parseInt(x.getAttribute("x"),10),A=parseInt(x.getAttribute("y"),10),j=g(e,"DataValues");let R,_;j&&(_=j.getAttribute("NoData"),null!=_&&(R=_.trim().split(" ").map((t=>parseFloat(t)))));if(g(t,"MRF_META/CachedSource"))throw new i("mrf:open","currently does not support MRF referencing other data files");const F=g(t,"MRF_META/GeoTags"),M=g(F,"BoundingBox");if(null==M)throw new i("mrf:open","missing node MRF_META/GeoTags/BoundingBox");const T=parseFloat(M.getAttribute("minx")),k=parseFloat(M.getAttribute("miny")),C=parseFloat(M.getAttribute("maxx")),U=parseFloat(M.getAttribute("maxy")),L=d(F,"Projection")||"",S=d(t,"datafile"),v=d(t,"IndexFile");let B;if("LOCAL_CS[]"!==L)if(L.toLowerCase().startsWith("epsg:")){const t=Number(L.slice(5));isNaN(t)||0===t||(B=new a({wkid:t}))}else B=y(L);const P=new l(T,k,C,U);P.spatialReference=B;const E=g(t,"MRF_META/Rsets"),H=parseInt(E&&E.getAttribute("scale")||"2",10),W=new h({origin:new n({x:P.xmin,y:P.ymax,spatialReference:B}),blockWidth:b,blockHeight:A,pyramidBlockWidth:b,pyramidBlockHeight:A,compression:f,pyramidScalingFactor:H}),D=new n({x:(C-T)/s,y:(U-k)/o,spatialReference:B});return{rasterInfo:new c({width:s,height:o,extent:P,spatialReference:B,bandCount:p,pixelType:u,pixelSize:D,noDataValue:R,storageInfo:W}),files:{mrf:this.url,index:v||this.url.replace(".mrf",".idx"),data:S||this.url.replace(".mrf",I.get(f))}}}async _fetchAuxiliaryData(t){try{const{data:e}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:null==t?void 0:t.signal});return x(e)}catch{return null}}};t([s()],b.prototype,"_files",void 0),t([s()],b.prototype,"_storageIndex",void 0),t([s({type:String,json:{write:!0}})],b.prototype,"datasetFormat",void 0),b=t([o("esri.layers.support.rasterIO.MRFRaster")],b);var A=b;export default A;
