/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import"../../../core/has.js";import{isSome as t,unwrap as i}from"../../../core/maybe.js";import"../../../core/Logger.js";import"../../../core/accessorSupport/ensureType.js";import{property as s}from"../../../core/accessorSupport/decorators/property.js";import{subclass as n}from"../../../core/accessorSupport/decorators/subclass.js";import r from"../../../core/Error.js";import"../../../core/urlUtils.js";import"../../../core/uuid.js";import"../../../portal/support/resourceExtension.js";import{isAbortError as o}from"../../../core/promiseUtils.js";import a from"../../../geometry/Extent.js";import"../../../geometry.js";import l from"../DimensionalDefinition.js";import{clip as c}from"../rasterFunctions/pixelUtils.js";import p from"./BaseRaster.js";import{coordsReversedForWKID as d}from"../wmsUtils.js";import{parse as h}from"./multipartParser.js";import{parseCapabilities as u}from"./wcsCapabilitiesParser.js";import{standardizeInterpolations as f,parseCoverages as g}from"./wcsCoverageParser.js";const m=["nearest neighbor","bilinear","bicubic"],v=["nearest","linear","cubic"];let x=class extends p{constructor(){super(...arguments),this.datasetFormat="WCSServer"}async open(e){await this.init();const t=null==e?void 0:e.signal,i=await this._getCapabilities(t);if(this.capabilities=i,!this.version){var s;let e=null==(s=i.capabilitiesVersion)?void 0:s.slice(0,3);"2.0"===e||"1.1"===e||"1.0"===e?this.version=i.capabilitiesVersion:(e=i.supportedVersions.find((e=>"2.0.1"===e))||i.supportedVersions.find((e=>"2.0"===e.slice(0,3)))||i.supportedVersions.find((e=>"1.1"===e.slice(0,3)))||i.supportedVersions.find((e=>"1.0"===e.slice(0,3)))||"1.0.0",this.version=e)}null==this.coverageId&&(this.coverageId=i.coverages[0].id);const n=i.coverages.filter((e=>e.id===this.coverageId))[0];if(null==n)throw new r("wcsraster-open",`the coverageId ${this.coverageId} does not exist in capabilities`);const o=await this._describeCoverage(t);this.coverageInfo=o[0],"2.0"===this.version.slice(0,3)&&(this.coverageInfo.lonLatEnvelope=n.lonLatEnvelope,this.coverageInfo.supportedInterpolations=f(i.supportedInterpolations)),this.datasetName=this.coverageInfo.title;const{rasterInfo:a}=this.coverageInfo;if(this.createRemoteDatasetStorageInfo(a,512,512),this._set("rasterInfo",a),null==a.spatialReference)throw new r("wcsraster-open",`coverage without spatial referernce is not supported: ${this.coverageId}`);const{pixelType:l,bandCount:c}=await this._getPixelTypeAndBandCount(t);a.pixelType=l,1===a.bandCount&&c>1&&(a.bandCount=c),this.updateTileInfo()}async fetchRawTile(e,t,i,s={}){if(this.isBlockOutside(e,t,i))return null;const{nativePixelSize:n,spatialReference:o}=this.rasterInfo,a=2**e,l=n.x*a,p=n.y*a,{blockWidth:d,blockHeight:h}=this.getBlockWidthHeight(e),{origin:u}=this.rasterInfo.storageInfo.tileInfo,f=this.getTileExtent({x:l,y:p},t,i,u,o,[d,h]),g=this.rasterInfo.extent,m=f.xmax>g.xmax||f.ymin<g.ymin;let v=f,x=d,w=h;if(m&&(v=f.clone().intersection(g),x=Math.floor((v.xmax-v.xmin)/l),w=Math.floor((v.ymax-v.ymin)/p),v.xmax=v.xmin+l*x,v.ymin=v.ymax-p*w),x<=1||w<=1)return null;const y=await this._getCoverage(v,x,w,a,s);if(!y)return null;let I=await this.decodePixelBlock(y,{width:x,height:w,planes:null,pixelType:null});if(I&&(I.width!==x||I.height!==w))throw new r("wcsraster-fetch",`the reponse has unexpected dimension width: ${I.width}, height: {pixelBlock.height}`);return m&&(I=c(I,{x:0,y:0},{width:h,height:h})),I}async _getCapabilities(e){const t={service:"WCS",request:"GetCapabilities"};this.version&&(t.version=this.version,t.acceptVersions=this.version);try{const{data:i}=await this.request(this.url,{query:t,responseType:"xml",signal:e});return u(i)}catch(i){if(!o(i))throw new r("wcslayer:open","wcs capabilities is not valid or supported");throw i}}async _describeCoverage(e){const t={service:"WCS",request:"DescribeCoverage",version:this.version},i=this.version.slice(0,3);"1.0"===i?t.coverage=this.coverageId:"1.1"===i?t.identifiers=this.coverageId:"2.0"===i&&(t.coverageId=this.coverageId);try{const{data:i}=await this.request(this.url,{query:t,responseType:"xml",signal:e});return g(i,this.version)}catch(s){if(!o(s))throw new r("wcslayer:open","wcs coverage description is not valid or supported");throw s}}async _getPixelTypeAndBandCount(e){const{pixelSize:s,extent:n,multidimensionalInfo:o}=this.rasterInfo,c=n.center,p=new a({xmin:c.x-s.x,xmax:c.x+s.x,ymin:c.y-s.y,ymax:c.y+s.y,spatialReference:n.spatialReference});let d;if(t(o)){const e=o.variables[0];d=[],e.dimensions.forEach((t=>{d.push(new l({variableName:e.name,dimensionName:t.name,values:t.hasRegularIntervals?t.extent[0]:t.values[0],isSlice:!0}))}))}const h=await this._getCoverage(p,2,2,1,{multidimensionalDefinition:d,signal:i(e)});if(!h)throw new r("wcsraster-open","unable to determine pixel type");const u=await this.decodePixelBlock(h,{width:2,height:2,planes:null,pixelType:null});return{pixelType:u.pixelType,bandCount:u.getPlaneCount()}}async _getCoverage(e,t,i,s,n){const{coverageDescription:o}=this.coverageInfo,{version:a}=o,l="2.0"===o.version?this._getCoverage201Parameters(e,t,i,s,n,o):"1.1"===o.version?this._getCoverage110Parameters(e,t,i,n,o):this._getCoverage100Parameters(e,t,i,n),c="2.0"===o.version?await this.request(this._constructWCS201Url(l),{signal:n.signal,responseType:"array-buffer"}):await this.request(this.url,{query:l,signal:n.signal,responseType:"array-buffer"});if("1.0"===a)return c.data;const p=h(c);if(p.isMultipart&&p.data){const e=p.data.filter((e=>{var t;return(null==(t=e.contentType)?void 0:t.toLowerCase().includes("image"))&&null!=e.contentData}))[0];return null==e?void 0:e.contentData}if(this.ioConfig.allowAnyMediaType)return c.data;throw new r("wcsraster:getcoverage","response is not a valid coverage, multipart response is expected")}_getInterpolationIndex(e){return-1===this.coverageInfo.supportedInterpolations.indexOf(e)||"nearest"===e?0:"bilinear"===e?1:"cubic"===e?2:0}_getCoverage100Parameters(e,t,i,s){const n=`${e.xmin},${e.ymin},${e.xmax},${e.ymax}`,r=e.spatialReference.wkid,o=(this.coverageInfo.supportedFormats||[]).find((e=>e.toLowerCase().indexOf("tiff")>-1))||"GEOTIFF",{bandIds:a,interpolation:l}=s,c=this._getInterpolationIndex(l),p=a?a.map((e=>this.coverageInfo.bandNames[e])):null,d=m[c];return{service:"WCS",request:"GetCoverage",version:this.version,coverage:this.coverageId,format:o,crs:`EPSG:${r}`,bbox:n,width:t,height:i,interpolation:d,band:null==p?void 0:p.join(",")}}_getCoverage110Parameters(e,t,i,s,n){var r;const{multidimensionalDefinition:o,bandIds:a,interpolation:l}=s,c=e.spatialReference.wkid,p=`urn:ogc:def:crs:EPSG::${c}`,h=(this.coverageInfo.supportedFormats||[]).find((e=>e.toLowerCase().indexOf("tiff")>-1))||"image/tiff",u=this._getInterpolationIndex(l),f=v[u],g=null==l||0===(null==(r=this.coverageInfo.supportedInterpolations)?void 0:r.indexOf(l)),m=n.domain.spatialDomain,x=m.origin.x<=m.envelope.xmin&&m.origin.y<=m.envelope.ymin,w=e.width/t,y=e.height/i*(x?1:-1),I=x?[e.xmin,e.ymin]:[e.xmin,e.ymax],b=m.useEPSGAxis&&d(c),C=b?`${I[1]},${I[0]}`:`${I[0]},${I[1]}`,$=b?`${y},0,0,${w}`:`${w},0,0,${y}`,S=w/2,j=e.xmin+S,T=e.xmax-S,_=Math.abs(y)/2,O=e.ymin+_,P=e.ymax-_,L=b?`${O},${j},${P},${T},${p}`:`${j},${O},${T},${P},${p}`,E=n.range.filter((e=>e.axis.some((e=>e.identifier.toLowerCase().indexOf("band")>-1))))[0];let R,q=E&&f&&a?g?`${E.identifier}[${E.axis[0].identifier}[${a.join(",")}]]`:`${E.identifier}:${f}[${E.axis[0].identifier}[${a.join(",")}]]`:null;if(null!=o&&o.length)for(let d=0;d<o.length;d++){let e=o[d].values;const t=o[d].dimensionName.toLowerCase(),i=o[d].variableName.toLowerCase();if(e.length>0)if(e[0]instanceof Array&&(e=e[0]),"stdtime"===t)R=e.map((e=>this._convertToISOTime(e))).join(",");else{const s=n.range.filter((e=>e.identifier.toLowerCase()===i))[0];if(s){const i=s.axis.filter((e=>e.identifier.toLowerCase()===t))[0];i&&(q=g?s.identifier+"["+i.identifier+"["+e.join(",")+"]]":s.identifier+":"+f+"["+i.identifier+"["+e.join(",")+"]]")}}}return{service:"WCS",request:"GetCoverage",version:this.version,identifier:this.coverageId,format:h,crs:`EPSG:${c}`,boundingbox:L,gridCS:"urn:ogc:def:cs:OGC:0.0:Grid2dSquareCS",gridType:"urn:ogc:def:method:WCS:1.1:2dGridIn2dCrs",gridOrigin:C,gridOffsets:$,gridBaseCRS:p,timeSequence:R,rangeSubset:q}}_convertToISOTime(e,t=!1){return(t?new Date(24*(e-25569)*60*60*1e3):new Date(e)).toISOString()}_getCoverage201Parameters(e,t,i,s,n,r){const{multidimensionalDefinition:o,interpolation:a}=n,l=this._getInterpolationIndex(a);let c=null;const{supportedInterpolations:p}=this.capabilities;if(null!=p&&p.length)switch(l){case 0:c=p.find((e=>e.includes("nearest")));break;case 1:c=p.find((e=>e.includes("linear")));break;case 2:c=p.find((e=>e.includes("cubic")||e.includes("quadratic")))}const d=(this.coverageInfo.supportedFormats||[]).find((e=>e.toLowerCase().indexOf("tiff")>-1))||"image/tiff",{bandNames:h}=this.coverageInfo,{boundedBy:u,domainSet:f,rangeType:g}=r,m=u.isEastFirst?0:1,v=1-m,{axisLabels:x}=u,w=x[m],y=x[v],I=`http://www.opengis.net/def/crs/EPSG/0/${e.spatialReference.wkid}`,b=I,C=[];C.push(`${w}(${e.xmin},${e.xmax})`),C.push(`${y}(${e.ymin},${e.ymax})`);const $=[];if(x.length>2)for(let P=2;P<x.length;P++){const e=f.origin[P];if(x[P].toLowerCase().indexOf("time")>-1){let t=e.toString();u.uomLabels[P].toLowerCase().indexOf("ole")>-1&&($.push(x[P]),t=this._convertToISOTime(e,!0)),C.push(x[P]+",http://www.opengis.net("+t+")")}else C.push(x[P]+",http://www.opengis.net("+e+")")}let S=null;if(null!=o&&o.length){const e=[];g.forEach((t=>t.forEach((t=>e.push(t.name)))));const t=[];for(let i=0;i<o.length;i++){const s=x.find((e=>e===o[i].dimensionName)),n=e.find((e=>e===o[i].variableName));if(-1===t.indexOf(n)&&t.push(n),s){let e=o[i].values;if(e.length>0){Array.isArray(e[0])&&(e=e[0]);let t="";t=s.toLowerCase().indexOf("time")>-1?e.map((e=>this._convertToISOTime(e))).join(","):e.join(",");const i=C.findIndex((e=>0===e.indexOf(s+",http://www.opengis.net")));-1===i&&C.push(s+",http://www.opengis.net("+t+")"),-1!==i&&-1===C[i].indexOf("("+t+")")&&C.splice(i,1,s+",http://www.opengis.net("+t+")")}}}t.length&&(S=t.join(","))}else if(null!=h&&h.length){S=(n.bandIds?n.bandIds.map((e=>h[e])):h).join(",")}const j=C.join("&subset="),T=!(r.domainSet.axisLabels.join("")===r.boundedBy.axisLabels.join(""))&&!1!==this.ioConfig.allowScaleFactor,_=T?null:`${w}(${t}),${y}(${i})`,O=T?1/s:null;return{service:"WCS",request:"GetCoverage",version:this.version,coverageId:this.coverageId,rangesubset:S,interpolation:c,scaleSize:_,scaleFactor:O,subset:j,format:d,mediaType:this.ioConfig.allowAnyMediaType?null:"multipart/related",outputcrs:I,subsettingcrs:b}}_constructWCS201Url(e){const t={...this.ioConfig.customFetchParameters,...e},i=[];Object.keys(t).forEach((e=>{const s=t[e];null!=s&&("subset"===e?s.split("&subset=").forEach((e=>{e&&i.push(`subset=${encodeURIComponent(e)}`)})):i.push(`${e}=${encodeURIComponent(s)}`))}));return`${encodeURI(this.url)}?${i.join("&")}`}};e([s({type:String,json:{write:!0}})],x.prototype,"datasetFormat",void 0),e([s()],x.prototype,"tileType",void 0),e([s({type:String,json:{write:!0}})],x.prototype,"version",void 0),e([s({type:String,json:{write:!0}})],x.prototype,"coverageId",void 0),x=e([n("esri.layers.support.rasterDatasets.ImageServerRaster")],x);var w=x;export default w;
